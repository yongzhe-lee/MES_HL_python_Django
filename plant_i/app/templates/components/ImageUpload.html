{# ★ 변경: uid 확보 (전달 없으면 기본값) #}
{% with uid=uniqueId|default:'woImage' %}
<div class="file-section">
	<h3>사진</h3>

	<!-- ★ 변경: 모든 id에 {{ uid }}_ 접두사 -->
	<!-- 파일 선택 및 드래그 영역 -->
	<div class="file-upload-container" id="{{ uid }}_uploadContainer">
		<input type="file" id="{{ uid }}_imageInput" multiple accept=".png,.jpg,.jpeg,.gif" hidden />
		<button type="button" class="upload-button" id="{{ uid }}_uploadButton">
			파일선택
		</button>

		<div id="{{ uid }}_dropZone" class="file-upload-box">
			<div class="upload-placeholder">업로드할 파일을 여기에 끌어다 놓으세요.</div>
		</div>
	</div>

	<!-- 업로드된 파일 미리보기 영역 -->
	<div class="uploaded-files-preview" id="{{ uid }}_previewContainer"></div>

	<!-- 파일 그리드 영역 -->
	<div class="file-grid">
		<table class="file-table">
			<thead>
				<tr>
					<th></th>
					<th>파일명</th>
					<th>용량</th>
					<th>삭제</th>
				</tr>
			</thead>
			<tbody id="{{ uid }}_fileTableBody"></tbody>
		</table>
	</div>

	<!-- 파일 정보 영역 -->
	<div class="file-info-footer">
		<div class="file-count-info">
			total count : <span class="count-badge" id="{{ uid }}_totalCount">0</span>
			<span class="total-size" id="{{ uid }}_totalSize">total size : 0 KB</span>
		</div>
		<div class="file-type-info">
			허용되는 파일 형식 : png, gif, jpg (파일크기제한 : 10MB)
		</div>
	</div>
</div>
<style>
	
</style>
<script>
	// ★ 변경: 헬퍼 - 현재 인스턴스용 getter (스코프 분리)
	(function() {
		const __UID__ = '{{ uid }}'; // ★ 변경
		const gid = (name) => document.getElementById(__UID__ + '_' + name); // ★ 변경
		const gns = (key) => window[__UID__ + '_' + key];                     // ★ 변경
		const setGns = (key, val) => (window[__UID__ + '_' + key] = val);    // ★ 변경

	// ★ 변경: 인스턴스별 상태 저장 (기존 window.imagesData → uid별 상태)
	if (!gns('imagesData')) setGns('imagesData', []);                     // ★ 변경

	// ★ 변경: DOM 캐시도 uid별로
	setGns('imageInput', gid('imageInput'));                              // ★ 변경
	setGns('dropZone', gid('dropZone'));                                  // ★ 변경
	setGns('previewContainer', gid('previewContainer'));                  // ★ 변경
	setGns('fileTableBody', gid('fileTableBody'));                        // ★ 변경
	setGns('totalCount', gid('totalCount'));                              // ★ 변경
	setGns('totalSize', gid('totalSize'));                                // ★ 변경

	// 기존: window.IMAGE_MAX_SIZE/ALLOWED_TYPES는 공용이라 유지해도 OK
	if (typeof window.IMAGE_MAX_SIZE === 'undefined') {
		window.IMAGE_MAX_SIZE = 10 * 1024 * 1024;
	}
	if (typeof window.IMAGE_ALLOWED_TYPES === 'undefined') {
		window.IMAGE_ALLOWED_TYPES = ['image/png', 'image/jpeg', 'image/gif'];
	}

	if (typeof window.ImageUploader === 'undefined') {
		class ImageUploader {
			constructor() {
				this.tableName = '{{ tableName }}';
				this.attachName = '{{ attachName }}';
				this.dataPk = '{{ dataPk }}' || '';
				this._previousDataPk = this.dataPk;
				this.readOnly = false;
				this.uid = __UID__;                                            // ★ 변경
				this.init();
			}

			init() {
				this.bindEvents();
				if (this.dataPk) this.loadFilesFromServer();
				this.updateUIBasedOnMode();
			}

			// 읽기 모드 설정 메서드 추가
			setReadOnlyMode(isReadOnly) {
				this.readOnly = isReadOnly;
				this.updateUIBasedOnMode();
			}

			updateUIBasedOnMode() {
				const uploadContainer = gid('uploadContainer');
				const deleteHeader = document.querySelector('.file-table th:last-child');
				if (!uploadContainer || !deleteHeader) return;

				if (this.readOnly) {
					uploadContainer.style.display = 'none';
					deleteHeader.style.display = 'none';
				} else {
					uploadContainer.style.display = 'block';
					deleteHeader.style.display = 'table-cell';
				}
			}

			bindEvents() {
				const imageInput = gns('imageInput');                         // ★ 변경
				const dropZone  = gns('dropZone');                             // ★ 변경
				const uploadBtn = gid('uploadButton');                          // ★ 변경

				// 아래의 handleImages, renderImageTable, updateImageInfo 등은
				// window 전역이 아닌 "uid별 상태"를 참조하도록 바꿉니다.
				const getImages = () => gns('imagesData');                     // ★ 변경
				const setImages = (arr) => setGns('imagesData', arr);          // ★ 변경

				imageInput.addEventListener('change', e => {
					if (this.readOnly) { e.preventDefault(); return; }
					handleImages(e.target.files, getImages, setImages, this.uid);    // ★ 변경
					imageInput.value = '';
				});

				dropZone.addEventListener('dragover', e => e.preventDefault());
				dropZone.addEventListener('drop', e => {
					e.preventDefault();
					if (this.readOnly) return;
					handleImages(e.dataTransfer.files, getImages, setImages, this.uid); // ★ 변경
				});

				uploadBtn.addEventListener('click', e => {
					if (this.readOnly) { e.preventDefault(); return; }
					imageInput.click();
				});
			}

			// dataPk 설정 메서드 (외부에서 호출)
			setDataPk(newDataPk) {
				if (this.dataPk !== newDataPk) {
					this._previousDataPk = this.dataPk;
					this.dataPk = newDataPk;
					
					this.loadFilesFromServer();
				}
			}

			loadFilesFromServer(callback) {
				const url = '/api/files/upload?action=call_attach_file';
				const data = {
					action: 'call_attach_file',
					tableName: this.tableName,
					attachName: this.attachName,
					dataPk: this.dataPk || ''
				};

				AjaxUtil.postAsyncData(url, data, (res) => {
					if (res.success) {
						const tableBody = gns('fileTableBody');                      // ★ 변경
						const preview   = gns('previewContainer');                   // ★ 변경
						
						// 기존 테이블 초기화
						tableBody.innerHTML = '';
						preview.innerHTML = '';
						setGns('imagesData', []);                                    // ★ 변경

						// 받아온 파일 데이터로 테이블 생성
						if (res.data && Array.isArray(res.data)) {
							res.data.forEach((file, index) => {
								const fileData = {
									name: file.FileName,
									size: file.FileSize,
									id: file.id,
									file_index: file.FileIndex,
									src: '/uploads/plant_i/' + this.tableName + '/' + file.PhysicFileName
								};

								const images = gns('imagesData');
								images.push(fileData); setGns('imagesData', images);      // ★ 변경
								renderImageTable(index, this.uid);                        // ★ 변경
							});
						}

						updateImageInfo(this.uid);                                    // ★ 변경

						if (typeof callback === 'function') callback();
					} else {
						if (typeof callback === 'function') callback();
					}
				});
			}

			async saveImages() {
				const formData = new FormData();
				
				const preview = gns('previewContainer');                      // ★ 변경
				const imagesState = gns('imagesData');                        // ★ 변경
				const previewFiles = Array.from(preview.querySelectorAll('.file-item')).map(item => {
					const index = parseInt(item.dataset.index);
					return imagesState[index];
				}).filter(file => file);
				
				// 원본 File 객체(rawFile)로 바로 append
				for (let i = 0; i < previewFiles.length; i++) {
					const file = previewFiles[i].rawFile;
					if (file) {
						formData.append('uploadfile', file);
					}
				}

				if (previewFiles.length > 0) {
					formData.append('action', 'save_file');
					formData.append('tableName', this.tableName);
					formData.append('attachName', this.attachName);
					formData.append('dataPk', this.dataPk);
					formData.append('others', this.tableName);
					
					try {
						const csrfToken = getCookie('csrftoken');
						const response = await fetch('/api/files/upload', {
							method: 'POST',
							body: formData,
							credentials: 'include',
							headers: {'X-CSRFToken': csrfToken}
						});

						const result = await response.json();
						const failedFiles = result.filter(f => !f.success);

						if (failedFiles.length > 0) {
							const msg = failedFiles.map(f => `${f.fileNm}: ${f.message || '저장 실패'}`).join('\n');
							Alert.alert('일부 파일 저장 실패', msg);
						}

						// UI 초기화
						setGns('imagesData', []);                                  // ★ 변경
						preview.innerHTML = '';
						updateImageInfo(this.uid);                                 // ★ 변경
						this.loadFilesFromServer();
						return true;

					} catch (error) {
						console.error('이미지 저장 중 오류:', error);
						Alert.alert('오류', '이미지 저장 중 오류가 발생했습니다.');
						return false;
					}
				}			
			}

			// 현재 이미지 데이터 반환
			getImagesData() {
				return gns('imagesData');
			}

			// 이미지 데이터 초기화
			clearImages() {
				setGns('imagesData', []);
				gns('previewContainer').innerHTML = '';
				gns('fileTableBody').innerHTML = '';
				
				updateImageInfo(this.uid);
			}
		}
		window.ImageUploader = ImageUploader;
	}
	window.imageUploader = new window.ImageUploader();

	// ★ 변경: 헬퍼 함수들도 uid를 받아 동작(예시)
	function handleImages(fileList, getImages, setImages, uid) {
		const files = Array.from(fileList);
		const state = getImages();
		
		files.forEach((f) => {
			if (!window.IMAGE_ALLOWED_TYPES.includes(f.type)) return alert('지원하지 않는 파일 형식입니다.');
			if (f.size > window.IMAGE_MAX_SIZE) return alert('파일 크기는 최대 10MB까지 허용됩니다.');

			const reader = new FileReader();
			reader.onload = e => {
				const index = state.push({
					name: f.name,
					size: f.size,
					src: e.target.result,
					type: f.type,
					rawFile: f
				}) - 1;
				setImages([...state]);
				renderImagePreview(index, uid);
				updateImageInfo(uid);
			};
			reader.readAsDataURL(f);
		});
	}

	function renderImagePreview(index, uid) {
		const file = window[uid + '_imagesData'][index];
		const div = document.createElement('div');
		div.className = 'file-item file-doc-item';
		
		// 읽기 모드일 때 삭제 버튼 숨김 (현재 인스턴스의 readOnly 상태 사용)
		const currentUploader = window.imageUploader;
		const deleteButton = currentUploader && currentUploader.readOnly ? '' : 
			`<button type="button" class="delete-button" onclick="deleteImage(${index}, '${uid}')">×</button>`;
		
		div.innerHTML = `
			<div class="file-icon">
				<img src="${file.src}" alt="img" style="width: 48px; height: 48px;">
			</div>
			<div class="file-info">
				<span class="file-name">${file.name}</span>
				<span class="file-size">${(file.size / 1024).toFixed(1)} KB</span>
			</div>
			${deleteButton}
		`;
		div.dataset.index = index;
		document.getElementById(uid + '_previewContainer').appendChild(div);
	}

	function renderImageTable(index, uid) {
		const tableBody = document.getElementById(uid + '_fileTableBody');
		const file = window[uid + '_imagesData'][index];
		if (!file) return;

		const tr = document.createElement('tr');
		tr.dataset.index = index;
		
		// 읽기 모드일 때 삭제 버튼 숨김 (현재 인스턴스의 readOnly 상태 사용)
		const currentUploader = window.imageUploader;
		const deleteButton = currentUploader && currentUploader.readOnly ? '' : 
			`<td><button type="button" class="delete-button" onclick="deleteImage(${index}, '${uid}')">×</button></td>`;
		
		tr.innerHTML = `
			<td><img src="/static/img/no-image.png" style="width: 20px; height: 20px;"></td>
			<td><a href="javascript:void(0)" onclick="downloadFile(${file.id})">${file.name}</a></td>
			<td>${(file.size / 1024).toFixed(1)} KB</td>
			${deleteButton}
		`;
		tableBody.appendChild(tr);
	}

	function deleteImage(index, uid) {
		// 읽기 모드일 때는 삭제하지 않음
		if (window.imageUploader.readOnly) {
			console.log('읽기 모드에서는 이미지 삭제가 불가능합니다.');
			return;
		}

		const file = window[uid + '_imagesData'][index];
		if (!file) return;

		// 서버에 삭제 요청
		const url = '/api/files/upload?action=remove_file';
		const data = {
			tableName: window.imageUploader.tableName,
			attachName: window.imageUploader.attachName,
			fileName: file.name,
			others: 'equipment',
			dataPk: window.imageUploader.dataPk,
			fileIndex: file.file_index
		};

		AjaxUtil.postAsyncData(url, data, (res) => {
			if (res.success) {
				window[uid + '_imagesData'][index] = null;
				document.querySelectorAll(`[data-index="${index}"]`).forEach(el => el.remove());
				updateImageInfo(uid);
			}
		});
	}

	function updateImageInfo(uid) {
		const files = window[uid + '_imagesData'] || [];
		const cntEl = document.getElementById(uid + '_totalCount');
		const sizeEl = document.getElementById(uid + '_totalSize');
		const total = files.reduce((a,b)=>a + (b.size||0), 0);
		if (cntEl) cntEl.textContent = String(files.length);
		if (sizeEl) sizeEl.textContent = `total size : ${Math.round(total/1024)} KB`;
	}

	// 파일 다운로드 함수 추가
	function downloadFile(fileId) {
		window.location.href = `/api/files/download?file_id=${fileId}`;
	}

	// CSRF 토큰을 쿠키에서 추출하는 함수
	function getCookie(name) {
	    let cookieValue = null;
	    if (document.cookie && document.cookie !== '') {
	        const cookies = document.cookie.split(';');
	        for (let i = 0; i < cookies.length; i++) {
	            const cookie = cookies[i].trim();
	            if (cookie.substring(0, name.length + 1) === (name + '=')) {
	                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
	                break;
	            }
	        }
	    }
	    return cookieValue;
	}
	})(); // ★ 변경: IIFE 닫기
</script>

{# ★ 변경: with 블록 닫기 #}
{% endwith %}
