{# ★ 변경: uid 확보 (전달 없으면 기본값) #}
{% with uid=uniqueId|default:'woFile' %}
<div class="file-section">
	<h3>문서</h3>

	<!-- ★ 변경: 모든 id에 {{ uid }}_ 접두사 -->
	<!-- 파일 선택 및 드래그 영역 -->
	<div class="file-upload-container" id="{{ uid }}_uploadContainer">
		<input type="file" id="{{ uid }}_fileDocInput" multiple
			   accept=".xls,.xlsx,.pdf,.txt,.doc,.docx,.ppt,.pptx,.csv,.zip,.hwp,.png,.jpg,.jpeg,.gif" hidden />
		<button type="button" class="upload-button" id="{{ uid }}_uploadButton">파일선택</button>

		<div id="{{ uid }}_dropDocZone" class="file-upload-box">
			<div class="upload-placeholder">업로드할 파일을 여기에 끌어다 놓으세요.</div>
		</div>
	</div>

	<!-- 미리보기 (이미지) -->
	<div class="uploaded-docfiles-preview" id="{{ uid }}_previewDocContainer"></div>

	<!-- 테이블 -->
	<div class="file-grid">
		<table class="file-table">
			<thead>
				<tr>
					<th></th>
					<th>파일명</th>					
					<th>용량</th>
					<th id="{{ uid }}_deleteHeader">삭제</th>
				</tr>
			</thead>
			<tbody id="{{ uid }}_fileDocTableBody"></tbody>
		</table>
	</div>

	<!-- 정보 -->
	<div class="file-info-footer">
		<div class="file-count-info">
			total count : <span class="count-badge" id="{{ uid }}_docTotalCount">0</span>&nbsp;&nbsp;
			<span class="total-size" id="{{ uid }}_docTotalSize">total size : 0 KB</span>
		</div>
		<div class="file-type-info">
			허용되는 파일 형식 :
			xls, xlsx, pdf, txt, doc, docx, ppt, pptx, csv, zip, hwp, png, gif, jpg
			(파일크기제한 : 10MB)
		</div>
	</div>
</div>
<style>
	.file-table {
		width: 100%;
		border-collapse: collapse;
		text-align: left;
	}

	.file-table th,
	.file-table td {
		padding: 8px;
		border-bottom: 1px solid #ddd;
	}

	.file-table th {
		background-color: #f5f5f5;
		font-weight: bold;
	}

	.file-table td {
		vertical-align: middle;
	}

	.file-table th:nth-child(1),
	.file-table td:nth-child(1) {
		width: 10%;
	}

	.file-table th:nth-child(2),
	.file-table td:nth-child(2) {
		width: 60%;
	}

	.file-table th:nth-child(3),
	.file-table td:nth-child(3) {
		width: 20%;
		text-align: right;
	}

	.file-table th:nth-child(4),
	.file-table td:nth-child(4) {
		width: 10%;
		text-align: center;
	}
</style>
<script>
	// ★ 변경: 헬퍼 - 현재 인스턴스용 getter (스코프 분리)
	(function() {
		const __UID__ = '{{ uid }}'; // ★ 변경
		const gid = (name) => document.getElementById(__UID__ + '_' + name); // ★ 변경
		const gns = (key) => window[__UID__ + '_' + key];                     // ★ 변경
		const setGns = (key, val) => (window[__UID__ + '_' + key] = val);    // ★ 변경

	// ★ 변경: 인스턴스별 상태 저장 (기존 window.fileDocsData → uid별 상태)
	if (!gns('fileDocsData')) setGns('fileDocsData', []);                 // ★ 변경

	// ★ 변경: DOM 캐시도 uid별로
	setGns('fileDocInput', gid('fileDocInput'));                          // ★ 변경
	setGns('dropDocZone', gid('dropDocZone'));                            // ★ 변경
	setGns('previewDocContainer', gid('previewDocContainer'));            // ★ 변경
	setGns('fileDocTableBody', gid('fileDocTableBody'));                  // ★ 변경
	setGns('totalDocCount', gid('docTotalCount'));                        // ★ 변경
	setGns('totalDocSize', gid('docTotalSize'));                          // ★ 변경

	// 기존: window.DOC_MAX_SIZE/ALLOWED_TYPES는 공용이라 유지해도 OK
	if (typeof window.DOC_MAX_SIZE === 'undefined') {
		window.DOC_MAX_SIZE = 10 * 1024 * 1024;
	}
	if (typeof window.DOC_ALLOWED_TYPES === 'undefined') {
		window.DOC_ALLOWED_TYPES = [
			"application/vnd.ms-excel",
			"application/haansoftxlsx",
			"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
			"application/pdf",
			"text/plain",
			"application/msword",
			"application/haansoftdocx",
			"application/vnd.openxmlformats-officedocument.wordprocessingml.document",
			"application/vnd.ms-powerpoint",
			"application/vnd.openxmlformats-officedocument.presentationml.presentation",
			"text/csv",
			"application/zip",
			"application/x-zip-compressed",
			"application/x-hwp",
			"application/haansofthwp",
			"application/octet-stream",
			"image/png",
			"image/jpeg",
			"image/gif"
		];
	}

	// ★ 변경: FileUploader 클래스가 이미 정의되어 있는지 확인하고, 없을 때만 정의
	if (typeof window.FileUploader === 'undefined') {
		window.FileUploader = class FileUploader {
			constructor(uid, tableName, attachName, dataPk) {
				this.uid = uid;
				this.tableName = tableName;
				this.attachName = attachName;
				this.dataPk = dataPk || '';
				this._previousDataPk = this.dataPk;
				this.readOnly = false;
				this.init();
			}

			init() {
				this.bindEvents();
				// dataPk가 있을 때만 서버에서 파일 로드
				if (this.dataPk && this.dataPk.trim() !== '') {
					this.loadFilesFromServer();
				}
				this.updateUIBasedOnMode();
			}

			// 읽기 모드 설정 메서드 추가
			setReadOnlyMode(isReadOnly) {
				this.readOnly = isReadOnly;
				this.updateUIBasedOnMode();
			}

			updateUIBasedOnMode() {
				const uploadContainer = document.getElementById(this.uid + '_uploadContainer');
				const deleteHeader = document.getElementById(this.uid + '_deleteHeader');
				const dropZone = document.getElementById(this.uid + '_dropDocZone');
				const uploadButton = document.getElementById(this.uid + '_uploadButton');
				const fileInput = document.getElementById(this.uid + '_fileDocInput');				
				
				if (!uploadContainer || !deleteHeader) {
					return;
				}

				if (this.readOnly) {					
					if (uploadContainer) {
						uploadContainer.style.display = 'none';
					}
					
					if (deleteHeader) {
						deleteHeader.style.display = 'none';
					}
					
					if (dropZone) {
						dropZone.style.pointerEvents = 'none';
					}
					
					if (uploadButton) {
						uploadButton.style.display = 'none';
					}
					
					if (fileInput) {
						fileInput.disabled = true;
					}					
				} else {
					// 편집 모드: 모든 UI 요소들 표시
					
					if (uploadContainer) {
						uploadContainer.style.display = 'block';
					}
					
					if (deleteHeader) {
						deleteHeader.style.display = 'table-cell';
					}
					
					if (dropZone) {
						dropZone.style.pointerEvents = 'auto';
					}
					
					if (uploadButton) {
						uploadButton.style.display = 'inline-block';
					}
					
					if (fileInput) {
						fileInput.disabled = false;
					}
					
				}
				
			}

			bindEvents() {
				const fileInput = document.getElementById(this.uid + '_fileDocInput');
				const dropZone  = document.getElementById(this.uid + '_dropDocZone');
				const uploadBtn = document.getElementById(this.uid + '_uploadButton');

				// 이벤트 리스너가 이미 바인딩되어 있는지 확인
				if (this._eventsBound) {
					return;
				}
				this._eventsBound = true;

				// 아래의 handleFiles, renderTable, updateFileInfo 등은
				// window 전역이 아닌 "uid별 상태"를 참조하도록 바꿉니다.
				const getFiles = () => window[this.uid + '_fileDocsData'];
				const setFiles = (arr) => (window[this.uid + '_fileDocsData'] = arr);

				fileInput.addEventListener("change", e => {
					e.preventDefault();
					e.stopPropagation();
					if (this.readOnly) { 
						return; 
					}
					
					// 파일이 선택되었을 때만 처리
					if (e.target.files && e.target.files.length > 0) {
						window[this.uid + '_handleFiles'](e.target.files, getFiles, setFiles, this.uid);
					} else {
					}
					
					// 파일 입력 초기화는 약간의 지연 후 실행
					setTimeout(() => {
						fileInput.value = '';
					}, 100);
				}, { once: false, passive: false });

				dropZone.addEventListener("dragover", e => {
					e.preventDefault();
					e.stopPropagation();
				});
				dropZone.addEventListener("drop", e => {
					e.preventDefault();
					e.stopPropagation();
					if (this.readOnly) return;
					window[this.uid + '_handleFiles'](e.dataTransfer.files, getFiles, setFiles, this.uid);
				});

				uploadBtn.addEventListener("click", e => {
					e.preventDefault();
					e.stopPropagation();
					
					if (this.readOnly) { 
						return; 
					}
					
					// fileInput이 실제로 존재하고 접근 가능한지 확인
					if (!fileInput) {
						return;
					}
					
					if (fileInput.disabled) {
						return;
					}
					
					try {
						fileInput.click();
					} catch (error) {
					}
				});
				
			}

			setDataPk(newDataPk) {
				if (this.dataPk !== newDataPk) {
					this._previousDataPk = this.dataPk;
					this.dataPk = newDataPk;
					
					// dataPk가 있을 때만 서버에서 파일 로드
					if (this.dataPk) {
						this.loadFilesFromServer();
					}
				}
			}

			loadFilesFromServer(callback) {
				if (!this.dataPk) { if (typeof callback === 'function') callback(); return; }
				const tableBody = document.getElementById(this.uid + '_fileDocTableBody');
				const preview   = document.getElementById(this.uid + '_previewDocContainer');

				const url = '/api/files/upload?action=call_attach_file';
				const data = {
					action: 'call_attach_file',
					tableName: this.tableName,
					attachName: this.attachName,
					dataPk: this.dataPk || ''
				};


				AjaxUtil.postAsyncData(url, data, (res) => {
					if (res.success) {
						
						tableBody.innerHTML = '';
						preview.innerHTML = '';
						window[this.uid + '_fileDocsData'] = [];

						res.data.forEach((file, index) => {
							const fileData = {
								name: file.FileName,
								size: file.FileSize || 0, // 파일 크기 정보 추가
								id: file.id,
								file_index: file.FileIndex,
								src: '/uploads/plant_i/' + this.tableName + '/' + file.PhysicFileName
							};							
							
							const files = window[this.uid + '_fileDocsData'];
							files.push(fileData); 
							window[this.uid + '_fileDocsData'] = files;
							window[this.uid + '_renderTable'](index, this.uid);
						});

						window[this.uid + '_updateFileInfo'](this.uid);
						if (typeof callback === 'function') callback();
					} else {
					}
				});
			}

			async saveFiles() {

				const preview = document.getElementById(this.uid + '_previewDocContainer');
				const filesState = window[this.uid + '_fileDocsData'];
				const previewFiles = Array.from(preview.querySelectorAll('.file-doc-item'))
					.map(item => filesState[parseInt(item.dataset.index)])
					.filter(file => file && file.rawFile);

				const formData = new FormData();
				previewFiles.forEach(f => formData.append('uploadfile', f.rawFile));
				formData.append('action', 'save_file');
				formData.append('tableName', this.tableName);
				formData.append('attachName', this.attachName);
				formData.append('dataPk', this.dataPk);
				formData.append('others', this.tableName);
				formData.append('allowedDuple', 'Y');

				try {
					const csrfToken = getCookie('csrftoken');
					const response = await fetch('/api/files/upload', {
						method: 'POST',
						body: formData,
						credentials: 'include',
						headers: {'X-CSRFToken': csrfToken}
					});
					const result = await response.json();

					const failedFiles = result.filter(f => !f.success);
					if (failedFiles.length > 0) {
						const msg = failedFiles.map(f => `${f.fileNm}: ${f.message || '저장 실패'}`).join('\n');
						Alert.alert('일부 파일 저장 실패', msg);
						return false;
					} else {
						// 초기화
						window[this.uid + '_fileDocsData'] = [];
						preview.innerHTML = '';
						window[this.uid + '_updateFileInfo'](this.uid);
						await this.loadFilesFromServer();
						return true;
					}
				} catch (e) {
					console.error('파일 저장 중 오류:', e);
					Alert.alert('오류', '파일 저장 중 오류가 발생했습니다.');
					return false;
				}
			}

			// 현재 파일 데이터 반환
			getFilesData() {
				return window[this.uid + '_fileDocsData'];
			}

			// 파일 데이터 초기화
			clearFiles() {
				window[this.uid + '_fileDocsData'] = [];
				document.getElementById(this.uid + '_previewDocContainer').innerHTML = '';
				document.getElementById(this.uid + '_fileDocTableBody').innerHTML = '';
				this.dataPk = '';
				window[this.uid + '_updateFileInfo'](this.uid);
			}
		};
	}
	
	// ★ 변경: 각 인스턴스별로 파일 업로더 생성 및 저장 (생성자 매개변수 전달)
	const fileUploaderInstance = new window.FileUploader(__UID__, '{{ tableName }}', '{{ attachName }}', '{{ dataPk }}');
	window[__UID__ + '_fileUploader'] = fileUploaderInstance;
	

	// ★ 변경: 헬퍼 함수들도 uid를 받아 동작(예시)
	// 각 인스턴스별로 독립적인 함수명 사용하여 충돌 방지
	window[__UID__ + '_handleFiles'] = function(fileList, getFiles, setFiles, uid) {
		// 이벤트 전파 방지 - event 객체가 정의되지 않을 수 있으므로 제거
		
		const files = Array.from(fileList);
		const currentState = getFiles();
		
		// 파일 처리 중 중복 호출 방지
		if (window[uid + '_processingFiles']) return;
		window[uid + '_processingFiles'] = true;
		
		try {
			files.forEach((f) => {
				// 용량/타입 체크는 기존 로직 그대로…
				if (!window.DOC_ALLOWED_TYPES.includes(f.type)) {
					alert(`허용되지 않는 파일 형식입니다: ${f.name}`);
					return;
				}
				if (f.size > window.DOC_MAX_SIZE) {
					alert(`파일 크기 초과 (10MB): ${f.name}`);
					return;
				}

				const reader = new FileReader();
				reader.onload = e => {
					// 새로운 파일 데이터 생성
					const newFileData = {
						name: f.name,
						size: f.size,
						src: e.target.result,
						type: f.type,
						rawFile: f
					};
					
					// 현재 상태를 복사하여 새 배열 생성
					const newState = [...currentState, newFileData];
					const index = newState.length - 1;
					
					// 상태 업데이트
					setFiles(newState);
					
					// UI 업데이트
					window[uid + '_renderPreview'](index, uid);
					window[uid + '_updateFileInfo'](uid);
				};
				reader.readAsDataURL(f);
			});
		} finally {
			// 파일 처리 완료 후 플래그 해제
			window[uid + '_processingFiles'] = false;
		}
	};

	window[__UID__ + '_renderPreview'] = function(index, uid) {
		const file = window[uid + '_fileDocsData'][index];
		const div = document.createElement("div");
		div.className = 'file-item file-doc-item';
		
		let previewContent = '';
		if (file.type.startsWith("image/")) {
			previewContent = `<img src="${file.src}" alt="img" style="width: 48px; height: 48px;">`;
		} else {
			previewContent = `<img src="/static/img/file-icon.png" style="width: 48px; height: 48px;">`;
		}

		div.innerHTML = `
			<div class="file-icon">
				${previewContent}
			</div>
			<div class="file-info">
				<span class="file-name">${file.name}</span>
				<span class="file-size">${(file.size / 1024).toFixed(1)} KB</span>
			</div>
			<button type="button" class="delete-button" onclick="window['${uid}_deleteFile'](${index}, '${uid}')">×</button>
		`;
		div.dataset.index = index;
		document.getElementById(uid + '_previewDocContainer').appendChild(div);
	};

	window[__UID__ + '_renderTable'] = function(index, uid) {
		const tableBody = document.getElementById(uid + '_fileDocTableBody');
		const file = window[uid + '_fileDocsData'][index];
		if (!file) return;

		const tr = document.createElement("tr");
		tr.dataset.index = index;
		
		// 읽기 모드일 때 삭제 버튼 숨김
		const fileUploader = window[uid + '_fileUploader'];
		const deleteButton = (!fileUploader || fileUploader.readOnly) ? '' : 
			`<td><button type="button" class="delete-button" onclick="window['${uid}_deleteFile'](${index}, '${uid}')">×</button></td>`;
		
		// 파일 크기 포맷팅
		const fileSize = file.size ? `${(file.size / 1024).toFixed(1)} KB` : 'N/A';
		
		// 파일 ID가 없는 경우 처리
		const fileId = file.id || file.file_index || index;
		const downloadLink = fileId ? 
			`<a href="javascript:void(0)" onclick="window['${uid}_downloadFile']('${fileId}')">${file.name}</a>` :
			`<span style="color: #999;">${file.name} (다운로드 불가)</span>`;
		
		tr.innerHTML = `
			<td></td>
			<td>${downloadLink}</td>
			<td>${fileSize}</td>
			${deleteButton}
		`;
		tableBody.appendChild(tr);
		
	};

	window[__UID__ + '_deleteFile'] = function(index, uid) {
		// 읽기 모드일 때는 삭제하지 않음
		const fileUploader = window[uid + '_fileUploader'];
		if (!fileUploader || fileUploader.readOnly) {
			return;
		}

		const file = window[uid + '_fileDocsData'][index];
		if (!file) return;

		// 서버에 삭제 요청
		const url = '/api/files/upload?action=remove_file';
		const data = {
			tableName: fileUploader.tableName,
			attachName: fileUploader.attachName,
			fileName: file.name,
			others: 'equipment',
			dataPk: fileUploader.dataPk,
			fileIndex: file.file_index
		};

		AjaxUtil.postAsyncData(url, data, (res) => {
			if (res.success) {
				window[uid + '_fileDocsData'][index] = null;
				document.querySelectorAll(`[data-index="${index}"]`).forEach(el => el.remove());
				window[uid + '_updateFileInfo'](uid);
			}
		});
	};

	window[__UID__ + '_updateFileInfo'] = function(uid) {
		const files = window[uid + '_fileDocsData'] || [];
		const cntEl = document.getElementById(uid + '_docTotalCount');
		const sizeEl = document.getElementById(uid + '_docTotalSize');
		const total = files.reduce((a,b)=>a + (b.size||0), 0);
		if (cntEl) cntEl.textContent = String(files.length);
		if (sizeEl) sizeEl.textContent = `total size : ${Math.round(total/1024)} KB`;
	};

	// 파일 다운로드 함수 추가
	window[__UID__ + '_downloadFile'] = function(fileId) {
		
		// fileId가 없는 경우 처리
		if (!fileId || fileId === 'undefined' || fileId === 'null') {
			console.error(`[${__UID__}] 파일 ID가 유효하지 않습니다: ${fileId}`);
			alert('파일 다운로드를 위한 ID 정보가 없습니다.');
			return;
		}
		
		try {
			const downloadUrl = `/api/files/download?file_id=${fileId}`;
			
			// 새 창에서 다운로드 시도
			const downloadWindow = window.open(downloadUrl, '_blank');
			if (!downloadWindow) {
				// 팝업이 차단된 경우 직접 다운로드
				window.location.href = downloadUrl;
			}
		} catch (error) {
			console.error(`[${__UID__}] 파일 다운로드 중 오류:`, error);
			alert('파일 다운로드 중 오류가 발생했습니다.');
		}
	};

	// CSRF 토큰을 쿠키에서 추출하는 함수
	function getCookie(name) {
	    let cookieValue = null;
	    if (document.cookie && document.cookie !== '') {
	        const cookies = document.cookie.split(';');
	        for (let i = 0; i < cookies.length; i++) {
	            const cookie = cookies[i].trim();
	            if (cookie.substring(0, name.length + 1) === (name + '=')) {
	                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
	                break;
	            }
	        }
	    }
	    return cookieValue;
	}
	
	// ★ 추가: 파일 업로더 디버깅을 위한 전역 함수
	window[__UID__ + '_debugFileUploader'] = function() {
	};
	
	console.log(`[${__UID__}] FileUpload 컴포넌트 로드 완료. 디버깅: ${__UID__}_debugFileUploader()`);
	})(); // ★ 변경: IIFE 닫기
</script>

{# ★ 변경: with 블록 닫기 #}
{% endwith %}
