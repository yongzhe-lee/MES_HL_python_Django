{"version":3,"sources":["raw-js/kendo.dataviz.chart.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendodataviz","chart","js","this","$","window","kendo","dataviz","Class","isNumber","datavizConstants","constants","MAX_VALUE","MIN_VALUE","VALUE","DATE","CENTER","TOP","BOTTOM","LEFT","WHITE","CIRCLE","X","Y","RIGHT","BLACK","COORD_PRECISION","END","START","DEFAULT_PRECISION","ARC","defined","getter","isArray","ChartElement","Point","Box","alignPathToPixel","setDefaultOptions","isString","inArray","isFunction","valueOrDefault","isObject","parseDate","deepExtend","last","eventElement","TextBox","getTemplate","ShapeElement","getSpacing","CurveProcessor","append","styleValue","CategoryAxis","BoxElement","Title","round","limitValue","cycleIndex","grep","elementStyles","autoTextColor","rad","bindEvents","services","unbindEvents","support","drawing","Path","Animation","AnimationFactory","Group","Circle","MultiPath","Color","geometry","GeometryPoint","GeometryCircle","transform","ChartAxis","extend","init","axis","_axis","options","value","point","getCategory","getValue","slot","from","to","limit","range","valueRange","findAxisByName","name","axes","idx","length","prepareUserOptions","ChartPane","pane","visual","chartsVisual","chartContainer","_pane","ChartPlotArea","plotArea","_plotArea","backgroundVisual","_bgVisual","countNumbers","values","count","i","num","Aggregates","min","Math","max","sum","sumOrNull","result","avg","first","getField","field","row","get","SeriesBinder","_valueFields","_otherFields","_nullValue","_undefinedValue","register","seriesTypes","valueFields","otherFields","this$1$1","type","_makeValue","undefined","canonicalFields","series","concat","bindPoint","pointIx","item","fields","data","pointData","Array","fieldData","slice","_bindFromArray","srcValueFields","sourceFields","srcPointFields","_bindFromObject","initialValue","array","object","srcFields","fieldName","srcFieldName","sourceFieldName","push","current","percentRegex","standardDeviationRegex","RegExp","ErrorRangeCalculator","errorValue","initGlobalRanges","deviationMatch","exec","valueGetter","createValueGetter","average","getAverage","deviation","getStandardDeviation","multiple","parseFloat","errorRange","low","high","globalRange","indexOf","standardError","getStandardError","binder","index","OBJECT","getErrorRange","pointValue","Error","percentValue","abs","sqrt","isSample","total","squareDifferenceSum","pow","browser","INITIAL_ANIMATION_DURATION","FADEIN","BORDER_BRIGHTNESS","START_SCALE","msie","ERROR_LOW_FIELD","ERROR_HIGH_FIELD","X_ERROR_LOW_FIELD","X_ERROR_HIGH_FIELD","Y_ERROR_LOW_FIELD","Y_ERROR_HIGH_FIELD","ZERO","INTERPOLATE","GAP","ABOVE","BELOW","SMOOTH","STEP","AREA","BAR","BOX_PLOT","BUBBLE","BULLET","CANDLESTICK","COLUMN","DONUT","FUNNEL","PYRAMID","HEATMAP","HORIZONTAL_WATERFALL","LINE","OHLC","PIE","POLAR_AREA","POLAR_LINE","POLAR_SCATTER","RADAR_AREA","RADAR_COLUMN","RADAR_LINE","RANGE_AREA","RANGE_BAR","RANGE_COLUMN","SCATTER","SCATTER_LINE","VERTICAL_AREA","VERTICAL_BOX_PLOT","VERTICAL_BULLET","VERTICAL_LINE","VERTICAL_RANGE_AREA","WATERFALL","EQUALLY_SPACED_SERIES","TRENDLINE_EXPONENTIAL","TRENDLINE_LINEAR","TRENDLINE_LOGARITHMIC","TRENDLINE_MOVING_AVERAGE","TRENDLINE_POLYNOMIAL","TRENDLINE_POWER","TRENDLINE_SERIES","LEGEND_ITEM_CLICK","LEGEND_ITEM_HOVER","LEGEND_ITEM_LEAVE","SERIES_CLICK","SERIES_HOVER","SERIES_OVER","SERIES_LEAVE","PLOT_AREA_CLICK","PLOT_AREA_HOVER","PLOT_AREA_LEAVE","DRAG","DRAG_END","DRAG_START","ZOOM_START","ZOOM","ZOOM_END","SELECT_START","SELECT","SELECT_END","RENDER","SHOW_TOOLTIP","HIDE_TOOLTIP","PANE_RENDER","CHART_POINT_ROLE","CHART_POINT_CLASSNAME","CHART_POINT_ROLE_DESCRIPTION","LEGEND_ITEM_ROLE","LEGEND_ITEM_CLASSNAME","LEGEND_ITEM_ARIA_ROLE_DESCRIPTION","LOGARITHMIC","CATEGORY","INSIDE_END","INSIDE_BASE","OUTSIDE_END","MOUSEWHEEL","MOUSEWHEEL_DELAY","DRILLDOWN","DRILLDOWN_FIELD","MIN_MOVING_AVERAGE_PERIOD","GLASS","TOOLTIP_OFFSET","LINE_MARKER_SIZE","MOUSEWHEEL_ZOOM_RATE","ErrorBarBase","isVertical","fn","call","reflow","targetBox","linePoints","endCaps","valueBox","getAxis","getSlot","centerBox","center","capsWidth","getCapsWidth","capValue","x","y","capStart","capEnd","y1","y2","box","x1","x2","boxSize","width","height","floor","createVisual","rect","toRect","sender","getSender","color","line","createDefaultVisual","defaultVisual","lineOptions","stroke","dashType","moveTo","lineTo","animation","delay","zIndex","CategoricalErrorBar","seriesValueAxis","anyHasZIndex","elements","appendIfNotNull","element","areNumbers","segmentVisible","visible","pointVisibility","bindSegments","points","categoriesCount","seriesCount","categories","equalsIgnoreCase","a","b","toLowerCase","evalOptions","context","state","dryRun","defaults","depth","needsEval","excluded","property","hasOwnProperty","propValue","filterSeriesByType","types","currentSeries","dateCache","WeakMap","parseDateCategory","category","intlService","date","set","hasGradientOverlay","overlay","gradient","hasValue","isDateAxis","axisOptions","sampleCategory","dateCategory","Date","singleItemOrArray","AREA_REGEX","hasValue$1","convertableToNumber","findNext","ref","pointHasValue","outPoint","start","dir","getter$$1","hasItem","createOutOfRangePoints","hasMinPoint","hasMaxPoint","minPoint","maxPoint","missingValues","test","stack","seriesMissingValues","_outOfRangeMinPoint","_outOfRangeMaxPoint","CategoricalChart","chartService","categoryAxis","seriesCategoryAxis","valueAxisRanges","categoryPoints","seriesPoints","seriesOptions","_evalSeries","render","traverseDataPoints","addValue","bind","pointOptions","seriesIx","pointType","prototype","vertical","invertAxes","plotValue","isStacked100","categoryIx","otherValues","categorySum","other","otherStack","group","plotRange","startValue","isStacked","positive","prevValue","isStackedBar","defaultStack","isNonGroupStack","STRING","otherValue","valueAxis","axisCrossingValue","categoryAxisCrossingValue","stackLimits","axisName","stackName","pIx","isFinite","updateStackRange","chartSeries","limitsCache","key","limits","errorTotals","negative","sparseArrayLimits","addErrorBar","errorBars","lowValue","highValue","seriesErrorRanges","addPointErrorBar","stackedErrorRange","updateRange","errorBar","createPoint","owner","noteText","dataItem","evalPointOptions","_defaults","doEval","axisRange","namedValueAxes","categorySlots","chartPoints","categorySlot","valueSlot","pointSlot","aboveAxis","stackValue","percentage","reflowPoint","reflowCategories","clip","limitPoints","limitPoint","limitedSlot","limitSlot","equals","reverse","axisCrossingValues","axisIndex","slotX","slotY","callback","_outOfRangeCallback","seriesIx$1","currentCategory","categoryAt","seriesIx$2","outOfRangePoint","formatPointValue","format","auto","PointEventsMixin","click","e","trigger","eventArgs","hover","over","out","runningTotal","originalEvent","NoteMixin","createNote","notes","text","label","note","Note","guid","random","id","toString","LinePoint","tooltipTracking","_id","markers","_rendered","size","marker","createMarker","createLabel","labels","createLabelElement","getLabelText","align","vAlign","margin","left","right","labelTemplate","formatValue","getAriaLabelText","ariaTemplate","getAriaTemplate","markerBorder","background","border","brightness","toHex","rotation","opacity","accessibilityOptions","ariaLabel","accessibility","markerBox","_childBox","childBox","clone","reflowLabel","noteTargetBox","anchor","position","alignTo","createHighlight","highlight","defaultColor","shadow","getElement","highlightVisual","highlightVisualArgs","paddingBox","halfSize","Rect","createFocusHighlight","markerOptions","highlightOptions","padding","tooltipAnchor","clipBox","overlaps","verticalAlign","horizontalAlign","horizontal","overlapsBox","unclipElements","noclip","focusVisual","toggleFocusHighlight","clearFocusFromVisual","getIndex","HIGHLIGHT_ZINDEX","tabIndex","role","className","ariaRoleDescription","LineSegment","toGeometryPoints","customVisual","segmentVisual","fromPoints","closed","close","aliasFor","coords","parent","getNearestPoint","StepLineMixin","calculateStepPoints","justified","stepAxis","stepDir","previousPoint","toGeometryPoint","stepPoint","lintPoint","StepLineSegment","SplineSegment","segments","process","curve","apply","LineChartMixin","renderSegments","lastSegment","_segments","sortedPoints","sortPoints","pointCount","createSegment","_addSegment","children","unshift","segment","nearestPoint","target","allPoints","nearestPointDistance","pointDistance","distanceTo","ClipAnimation","setup","_setEnd","step","pos","interpolateValue","topRight","bottomRight","suspend","setX","resume","duration","ClipAnimationMixin","createAnimation","root","getRoot","transitions","clipPath","fromRect","_setChildrenAnimation","animationPoints","LineChart","style","supportsPointInactiveOpacity","AreaSegment","prevSegment","stackPoints","createFill","fill","createStroke","lineCap","strokeSegments","_strokeSegments","createStrokeSegments","segmentsFromPoints","stackSegments","createStackSegments","map","Segment","hasStackSegment","fillSegments","hasStackSegments","fillToAxes","fillPath","crossingValue","endSlot","firstPoint","lastPoint","end","StepAreaSegment","SplineAreaSegment","curveProcessor","controlOut","controlIn","AreaChart","previousSegment","_gapStackPoints","_stackPoints","stackPoint","startIdx","endIdx","pointOffset","currentSeriesIx","_previousSegmentPoint","gapStackPoint","_createGapStackPoint","segmentIx","seriesIdx","AxisGroupRangeTracker","axisRanges","update","chartAxisRanges","chartRange","reset","query","BarLabel","content","textBox","textOptions","labelBox","contentBox","top","bottom","alignToClipBox","parentBox","addAccessibilityAttributesToVisual","ariaChecked","AccessibilityAttributesMixin","Bar","rectVisual","createRect","strokeOpacity","path","getBorderColor","lineJoin","createGradientOverlay","baseColor","borderWidth","pad","_brightness","borderColor","forEach","forEachReverse","ClusterLayout","rtl","gap","spacing","slots","slotSize","child","StackWrap","positionAxis","childrenCount","currentChild","snapTo","wrap","BarChart","clusterType","stackType","stackOrDefault","labelOptions","negativeColor","cluster","getStackWrap","stackWrap","stackGroup","wraps","_stackGroup","zeroSlot","stackAxis","childrenLength","_setAnimationOptions","pointVisual","origin","Candlestick","ocSlot","open","lhSlot","realBody","mid","lines","reflowNote","_mainVisual","mainVisual","createOverlay","createBody","createLines","container","body","drawLines","lineStyle","normalColor","meanPoints","medianPoints","whiskerPoints","tooltip","CandlestickChart","splitValue","downColor","parts","BoxPlot","whiskerSlot","boxSlot","q1","q3","reflowBoxSlot","lower","upper","reflowWhiskerSlot","medianSlot","median","mean","meanSlot","calcMeanPoints","calcWhiskerPoints","calcMedianPoints","renderOutliers","outliers","outerFence","outlierValue","extremes","markersBorder","shape","reflowOutliers","move","whiskers","CROSS","VerticalBoxPlot","BoxPlotChart","filterOutliers","items","ScatterErrorBar","seriesAxes","ScatterChart","_initFields","xAxisRanges","yAxisRanges","valueErrorField","lowField","highField","createMissingValue","intl","xAxisName","xAxis","yAxisName","yAxis","xAxisRange","yAxisRange","namedXAxes","axisX","namedYAxes","axisY","ref$1","Bubble","radius","highlightGroup","createGradient","stops","offset","BubbleChart","_maxSize","negativeValues","updateBubblesSize","pointsCount","animationOptions","minR","minSize","maxR","maxSize","minArea","PI","areaRatio","area","Target","Bullet","targetValueSlot","targetSlotX","targetSlotY","targetSlot","bodyVisual","create","BulletChart","seriesItem","wrapData","bulletOptions","bullet","isNaN","BaseTooltip","getStyle","pointColor","backgroundColor","font","paddingTop","paddingBottom","paddingLeft","paddingRight","show","tooltipOptions","isDark","notify","hide","destroy","CrosshairTooltip","crosshair","formatService","initAxisName","showAt","stickyMode","formattedValue","dateFormats","baseUnit","getAnchor","ref_options","lineBox","bbox","bottomLeft","translate","topLeft","Crosshair","moveLine","lineEnd","getBox","dim","lineStart","pointCategoryIndex","axisLineBox","currentAxis","ChartContainer","shouldClip","_clipBox","chartsBox","clipRect","unclipLabels","stackRoot","charts","j","isStackRoot","Pane","ID","createTitle","titleOptions","title","buildTitle","appendAxis","appendAxisAt","splice","appendChart","empty","removeAxis","i$1","removeChart","pop","visualStyle","renderComplete","createGridLines","clipRoot","allAxes","vGridLines","hGridLines","gridLines","altAxis","refresh","clear","renderVisual","notifyRender","axisValueField","length$1","idx$1","axis$1","lineBox$1","service","getService","paneIndex","shrinkToFit","PlotAreaBase","initFields","initSeries","legend","crosshairs","originalOptions","originalSeries","_bindCache","createPanes","createCrosshairs","cached","paneDefaults","paneOptions","panes","panesLength","currentPane","crosshairOptions","currentCrosshair","removeCrosshairs","hideCrosshairs","findPane","matchingPane","findPointPane","containsPoint","axisToRemove","filteredAxes","chartToRemove","filteredCharts","addToLegend","inactiveItems","inactiveItemsLabels","seriesVisible","visibleInLegend","itemLabelOptions","markerColor","active","groupAxes","xAxes","yAxes","paneIx","paneAxes","axisIx","any","groupSeriesByPane","seriesByPane","seriesPaneName","filterVisibleSeries","unpad","reflowPanes","detachLabels","reflowAxes","reflowCharts","redraw","panesArray","cleanGradients","crossingAxes","crossingValues","valuesToAdd","defaultValue","alignAxisTo","targetAxis","targetCrossingValue","slotEdge","targetEdge","axisBox","alignAxes","xAnchor","yAnchor","xAnchorCrossings","yAnchorCrossings","leftAnchors","rightAnchors","topAnchors","bottomAnchors","paneId","paneAnchor","anchorCrossings","_overlap","_mirrored","mirror","paneYAnchor","pane$1","paneId$1","visible$1","anchor$1","anchorCrossings$1","shrinkAxisWidth","axisGroupBox","overflowX","shrink","shrinkAxisHeight","shrinked","overflowY","fitAxes","offsetX","paneBox","offsetY","currentAxis$1","reflowPaneAxes","autoRotateAxisLabels","groupedAxes","rotated","allPaneAxes","autoRotateLabels","chartPane","remainingHeight","autoHeightPanes","percents","parseInt","currentPane$1","i$2","currentPane$2","backgroundBox","axesCount","axisA","axisB","chartsBoxes","boxes","addBackgroundPaths","multipath","paths","backgroundContainsPoint","bg","appendVisual","pointsByCategoryIndex","categoryIndex","pointsBySeriesIndex","seriesIndex","filterPoints","pointsByPointIndex","pointIndex","pointsBySeriesName","findPoint","paneByPoint","detachAxisGroupLabels","labelAxisCount","labelAxis","createLabelAxis","onAxis","edge","plotBands","isTrendline","trendlineFactory","createTrendlineSeries","modifiedSeries","forSeries","seriesByName","for","trendlineSeries","INHERIT","filter","find","getFirstPoint","getPointBelow","_getNextPoint","_pointsByVertical","getPointAbove","getPointToTheRight","_pointsByHorizontal","getPointToTheLeft","getPointsFunc","increment","nextIndex","loopPoints","direction","at","basePoint","isSingleAxis","some","reduce","acc","PlotAreaEventsMixin","_dispatchEvent","SeriesAggregator","defaultAggregates","seriesFields","_seriesFields","rootAggregate","aggregate","_series","_binder","fieldAggregate","canonicalName","aggregatePoints","srcPoints","_bindPoints","firstDataItem","dataItems","srcValues","_bindField","setValue","parentObj","split","shift","DefaultAggregates","aggregates","seriesType","RangeBar","fromOptions","toOptions","labelFrom","labelTo","RangeBarChart","plotLimits","RangeLinePoint","AUTO","RangeAreaPoint","initLabelsFormat","fromPoint","toPoint","copyFields","fromBox","toBox","positionLabels","fromLabelPosition","toLabelPosition","RangeAreaSegment","toPoints","fromSegments","toPath","fromPath","SplineRangeAreaSegment","createCurveSegments","StepRangeAreaSegment","RangeAreaChart","fromSlot","toSlot","OHLCPoint","oPoints","cPoints","lhPoints","oSlot","cSlot","OHLCChart","WaterfallSegment","WaterfallChart","createSegments","totalCategories","summary","prevPoint","registry","impl","String","calculateSlope","sourceValues","slope","intercept","xy","xMin","Number","xMax","xValue","yValue","checkAllPositive","every","getTrendlineData","valueMapper","totalRange","totalRangeIndices","currentRange","currentRangeIndices","ceil","log","valueGetter$1","valueGetter$2","calculateMovingAverage","period","averagePoints","lastValue","valueGetter$3","MIN_ORDER","MAX_ORDER","calculatePolynomial","order","k","X$$1","Matrix","Y$$1","coefficients","Xt","transpose","B","multiply","inverse","linearRegression","n","valueGetter$4","valueGetter$5","seriesValues","exp","getData","categoryField","getData$1","getData$2","trendline","calculatePoints","getData$3","getData$4","getData$5","AREA_SERIES","OUT_OF_RANGE_SERIES","CategoricalPlotArea","namedCategoryAxes","valueAxisRangeTracker","_seriesPointsCache","_currentPointsCache","stack100","createCategoryAxes","aggregateCategories","createCategoryAxesLabels","createCharts","createValueAxes","filterSeries","trendlineAggregateForecast","forecast","before","after","srcSeries","aggregateSeries","paneSeries","visibleSeries","groups","groupSeriesByCategoryAxis","groupIx","createChartGroup","createAreaChart","createRangeAreaChart","createBarChart","createRangeBarChart","createBulletChart","createCandlestickChart","createBoxPlotChart","createOHLCChart","createWaterfallChart","createLineChart","processedSeries","axisPane","dataLength","_seriesMax","outOfRangePoints","clearSeriesPointsCache","seriesSourcePoints","categoriesHash","srcCategories","dateAxis","srcData","indexCategories","totalIndex","aggregator","categoryItem","categoryIdx","totalCount","categoriesToAdd","defaultPaneName","stackableChartOptions","anyStackedSeries","s","categoryAxes","unique","axisSeries","groupSeries","firstSeries","barChart","rangeColumnChart","bulletChart","lineChart","areaChart","rangeAreaChart","waterfallChart","axisRequiresRounding","categoryAxisName","categoryAxisIndex","centeredSeries","seriesAxis","aggregatedAxis","createLabels","definitions","isJustified","_forecast","DateCategoryAxis","primaryAxis","tracker","defaultRange","baseOptions","roundToMajorUnit","defaultAxisRange","LogarithmicAxis","NumericAxis","eventType","_eventCoordinates","pointPane","updateAxisOptions","_siblingsBySeriesIndex","_siblingsByPointIndex","siblings","sort","_getSeriesCompareFn","_isInStackedSeries","sortableSeries","stackableSeries","targetOptions","axesOptions","Highlight","_points","arrayPoints","toggleHighlight","hasHighlight","togglePointHighlight","toggleHandler","toggle","preventDefault","_defaultPrevented","isHighlighted","acceptKey","mouseKey","event","ctrlKey","shiftKey","altKey","toChartAxisRanges","ranges","Pannable","_active","_panAxes","pan","delta","lock","updatedAxes","limitRange","ZoomSelection","createElement","marquee","_marquee","document","marqueeColor","appendChild","removeElement","parentNode","removeChild","setStyles","styles","zoomPane","_zoomPane","_elementOffset","_zoomPaneClipBox","pageX","pageY","chartElement","elementOffset","_selectionPosition","elementOffset$$1","selectionPosition","_updateAxisRanges","zoom","pointsRange","startLocation","location","util","limitValue$1","valueOrDefault$1","MousewheelZoom","rate","updateRanges","zoomRange","LegendLayout","Layout","lineSpacing","orientation","VERTICAL","HORIZONTAL","alignItems","legendItem","clippedBBox","rectToBox","addVisual","DEFAULT_MARKER_SIZE","LegendItemMarker","cursor","markerHighlightOptions","ChartElement$1","initUserOptions","translateChildren","dx","dy","arguments$1","arguments","renderChildren","childVisual","stackVisual","visuals","sibling","insert","traverse","closest","match","matched","_highlight","focusHighlight","_focusHighlight","rootBackground","highlightColor","focusHighlightOptions","gradientOptions","Point$1","rotate","degrees","theta","cosT","cos","sinT","sin","cx","cy","onCircle","angle","radians","Box$1","wrapPoint","arrayPoint","targetCenter","dw","dh","expand","getHash","join","r1","rotatePoint","r2","r3","r4","hasSize","alignment","c1","c2","sizeFunc","WIDTH","HEIGHT","BoxElement$1","hasSetSize","reflowPaddingBox","hasBox","ShapeElement$1","halfWidth","halfHeight","TRIANGLE","ROUNDED_RECT","borderRadius","setCornerRadius","visualOptions","MarkerLineArea","LegendItemLine","centerY","createHighlightLine","createHighlightMarker","highlightLine","highlightMarker","RECT","LegendItemSquare","LegendItem","createContainer","FloatElement","markerWrap","createMarkerArea","_marker","_createMarker","_createLine","_createMarkerLine","_createSquare","_highlightOptions","_line","_markerLineArea","_square","_highlightMarkers","_toggleHighlight","_restoreMarkers","h","eventSink","_itemOverlay","widget","args","_legendItemHover","_unsetActivePoint","CUSTOM","Legend","createContainers","createLegendTitle","createItems","userAlign","hasTitle","itemsContainer","innerElement","markersOptions","itemOptions","hasItems","getItems","legendBox","containerCustomReflow","containerReflow","alignTarget","containerBox","createTitleLayout","appendTitleLayoutContent","layout","Boolean","POINTER","SQUARE","PlotAreaFactory","_registry","entry","trendlines","createDiv","classNames","closestHandle","hasClasses","Selection","observer","_dateAxis","initOptions","offsetHeight","createElements","_index","onPane","wrapper","selection","leftMask","rightMask","leftHandle","rightHandle","selectionStyles","leftHandleHeight","rightHandleHeight","borderLeftWidth","borderRightWidth","cssText","obj","mousewheel","_mousewheelHandler","_mousewheel","_domEvents","DomEventsBuilder","stopPropagation","_start","_move","_end","tap","_tap","press","_press","gesturestart","_gesturestart","gesturechange","_gesturechange","gestureend","_gestureend","clearTimeout","_mwTimeout","_state","_rangeEventArgs","_value","_pointInPane","modelCoords","_toModelCoordinates","eventCoordinates","handle","bodyRect","getBoundingClientRect","inBody","moveTarget","addClass","oldRange","span","scale","removeClass","rightClick","which","mousewheelDelta","setTimeout","touch","touches","p0","p1","_slot","leftMaskWidth","rightMaskWidth","distance","fromValue","toValue","zDir","relative","minDelta","maxDelta","Tooltip","_current","SharedTooltip","tooltipPoints","_slotAnchor","_defaultAnchor","shared","categoryText","categoryFormat","slotCenter","BarChartAnimation","fromScale","abort","scaleX","scaleY","BubbleAnimation","easing","FadeInAnimation","fadeTo","PieAnimation","ScatterLineChart","missingValue","getScatterTrendlineData","samplingInterval","diff","relativeValue","autoMajorUnit","valueGetter$6","scatterValueGetter","xValueLimits","valueGetter$7","logValueGetter","valueGetter$8","scatterRegistry","getData$6","getData$7","getData$8","getData$9","getData$10","getData$11","XYPlotArea","xAxisRangeTracker","yAxisRangeTracker","filteredSeries","createScatterChart","createScatterLineChart","createBubbleChart","createAxes","xAxisOptions","yAxisOptions","createXYAxis","inferredDate","namedAxes","isLog","typeSamples","seriesAxisName","firstPointValue","DateValueAxis","xAxesOptions","yAxesOptions","axisPane$1","xValues","yValues","currentValue","updateAxisOptions$1","PieSegment","sector","labelText","themeLabels","theme","seriesDefaults","animationDelay","labelsOptions","labelsDistance","middle","lp","labelHeight","labelWidth","startAngle","innerRadius","endAngle","createSegmentVisual","borderOptions","fallbackFill","userSpace","singleSegment","ShapeBuilder","createRing","midAndle","tooltipAlignment","RAD_30","RAD_60","sine","cosine","DEFAULT_FONT","PieChartMixin","createLegendItem","legendOptions","pointVisible","legendItems","PieChart","seriesColors","colorsCount","anglePerValue","constantAngle","currentAngle","explode","Ring","evalSegmentOptions","segmentOptions","seriesConfigs","minWidth","halfMinWidth","defaultPadding","newBox","newBoxCenter","boxCenter","leftSideLabels","rightSideLabels","seriesConfig","setRadius","labelComparator","leftLabelsReflow","rightLabelsReflow","distances","distanceBetweenLabels","distributeLabels","lr","firstBox","secondBox","remaining","_takeDistance","reflowLabels","amount","available","boxX","labelsCount","labelDistance","boxY","hAlignLabel","connectors","_connectorLines","connectorsColor","connectorLine","centerPoint","sr","crossing","intersection","pointInCircle","space","autoFit","pieCenter","bboxBottom","reverseValue","originalX","sector_center","t","a1","a2","b1","b2","uat","ub","ua","PiePlotArea","createPieChart","pieChart","DonutSegment","DonutChart","holeSize","totalSize","seriesWithoutSize","currentSeries$1","DonutPlotArea","createDonutChart","donutChart","PolarPlotAreaBase","createPolarAxis","createValueAxis","polarAxis","axisType","axisDefaultRange","valueAxisOptions","RadarLogarithmicAxis","RadarNumericAxis","valueAxisBox","heightDiff","PolarScatterChart","valueRadius","PolarLineChart","SplinePolarAreaSegment","_polarAxisCenter","PolarAreaSegment","centerSegment","PolarAreaChart","_hasMissingValuesGap","xComparer","PolarPlotArea","PolarAxis","majorGridLines","minorGridLines","scatterChart","RadarLineChart","seriesSegments","groupBySeriesIx","isFirstDataPoint","isLastDataPoint","SplineRadarAreaSegment","RadarAreaSegment","RadarAreaChart","RadarSegment","RadarClusterLayout","slotAngle","slotSector","RadarStackLayout","childSector","RadarBarChart","RadarPlotArea","RadarCategoryAxis","_hasBarCharts","_isStacked100","chartOptions","FunnelSegment","chartBox","createPath","FunnelChart","labelPadding","dynamicSlopeReflow","totalHeight","firstSegment","maxSegment","lastUpperSide","previousOffset","previousHeight","nextSegment","nextPercentage","segmentSpacing","constantSlopeReflow","decreasingWidth","neckRatio","finalNarrow","dynamicSlope","dynamicHeight","PyramidChart","FunnelPlotArea","createChart","chartType","HeatmapPoint","labelColor","isRoundRect","halfBorderWidth","HeatmapChart","setRange","minLightnessOffset","parseColor","hsl","toHSL","l","toCss","colorScale","indexX","indexY","xRange","yRange","ref$2","xIndex","yIndex","xIn","yIn","HeatmapPlotArea","bindCategories","createAxisLabels","xCategories","createHashSet","yCategories","has","add","createHeatmapChart","firstCategory","updateAxisOptions$2","normalizedOffset","axisXItems","_getPointAxisXIndex","targetXValue","compareValues","_getPointAxisYIndex","axisYItems","targetYValue","_getPointAxisIndex","findIndex","axisItem","dateEquals","COLOR","FIRST","MAX","MIN","NOTE_TEXT","errorLow","errorHigh","AXIS_NAMES","MOUSEMOVE","CONTEXTMENU","MOUSELEAVE","KEYDOWN","FOCUS","BLUR","Chart","userOptions","themeOptions","observers","addObserver","ChartService","_initElement","_originalOptions","_theme","_initTheme","_focusState","_initHandlers","_initSurface","FontLoader","preloadFonts","fontLoaded","_destroyed","_redraw","_attachEvents","_setElementClass","getAttribute","setAttribute","firstChild","seriesCopies","aliases","alias","resolveAxisAliases","applyDefaults","applySeriesColors","getSize","chartArea","offsetWidth","resize","force","currentSize","_size","_resize","_selections","_destroySelections","_setupSelection","_noTransitionsRedraw","paneName","_model","findPaneByName","findPaneByIndex","seriesName","categoryName","pointByCategoryName","togglePointsHighlight","showTooltip","_sharedTooltip","_tooltip","hideTooltip","surface","_surfaceWrap","elementSize","renderAs","_destroySurface","Surface","_surfaceMouseenterHandler","_surfaceMouseleaveHandler","model","_getModel","_destroyView","_setElementAccessibilityAttributes","_legend","draw","play","_createTooltip","_createPannable","_createZoomSelection","_createMousewheelZoom","triggerPaneRender","_navState","_cancelDomEvents","_redrawFocusHighlight","ref_focusState","legendInFocus","preserveHighlight","_focusElement","_getFocusedLegendItem","description","exportVisual","exportOptions","currentOptions","clearMissingValues","pannable","_pannable","zoomable","_zoomSelection","_mousewheelZoom","_toggleDragZoomEvents","allowDrag","requiresHandlers","allowZoom","_dragZoomEnabled","touchAction","_touchAction","_toggleDomEvents","drag","domEvents","toggleDrag","toggleZoom","_createSharedTooltip","axisDefaults","themeAxisDefaults","mapAxisOptions","axisColor","applyAxisDefaults","seriesLength","commonDefaults","themeSeriesDefaults","commonThemeDefaults","cleanupNestedSeriesDefaults","applySeriesDefaults","colors","seriesColor","_createPlotArea","RootElement","_modelOptions","subtitle","orderTitles","DEFAULT_WIDTH","DEFAULT_HEIGHT","skipSeries","selections","select","_selectStart","_select","_selectEnd","_clickHandler","_click","_keydownHandler","_keydown","_focusHandler","_focus","_blurHandler","_blur","_mousedownHandler","_mousedown","_mouseleaveHandler","_mouseleave","_mouseover","_mouseout","_mousemove","throttle","removeObserver","eventNames","_toDocumentCoordinates","_updateDrilldownPoint","_resetDrilldownPoint","_focusPoint","_startDrilldown","_focusLegendItem","isDefaultPrevented","obj$1","_shouldAttachMouseMove","_hoveredPoint","_plotAreaHovered","_hasInactiveOpacity","_activeChartInstance","_applySeriesOpacity","_updateSeriesOpacity","cancel","_stopChartHandlers","_gestureDistance","_clearFocusedElement","suspendTracking","_zooming","resumeTracking","mousewheelZoom","previousGestureDistance","scaleDelta","_drawingChartElement","leave","_startNavigation","_suppressHover","panning","ranges$1","translateRange","_endNavigation","_mousewheelZoomRate","totalDelta","scaleRange","chartEvent","_getChartElement","eventTarget","coordinates","_elementPadding","_padding","clientX","clientY","inverseTransform","elementScale","invert","drawingElement","sharedTooltip","_startHover","_trackSharedTooltip","_propagateClick","handlingTap","_isLegendBeforeChart","legendPosition","_preventInitialPointFocus","_focusFirstLegendItem","_focusFirstPoint","focusedElement","TAB","isLegendBeforeChart","_navigatePoints","_navigateLegend","ESCAPE","_hideTooltip","ENTER","focusState","moveFocus","focusedPoint","_displayTooltip","ARROW_RIGHT","ARROW_LEFT","ARROW_DOWN","ARROW_UP","itemsLength","cycleFunc","focusedLegendItemIndex","cycleUp","cycleDown","_hasFocus","ownerDocument","activeElement","_focusChart","focus","omitHighlight","_setElementActiveDescendant","_showSeriesInactiveOpacity","_showInactiveOpacity","_clearElementActiveDescendant","_pseudoFocusedElement","_createPseudoFocusedElement","ARIA_ACTIVE_DESCENDANT","remove","removeAttribute","pseudoElement","checked","_hideInactiveOpacity","activePoint","_activePoint","_updateHoveredPoint","_displayInactiveOpacity","multipleSeries","highlightPoints","chartInstance","_chartInstanceFromPoint","inactivePoints","_getInactivePoints","_getInactiveOpacityForSeries","_getAllPointsOfType","constructor","hoveredPoint","drilldown","_drilldownState","resetOpacity","currSeries","defaultOpacity","_getDefaultOpacityForSeries","inactiveOpacity","activeSeries","hasDefaultInactiveOpacity","hasInactiveOpacity","defaultInactiveOpacity","DEFAULT_SERIES_OPACITY","_mouseMoveTrackHandler","_mouseMoveTracking","seriesPoint","_trackCrosshairs","overPlotArea","_tooltipCategoryIx","_sharedHighlight","pointArgs","hoverArgs","hideElements","keepTooltipOpen","_deferRedraw","_clearRedrawTimeout","_redrawTimeout","clearInterval","autoBind","bindCategoryAxisFromSeries","uniqueCategories","Set","seriesOnAxis","hasCategoryBinding","seriesWithData","categorySamples","getTime","time","_isBindable","transitionsState","updateMouseMoveHandler","applyOptions","setOptions","setDirection","setIntlService","noTransitionsRedraw","unbind","bar","column","rangeColumn","verticalLine","pie","donut","verticalArea","scatter","scatterLine","bubble","candlestick","ohlc","boxPlot","verticalBullet","polarArea","polarLine","radarArea","radarLine","waterfall","DATA_FIELDS","fieldValue","originalValue","nullValue","jQuery","undefined$1","Widget","ui","ChartBreadcrumb","_attachChartEvents","_renderBreadcrumb","events","rootItem","icon","showIcon","breadcrumb","_onChartDrilldown","_onChartDrilldownLevelChange","deferred","resetDrilldownLevel","getKendoChart","breadcrumbElement","Breadcrumb","_onBreadcrumbClick","level","plugin","NS","outerWidth","_outerWidth","outerHeight","_outerHeight","KendoChart","DataSource","InstanceObserver","template","encode","htmlEncode","MOUSELEAVE_NS","AXIS_LABEL_CLICK","DRILLDOWN_LEVEL_CHANGE","NOTE_CLICK","NOTE_HOVER","NOTE_LEAVE","DOCUMENT_ELEMENT","documentElement","CHANGE","DATABOUND","LEAVE","Observable","UserEvents","multiTouch","fastTap","ChartInstanceObserver","handlerMap","legendItemClick","dataSource","_seriesVisibility","SeriesVisibilityState","_initDataSource","_showWatermarkOverlay","instance","_instance","_bindSeries","_bindCategories","dimensions","_setEvents","_getThemeOptions","_sourceSeries","setDataSource","_hasDataSource","_onDataChanged","_dataChangeHandler","_hasData","fetch","off","_destroyCrosshairTooltips","findSeries","ChartSeries","findSeriesByName","_createSeries","findSeriesByIndex","originalChartArea","_seriesOptions","on","relatedTarget","autoHide","themeName","SASS_THEMES","autoTheme","themes","_initChart","_createChart","_isRtl","_onInit","_initTooltip","tooltips","_crosshairTooltips","_getCrosshairTooltip","_showTooltip","_onRender","_copyMembers","names","_events","_tooltipleave","_onLegendItemClick","_legendItemClick","save","_onDrilldown","drilldownSeriesFactory","Promise","then","resolved","_onDrilldownData","drilldownSeries","Object","assign","_bindData","groupedSeries","view","grouped","seriesVisibility","read","applyByGroup","applyByIndex","seriesData","_groupIx","categoriesData","_bindCategoryAxis","isRtl","css","proxyMembers","createProxyMember","nameTemplate","seriesClone","legacyTemplate","groupNameTemplate","logToConsole","_groupValue","ExportMixin","PDFMixin","action","persistSeriesVisibility","saveState","geom","attr","applyStylesFromKendoAttributes","mobileScrollerSelector","_mobileScroller","downEvent","applyEventMap","_closeTooltipHandler","_closeTooltip","_clearShowTimeout","sharedTemplate","colspan","colorMarker","nameColumn","sharedTemplateIterator","_offset","_ensureElement","stop","animate","showTimeout","_measure","zoomLevel","viewport","scrollTop","pageYOffset","scrollLeft","pageXOffset","movable","_fit","fakeContainer","normalizeStyle","toggleClass","_sharedContent","_pointContent","html","forceHide","_hideElement","is","appendTo","contains","fadeOut","always","tooltipTemplate","xLow","xHigh","yLow","yHigh","viewPortSize","output","_chart","_options","_filterPoints","_clearFields","toggleVisibility","_filterData"],"mappings":"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","file":"kendo.dataviz.chart.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('kendo.core.js'), require('kendo.color.js'), require('kendo.drawing.js'), require('kendo.dataviz.core.js'), require('kendo.breadcrumb.js'), require('kendo.data.js'), require('kendo.dataviz.themes.js'), require('kendo.userevents.js'), require('kendo.icons.js')) :\n    typeof define === 'function' && define.amd ? define(['kendo.core', 'kendo.color', 'kendo.drawing', 'kendo.dataviz.core', 'kendo.breadcrumb', 'kendo.data', 'kendo.dataviz.themes', 'kendo.userevents', 'kendo.icons'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.kendodataviz = global.kendodataviz || {}, global.kendodataviz.chart = global.kendodataviz.chart || {}, global.kendodataviz.chart.js = factory()));\n})(this, (function () {\n    /***********************************************************************\n     * WARNING: this file is auto-generated.  If you change it directly,\n     * your modifications will eventually be lost.  The source code is in\n     * `kendo-charts` repository, you should make your changes there and\n     * run `src-modules/sync.sh` in this repository.\n     */\n\n    (function($) {\n    /* eslint-disable */\n\n    window.kendo.dataviz = window.kendo.dataviz || {};\n    var dataviz = kendo.dataviz;\n    var Class = dataviz.Class;\n    var isNumber = dataviz.isNumber;\n    var datavizConstants = dataviz.constants;\n    var MAX_VALUE = datavizConstants.MAX_VALUE;\n    var MIN_VALUE = datavizConstants.MIN_VALUE;\n    var VALUE = datavizConstants.VALUE;\n    var DATE = datavizConstants.DATE;\n    var CENTER = datavizConstants.CENTER;\n    var TOP = datavizConstants.TOP;\n    var BOTTOM = datavizConstants.BOTTOM;\n    var LEFT = datavizConstants.LEFT;\n    var WHITE = datavizConstants.WHITE;\n    var CIRCLE = datavizConstants.CIRCLE;\n    var X = datavizConstants.X;\n    var Y = datavizConstants.Y;\n    var RIGHT = datavizConstants.RIGHT;\n    var BLACK = datavizConstants.BLACK;\n    var COORD_PRECISION = datavizConstants.COORD_PRECISION;\n    var END = datavizConstants.END;\n    var START = datavizConstants.START;\n    var DEFAULT_PRECISION = datavizConstants.DEFAULT_PRECISION;\n    var ARC = datavizConstants.ARC;\n    var defined = dataviz.defined;\n    var getter = dataviz.getter;\n    var isArray = dataviz.isArray;\n    var ChartElement = dataviz.ChartElement;\n    var Point = dataviz.Point;\n    var Box = dataviz.Box;\n    var alignPathToPixel = dataviz.alignPathToPixel;\n    var setDefaultOptions = dataviz.setDefaultOptions;\n    var isString = dataviz.isString;\n    var inArray = dataviz.inArray;\n    var isFunction = dataviz.isFunction;\n    var valueOrDefault = dataviz.valueOrDefault;\n    var isObject = dataviz.isObject;\n    var parseDate = dataviz.parseDate;\n    var deepExtend = dataviz.deepExtend;\n    var last = dataviz.last;\n    var eventElement = dataviz.eventElement;\n    var TextBox = dataviz.TextBox;\n    var getTemplate = dataviz.getTemplate;\n    var ShapeElement = dataviz.ShapeElement;\n    var getSpacing = dataviz.getSpacing;\n    var CurveProcessor = dataviz.CurveProcessor;\n    var append = dataviz.append;\n    var styleValue = dataviz.styleValue;\n    var CategoryAxis = dataviz.CategoryAxis;\n    var BoxElement = dataviz.BoxElement;\n    var Title = dataviz.Title;\n    var round = dataviz.round;\n    var limitValue = dataviz.limitValue;\n    var cycleIndex = dataviz.cycleIndex;\n    var grep = dataviz.grep;\n    var elementStyles = dataviz.elementStyles;\n    var autoTextColor = dataviz.autoTextColor;\n    var rad = dataviz.rad;\n    var bindEvents = dataviz.bindEvents;\n    var services = dataviz.services;\n    var unbindEvents = dataviz.unbindEvents;\n    var support = kendo.support;\n    var drawing = kendo.drawing;\n    var Path = drawing.Path;\n    var Animation = drawing.Animation;\n    var AnimationFactory = drawing.AnimationFactory;\n    var Group = drawing.Group;\n    var Circle = drawing.Circle;\n    var MultiPath = drawing.MultiPath;\n    var Color = kendo.Color;\n    var geometry = kendo.geometry;\n    var GeometryPoint = geometry.Point;\n    var GeometryCircle = geometry.Circle;\n    var transform = geometry.transform;\n\n    var ChartAxis = Class.extend({\n        init: function(axis) {\n\n            this._axis = axis;\n            this.options = axis.options;\n        },\n\n        value: function(point) {\n            var axis = this._axis;\n            var value = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);\n\n            return value;\n        },\n\n        slot: function(from, to, limit) {\n            if (limit === void 0) { limit = true; }\n\n            return this._axis.slot(from, to, limit);\n        },\n\n        range: function() {\n            return this._axis.range();\n        },\n\n        valueRange: function() {\n            return this._axis.valueRange();\n        }\n    });\n\n    function findAxisByName(name, axes) {\n        for (var idx = 0; idx < axes.length; idx++) {\n            if (axes[idx].options.name === name) {\n                axes[idx].prepareUserOptions();\n                return new ChartAxis(axes[idx]);\n            }\n        }\n    }\n\n    var ChartPane = kendo.Class.extend({\n        init: function(pane) {\n            this.visual = pane.visual;\n            this.chartsVisual = pane.chartContainer.visual;\n            this._pane = pane;\n        },\n\n        findAxisByName: function(name) {\n            return findAxisByName(name, this._pane.axes);\n        }\n    });\n\n    var ChartPlotArea = Class.extend({\n        init: function(plotArea) {\n\n            this._plotArea = plotArea;\n            this.visual = plotArea.visual;\n            this.backgroundVisual = plotArea._bgVisual;\n        }\n    });\n\n    function countNumbers(values) {\n        var length = values.length;\n        var count = 0;\n\n        for (var i = 0; i < length; i++) {\n            var num = values[i];\n            if (isNumber(num)) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    var Aggregates = {\n        min: function(values) {\n            var length = values.length;\n            var min = MAX_VALUE;\n\n            for (var i = 0; i < length; i++) {\n                var value = values[i];\n                if (isNumber(value)) {\n                    min = Math.min(min, value);\n                }\n            }\n\n            return min === MAX_VALUE ? values[0] : min;\n        },\n\n        max: function(values) {\n            var length = values.length;\n            var max = MIN_VALUE;\n\n            for (var i = 0; i < length; i++) {\n                var value = values[i];\n                if (isNumber(value)) {\n                    max = Math.max(max, value);\n                }\n            }\n\n            return max === MIN_VALUE ? values[0] : max;\n        },\n\n        sum: function(values) {\n            var length = values.length;\n            var sum = 0;\n\n            for (var i = 0; i < length; i++) {\n                var value = values[i];\n                if (isNumber(value)) {\n                    sum += value;\n                }\n            }\n\n            return sum;\n        },\n\n        sumOrNull: function(values) {\n            var result = null;\n\n            if (countNumbers(values)) {\n                result = Aggregates.sum(values);\n            }\n\n            return result;\n        },\n\n        count: function(values) {\n            var length = values.length;\n            var count = 0;\n\n            for (var i = 0; i < length; i++) {\n                var value = values[i];\n                if (value !== null && defined(value)) {\n                    count++;\n                }\n            }\n\n            return count;\n        },\n\n        avg: function(values) {\n            var count = countNumbers(values);\n            var result = values[0];\n\n            if (count > 0) {\n                result = Aggregates.sum(values) / count;\n            }\n\n            return result;\n        },\n\n        first: function(values) {\n            var length = values.length;\n\n            for (var i = 0; i < length; i++) {\n                var value = values[i];\n                if (value !== null && defined(value)) {\n                    return value;\n                }\n            }\n\n            return values[0];\n        }\n    };\n\n    function getField(field, row) {\n        if (row === null) {\n            return row;\n        }\n\n        var get = getter(field, true);\n        return get(row);\n    }\n\n    var SeriesBinder = Class.extend({\n        init: function() {\n\n            this._valueFields = {};\n            this._otherFields = {};\n            this._nullValue = {};\n            this._undefinedValue = {};\n        },\n\n        register: function(seriesTypes, valueFields, otherFields) {\n            var this$1$1 = this;\n            if (valueFields === void 0) { valueFields = [ VALUE ]; }\n            if (otherFields === void 0) { otherFields = {}; }\n\n            for (var i = 0; i < seriesTypes.length; i++) {\n                var type = seriesTypes[i];\n\n                this$1$1._valueFields[type] = valueFields;\n                this$1$1._otherFields[type] = otherFields;\n                this$1$1._nullValue[type] = this$1$1._makeValue(valueFields, null);\n                this$1$1._undefinedValue[type] = this$1$1._makeValue(valueFields, undefined);\n            }\n        },\n\n        canonicalFields: function(series) {\n            return this.valueFields(series).concat(this.otherFields(series));\n        },\n\n        valueFields: function(series) {\n            return this._valueFields[series.type] || [ VALUE ];\n        },\n\n        otherFields: function(series) {\n            return this._otherFields[series.type] || [ VALUE ];\n        },\n\n        bindPoint: function(series, pointIx, item) {\n            var data = series.data;\n            var pointData = defined(item) ? item : data[pointIx];\n            var result = { valueFields: { value: pointData } };\n            var valueFields = this.valueFields(series);\n            var otherFields = this._otherFields[series.type];\n            var fields, value;\n\n            if (pointData === null) {\n                value = this._nullValue[series.type];\n            } else if (!defined(pointData)) {\n                value = this._undefinedValue[series.type];\n            } else if (Array.isArray(pointData)) {\n                var fieldData = pointData.slice(valueFields.length);\n                value = this._bindFromArray(pointData, valueFields);\n                fields = this._bindFromArray(fieldData, otherFields);\n            } else if (typeof pointData === \"object\") {\n                var srcValueFields = this.sourceFields(series, valueFields);\n                var srcPointFields = this.sourceFields(series, otherFields);\n\n                value = this._bindFromObject(pointData, valueFields, srcValueFields);\n                fields = this._bindFromObject(pointData, otherFields, srcPointFields);\n            }\n\n            if (defined(value)) {\n                if (valueFields.length === 1) {\n                    result.valueFields.value = value[valueFields[0]];\n                } else {\n                    result.valueFields = value;\n                }\n            }\n\n            result.fields = fields || {};\n\n            return result;\n        },\n\n        _makeValue: function(fields, initialValue) {\n            var value = {};\n            var length = fields.length;\n\n            for (var i = 0; i < length; i++) {\n                var fieldName = fields[i];\n                value[fieldName] = initialValue;\n            }\n\n            return value;\n        },\n\n        _bindFromArray: function(array, fields) {\n            var value = {};\n\n            if (fields) {\n                var length = Math.min(fields.length, array.length);\n\n                for (var i = 0; i < length; i++) {\n                    value[fields[i]] = array[i];\n                }\n            }\n\n            return value;\n        },\n\n        _bindFromObject: function(object, fields, srcFields) {\n            if (srcFields === void 0) { srcFields = fields; }\n\n            var value = {};\n\n            if (fields) {\n                var length = fields.length;\n\n                for (var i = 0; i < length; i++) {\n                    var fieldName = fields[i];\n                    var srcFieldName = srcFields[i];\n                    if (srcFieldName !== null) {\n                        value[fieldName] = getField(srcFieldName, object);\n                    }\n                }\n            }\n\n            return value;\n        },\n\n        sourceFields: function(series, canonicalFields) {\n            var sourceFields = [];\n\n            if (canonicalFields) {\n                var length = canonicalFields.length;\n\n                for (var i = 0; i < length; i++) {\n                    var fieldName = canonicalFields[i];\n                    var sourceFieldName = fieldName === VALUE ? \"field\" : fieldName + \"Field\";\n\n                    sourceFields.push(series[sourceFieldName] !== null ? (series[sourceFieldName] || fieldName) : null);\n                }\n            }\n\n            return sourceFields;\n        }\n    });\n\n    SeriesBinder.current = new SeriesBinder();\n\n    var STD_ERR = \"stderr\";\n    var STD_DEV = \"stddev\";\n    var percentRegex = /percent(?:\\w*)\\((\\d+)\\)/;\n    var standardDeviationRegex = new RegExp(\"^\" + STD_DEV + \"(?:\\\\((\\\\d+(?:\\\\.\\\\d+)?)\\\\))?$\");\n\n    var ErrorRangeCalculator = Class.extend({\n        init: function(errorValue, series, field) {\n\n            this.initGlobalRanges(errorValue, series, field);\n        },\n\n        initGlobalRanges: function(errorValue, series, field) {\n            var data = series.data;\n            var deviationMatch = standardDeviationRegex.exec(errorValue);\n\n            if (deviationMatch) {\n                this.valueGetter = this.createValueGetter(series, field);\n\n                var average = this.getAverage(data);\n                var deviation = this.getStandardDeviation(data, average, false);\n                var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;\n                var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };\n\n                this.globalRange = function() {\n                    return errorRange;\n                };\n            } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {\n                this.valueGetter = this.createValueGetter(series, field);\n                var standardError = this.getStandardError(data, this.getAverage(data));\n\n                this.globalRange = function(value) {\n                    return { low: value - standardError, high: value + standardError };\n                };\n            }\n        },\n\n        createValueGetter: function(series, field) {\n            var data = series.data;\n            var binder = SeriesBinder.current;\n            var valueFields = binder.valueFields(series);\n            var item = defined(data[0]) ? data[0] : {};\n            var valueGetter;\n\n            if (isArray(item)) {\n                var index = field ? valueFields.indexOf(field) : 0;\n                valueGetter = getter(\"[\" + index + \"]\");\n            } else if (isNumber(item)) {\n                valueGetter = getter();\n            } else if (typeof item === datavizConstants.OBJECT) {\n                var srcValueFields = binder.sourceFields(series, valueFields);\n                valueGetter = getter(srcValueFields[valueFields.indexOf(field)]);\n            }\n\n            return valueGetter;\n        },\n\n        getErrorRange: function(pointValue, errorValue) {\n            var low, high, value;\n\n            if (!defined(errorValue)) {\n                return null;\n            }\n\n            if (this.globalRange) {\n                return this.globalRange(pointValue);\n            }\n\n            if (isArray(errorValue)) {\n                low = pointValue - errorValue[0];\n                high = pointValue + errorValue[1];\n            } else if (isNumber(value = parseFloat(errorValue))) {\n                low = pointValue - value;\n                high = pointValue + value;\n            } else if ((value = percentRegex.exec(errorValue))) {\n                var percentValue = pointValue * (parseFloat(value[1]) / 100);\n                low = pointValue - Math.abs(percentValue);\n                high = pointValue + Math.abs(percentValue);\n            } else {\n                throw new Error(\"Invalid ErrorBar value: \" + errorValue);\n            }\n\n            return { low: low, high: high };\n        },\n\n        getStandardError: function(data, average) {\n            return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);\n        },\n\n        getStandardDeviation: function(data, average, isSample) {\n            var this$1$1 = this;\n\n            var length = data.length;\n            var total = isSample ? average.count - 1 : average.count;\n            var squareDifferenceSum = 0;\n\n            for (var idx = 0; idx < length; idx++) {\n                var value = this$1$1.valueGetter(data[idx]);\n                if (isNumber(value)) {\n                    squareDifferenceSum += Math.pow(value - average.value, 2);\n                }\n            }\n\n            return Math.sqrt(squareDifferenceSum / total);\n        },\n\n        getAverage: function(data) {\n            var this$1$1 = this;\n\n            var length = data.length;\n            var sum = 0;\n            var count = 0;\n\n            for (var idx = 0; idx < length; idx++) {\n                var value = this$1$1.valueGetter(data[idx]);\n                if (isNumber(value)) {\n                    sum += value;\n                    count++;\n                }\n            }\n\n            return {\n                value: sum / count,\n                count: count\n            };\n        }\n    });\n\n    var browser = support.browser || {};\n\n    var INITIAL_ANIMATION_DURATION = 600;\n    var FADEIN = \"fadeIn\";\n\n    var GLASS = \"glass\";\n    var BORDER_BRIGHTNESS = 0.8;\n    var TOOLTIP_OFFSET = 5;\n    var START_SCALE = browser.msie ? 0.001 : 0;\n    var ERROR_LOW_FIELD = \"errorLow\";\n    var ERROR_HIGH_FIELD = \"errorHigh\";\n    var X_ERROR_LOW_FIELD = \"xErrorLow\";\n    var X_ERROR_HIGH_FIELD = \"xErrorHigh\";\n    var Y_ERROR_LOW_FIELD = \"yErrorLow\";\n    var Y_ERROR_HIGH_FIELD = \"yErrorHigh\";\n    var LINE_MARKER_SIZE = 8;\n    var ZERO = \"zero\";\n    var INTERPOLATE = \"interpolate\";\n    var GAP = \"gap\";\n    var ABOVE = \"above\";\n    var BELOW = \"below\";\n\n    var SMOOTH = \"smooth\";\n    var STEP = \"step\";\n\n    var AREA = \"area\";\n    var BAR = \"bar\";\n    var BOX_PLOT = \"boxPlot\";\n    var BUBBLE = \"bubble\";\n    var BULLET = \"bullet\";\n    var CANDLESTICK = \"candlestick\";\n    var COLUMN = \"column\";\n    var DONUT = \"donut\";\n    var FUNNEL = \"funnel\";\n    var PYRAMID = \"pyramid\";\n    var HEATMAP = \"heatmap\";\n    var HORIZONTAL_WATERFALL = \"horizontalWaterfall\";\n    var LINE = \"line\";\n    var OHLC = \"ohlc\";\n    var PIE = \"pie\";\n    var POLAR_AREA = \"polarArea\";\n    var POLAR_LINE = \"polarLine\";\n    var POLAR_SCATTER = \"polarScatter\";\n    var RADAR_AREA = \"radarArea\";\n    var RADAR_COLUMN = \"radarColumn\";\n    var RADAR_LINE = \"radarLine\";\n    var RANGE_AREA = \"rangeArea\";\n    var RANGE_BAR = \"rangeBar\";\n    var RANGE_COLUMN = \"rangeColumn\";\n    var SCATTER = \"scatter\";\n    var SCATTER_LINE = \"scatterLine\";\n    var VERTICAL_AREA = \"verticalArea\";\n    var VERTICAL_BOX_PLOT = \"verticalBoxPlot\";\n    var VERTICAL_BULLET = \"verticalBullet\";\n    var VERTICAL_LINE = \"verticalLine\";\n    var VERTICAL_RANGE_AREA = \"verticalRangeArea\";\n    var WATERFALL = \"waterfall\";\n    var EQUALLY_SPACED_SERIES = [\n        BAR, COLUMN, OHLC, CANDLESTICK, BOX_PLOT, VERTICAL_BOX_PLOT,\n        BULLET, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL\n    ];\n\n    var TRENDLINE_EXPONENTIAL = 'exponentialTrendline';\n    var TRENDLINE_LINEAR = 'linearTrendline';\n    var TRENDLINE_LOGARITHMIC = 'logarithmicTrendline';\n    var TRENDLINE_MOVING_AVERAGE = 'movingAverageTrendline';\n    var TRENDLINE_POLYNOMIAL = 'polynomialTrendline';\n    var TRENDLINE_POWER = 'powerTrendline';\n    var TRENDLINE_SERIES = [\n        TRENDLINE_EXPONENTIAL,\n        TRENDLINE_LINEAR,\n        TRENDLINE_LOGARITHMIC,\n        TRENDLINE_MOVING_AVERAGE,\n        TRENDLINE_POLYNOMIAL,\n        TRENDLINE_POWER\n    ];\n\n    var LEGEND_ITEM_CLICK = \"legendItemClick\";\n    var LEGEND_ITEM_HOVER = \"legendItemHover\";\n    var LEGEND_ITEM_LEAVE = \"legendItemLeave\";\n    var SERIES_CLICK = \"seriesClick\";\n    var SERIES_HOVER = \"seriesHover\";\n    var SERIES_OVER = \"seriesOver\";\n    var SERIES_LEAVE = \"seriesLeave\";\n    var PLOT_AREA_CLICK = \"plotAreaClick\";\n    var PLOT_AREA_HOVER = \"plotAreaHover\";\n    var PLOT_AREA_LEAVE = \"plotAreaLeave\";\n    var DRAG = \"drag\";\n    var DRAG_END = \"dragEnd\";\n    var DRAG_START = \"dragStart\";\n    var ZOOM_START = \"zoomStart\";\n    var ZOOM = \"zoom\";\n    var ZOOM_END = \"zoomEnd\";\n    var SELECT_START = \"selectStart\";\n    var SELECT = \"select\";\n    var SELECT_END = \"selectEnd\";\n    var RENDER = \"render\";\n    var SHOW_TOOLTIP = \"showTooltip\";\n    var HIDE_TOOLTIP = \"hideTooltip\";\n    var PANE_RENDER = \"paneRender\";\n\n    var CHART_POINT_ROLE = \"graphics-symbol\";\n    var CHART_POINT_CLASSNAME = \"k-chart-point\";\n    var CHART_POINT_ROLE_DESCRIPTION = \"Point\";\n    var LEGEND_ITEM_ROLE = \"checkbox\";\n    var LEGEND_ITEM_CLASSNAME = \"k-chart-legend-item\";\n    var LEGEND_ITEM_ARIA_ROLE_DESCRIPTION = \"Legend item\";\n\n    var LOGARITHMIC = \"log\";\n    var CATEGORY = \"category\";\n\n    var INSIDE_END = \"insideEnd\";\n    var INSIDE_BASE = \"insideBase\";\n    var OUTSIDE_END = \"outsideEnd\";\n\n    var MOUSEWHEEL = \"wheel\";\n    var MOUSEWHEEL_DELAY = 150;\n    var MOUSEWHEEL_ZOOM_RATE = 0.3;\n\n    var DRILLDOWN = \"drilldown\";\n    var DRILLDOWN_FIELD = \"drilldown\";\n\n    var MIN_MOVING_AVERAGE_PERIOD = 2;\n\n    var constants = {\n    \tINITIAL_ANIMATION_DURATION: INITIAL_ANIMATION_DURATION,\n    \tFADEIN: FADEIN,\n    \tLEGEND_ITEM_CLICK: LEGEND_ITEM_CLICK,\n    \tLEGEND_ITEM_HOVER: LEGEND_ITEM_HOVER,\n    \tLEGEND_ITEM_LEAVE: LEGEND_ITEM_LEAVE,\n    \tSERIES_CLICK: SERIES_CLICK,\n    \tSERIES_HOVER: SERIES_HOVER,\n    \tSERIES_OVER: SERIES_OVER,\n    \tSERIES_LEAVE: SERIES_LEAVE,\n    \tGLASS: GLASS,\n    \tBORDER_BRIGHTNESS: BORDER_BRIGHTNESS,\n    \tTOOLTIP_OFFSET: TOOLTIP_OFFSET,\n    \tSTART_SCALE: START_SCALE,\n    \tERROR_LOW_FIELD: ERROR_LOW_FIELD,\n    \tERROR_HIGH_FIELD: ERROR_HIGH_FIELD,\n    \tX_ERROR_LOW_FIELD: X_ERROR_LOW_FIELD,\n    \tX_ERROR_HIGH_FIELD: X_ERROR_HIGH_FIELD,\n    \tY_ERROR_LOW_FIELD: Y_ERROR_LOW_FIELD,\n    \tY_ERROR_HIGH_FIELD: Y_ERROR_HIGH_FIELD,\n    \tLINE_MARKER_SIZE: LINE_MARKER_SIZE,\n    \tINTERPOLATE: INTERPOLATE,\n    \tZERO: ZERO,\n    \tSMOOTH: SMOOTH,\n    \tSTEP: STEP,\n    \tCATEGORY: CATEGORY,\n    \tFUNNEL: FUNNEL,\n    \tPYRAMID: PYRAMID,\n    \tBAR: BAR,\n    \tCANDLESTICK: CANDLESTICK,\n    \tPIE: PIE,\n    \tCOLUMN: COLUMN,\n    \tAREA: AREA,\n    \tVERTICAL_BULLET: VERTICAL_BULLET,\n    \tBOX_PLOT: BOX_PLOT,\n    \tOHLC: OHLC,\n    \tWATERFALL: WATERFALL,\n    \tLINE: LINE,\n    \tBULLET: BULLET,\n    \tVERTICAL_LINE: VERTICAL_LINE,\n    \tVERTICAL_AREA: VERTICAL_AREA,\n    \tRANGE_AREA: RANGE_AREA,\n    \tVERTICAL_RANGE_AREA: VERTICAL_RANGE_AREA,\n    \tRANGE_COLUMN: RANGE_COLUMN,\n    \tVERTICAL_BOX_PLOT: VERTICAL_BOX_PLOT,\n    \tRANGE_BAR: RANGE_BAR,\n    \tHORIZONTAL_WATERFALL: HORIZONTAL_WATERFALL,\n    \tSCATTER: SCATTER,\n    \tSCATTER_LINE: SCATTER_LINE,\n    \tBUBBLE: BUBBLE,\n    \tRADAR_AREA: RADAR_AREA,\n    \tRADAR_LINE: RADAR_LINE,\n    \tRADAR_COLUMN: RADAR_COLUMN,\n    \tPOLAR_LINE: POLAR_LINE,\n    \tPOLAR_AREA: POLAR_AREA,\n    \tPOLAR_SCATTER: POLAR_SCATTER,\n    \tRENDER: RENDER,\n    \tPLOT_AREA_CLICK: PLOT_AREA_CLICK,\n    \tPLOT_AREA_HOVER: PLOT_AREA_HOVER,\n    \tPLOT_AREA_LEAVE: PLOT_AREA_LEAVE,\n    \tLOGARITHMIC: LOGARITHMIC,\n    \tDRAG: DRAG,\n    \tDRAG_START: DRAG_START,\n    \tDRAG_END: DRAG_END,\n    \tZOOM_START: ZOOM_START,\n    \tZOOM: ZOOM,\n    \tZOOM_END: ZOOM_END,\n    \tSELECT_START: SELECT_START,\n    \tSELECT: SELECT,\n    \tSELECT_END: SELECT_END,\n    \tPANE_RENDER: PANE_RENDER,\n    \tGAP: GAP,\n    \tDONUT: DONUT,\n    \tINSIDE_END: INSIDE_END,\n    \tINSIDE_BASE: INSIDE_BASE,\n    \tOUTSIDE_END: OUTSIDE_END,\n    \tMOUSEWHEEL: MOUSEWHEEL,\n    \tMOUSEWHEEL_DELAY: MOUSEWHEEL_DELAY,\n    \tMOUSEWHEEL_ZOOM_RATE: MOUSEWHEEL_ZOOM_RATE,\n    \tSHOW_TOOLTIP: SHOW_TOOLTIP,\n    \tHIDE_TOOLTIP: HIDE_TOOLTIP,\n    \tEQUALLY_SPACED_SERIES: EQUALLY_SPACED_SERIES,\n    \tABOVE: ABOVE,\n    \tBELOW: BELOW,\n    \tHEATMAP: HEATMAP,\n    \tDRILLDOWN: DRILLDOWN,\n    \tDRILLDOWN_FIELD: DRILLDOWN_FIELD,\n    \tMIN_MOVING_AVERAGE_PERIOD: MIN_MOVING_AVERAGE_PERIOD,\n    \tTRENDLINE_SERIES: TRENDLINE_SERIES,\n    \tTRENDLINE_EXPONENTIAL: TRENDLINE_EXPONENTIAL,\n    \tTRENDLINE_LINEAR: TRENDLINE_LINEAR,\n    \tTRENDLINE_LOGARITHMIC: TRENDLINE_LOGARITHMIC,\n    \tTRENDLINE_MOVING_AVERAGE: TRENDLINE_MOVING_AVERAGE,\n    \tTRENDLINE_POLYNOMIAL: TRENDLINE_POLYNOMIAL,\n    \tTRENDLINE_POWER: TRENDLINE_POWER,\n    \tCHART_POINT_ROLE: CHART_POINT_ROLE,\n    \tCHART_POINT_CLASSNAME: CHART_POINT_CLASSNAME,\n    \tCHART_POINT_ROLE_DESCRIPTION: CHART_POINT_ROLE_DESCRIPTION,\n    \tLEGEND_ITEM_ROLE: LEGEND_ITEM_ROLE,\n    \tLEGEND_ITEM_CLASSNAME: LEGEND_ITEM_CLASSNAME,\n    \tLEGEND_ITEM_ARIA_ROLE_DESCRIPTION: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION\n    };\n\n    var DEFAULT_ERROR_BAR_WIDTH = 4;\n\n    var ErrorBarBase = ChartElement.extend({\n        init: function(low, high, isVertical, chart, series, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.low = low;\n            this.high = high;\n            this.isVertical = isVertical;\n            this.chart = chart;\n            this.series = series;\n        },\n\n        reflow: function(targetBox) {\n            var endCaps = this.options.endCaps;\n            var isVertical = this.isVertical;\n            var axis = this.getAxis();\n            var valueBox = axis.getSlot(this.low, this.high);\n            var centerBox = targetBox.center();\n            var capsWidth = this.getCapsWidth(targetBox, isVertical);\n            var capValue = isVertical ? centerBox.x : centerBox.y;\n            var capStart = capValue - capsWidth;\n            var capEnd = capValue + capsWidth;\n            var linePoints;\n\n            if (isVertical) {\n                linePoints = [\n                    new Point(centerBox.x, valueBox.y1),\n                    new Point(centerBox.x, valueBox.y2)\n                ];\n                if (endCaps) {\n                    linePoints.push(new Point(capStart, valueBox.y1),\n                        new Point(capEnd, valueBox.y1),\n                        new Point(capStart, valueBox.y2),\n                        new Point(capEnd, valueBox.y2));\n                }\n                this.box = new Box(capStart, valueBox.y1, capEnd, valueBox.y2);\n            } else {\n                linePoints = [\n                    new Point(valueBox.x1, centerBox.y),\n                    new Point(valueBox.x2, centerBox.y)\n                ];\n                if (endCaps) {\n                    linePoints.push(new Point(valueBox.x1, capStart),\n                        new Point(valueBox.x1, capEnd),\n                        new Point(valueBox.x2, capStart),\n                        new Point(valueBox.x2, capEnd));\n                }\n                this.box = new Box(valueBox.x1, capStart, valueBox.x2, capEnd);\n            }\n\n            this.linePoints = linePoints;\n        },\n\n        getCapsWidth: function(box, isVertical) {\n            var boxSize = isVertical ? box.width() : box.height();\n            var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\n\n            return capsWidth;\n        },\n\n        createVisual: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var visual = options.visual;\n\n            if (visual) {\n                this.visual = visual({\n                    low: this.low,\n                    high: this.high,\n                    rect: this.box.toRect(),\n                    sender: this.getSender(),\n                    options: {\n                        endCaps: options.endCaps,\n                        color: options.color,\n                        line: options.line\n                    },\n                    createVisual: function () {\n                        this$1$1.createDefaultVisual();\n                        var defaultVisual = this$1$1.visual;\n                        delete this$1$1.visual;\n                        return defaultVisual;\n                    }\n                });\n            } else {\n                this.createDefaultVisual();\n            }\n        },\n\n        createDefaultVisual: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var linePoints = ref.linePoints;\n            var lineOptions = {\n                stroke: {\n                    color: options.color,\n                    width: options.line.width,\n                    dashType: options.line.dashType\n                }\n            };\n\n            ChartElement.fn.createVisual.call(this);\n\n            for (var idx = 0; idx < linePoints.length; idx += 2) {\n                var line = new Path(lineOptions)\n                    .moveTo(linePoints[idx].x, linePoints[idx].y)\n                    .lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\n\n                alignPathToPixel(line);\n                this$1$1.visual.append(line);\n            }\n        }\n    });\n\n    setDefaultOptions(ErrorBarBase, {\n        animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n        },\n        endCaps: true,\n        line: {\n            width: 2\n        },\n        zIndex: 1\n    });\n\n    var CategoricalErrorBar = ErrorBarBase.extend({\n        getAxis: function() {\n            var axis = this.chart.seriesValueAxis(this.series);\n\n            return axis;\n        }\n    });\n\n    function anyHasZIndex(elements) {\n        for (var idx = 0; idx < elements.length; idx++) {\n            if (defined(elements[idx].zIndex)) {\n                return true;\n            }\n        }\n    }\n\n    function appendIfNotNull(array, element) {\n        if (element !== null) {\n            array.push(element);\n        }\n    }\n\n    function areNumbers(values) {\n        return countNumbers(values) === values.length;\n    }\n\n    function segmentVisible(series, fields, index) {\n        var visible = fields.visible;\n        if (defined(visible)) {\n            return visible;\n        }\n\n        var pointVisibility = series.pointVisibility;\n        if (pointVisibility) {\n            return pointVisibility[index];\n        }\n    }\n\n    function bindSegments(series) {\n        var data = series.data;\n        var points = [];\n        var sum = 0;\n        var count = 0;\n\n        for (var idx = 0; idx < data.length; idx++) {\n            var pointData = SeriesBinder.current.bindPoint(series, idx);\n            var value = pointData.valueFields.value;\n\n            if (isString(value)) {\n                value = parseFloat(value);\n            }\n\n            if (isNumber(value)) {\n                pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;\n\n                pointData.value = Math.abs(value);\n                points.push(pointData);\n\n                if (pointData.visible) {\n                    sum += pointData.value;\n                }\n\n                if (value !== 0) {\n                    count++;\n                }\n            } else {\n                points.push(null);\n            }\n        }\n\n        return {\n            total: sum,\n            points: points,\n            count: count\n        };\n    }\n\n    function categoriesCount(series) {\n        var seriesCount = series.length;\n        var categories = 0;\n\n        for (var i = 0; i < seriesCount; i++) {\n            categories = Math.max(categories, series[i].data.length);\n        }\n\n        return categories;\n    }\n\n    function equalsIgnoreCase(a, b) {\n        if (a && b) {\n            return a.toLowerCase() === b.toLowerCase();\n        }\n\n        return a === b;\n    }\n\n    var MAX_EXPAND_DEPTH = 5;\n\n    function evalOptions(options, context, state, dryRun) {\n        if (state === void 0) { state = {}; }\n        if (dryRun === void 0) { dryRun = false; }\n\n        var defaults = state.defaults = state.defaults || {};\n        var depth = state.depth = state.depth || 0;\n        var needsEval = false;\n\n        state.excluded = state.excluded || [];\n\n        if (depth > MAX_EXPAND_DEPTH) {\n            return null;\n        }\n\n        for (var property in options) {\n            if (!inArray(property, state.excluded) && dataviz.hasOwnProperty(options, property)) {\n                var propValue = options[property];\n                if (isFunction(propValue)) {\n                    needsEval = true;\n                    if (!dryRun) {\n                        options[property] = valueOrDefault(propValue(context), defaults[property]);\n                    }\n                } else if (isObject(propValue)) {\n                    if (!dryRun) {\n                        state.defaults = defaults[property];\n                    }\n                    state.depth++;\n                    needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;\n                    state.depth--;\n                }\n            }\n        }\n\n        return needsEval;\n    }\n\n    function filterSeriesByType(series, types) {\n        var result = [];\n\n        var seriesTypes = [].concat(types);\n        for (var idx = 0; idx < series.length; idx++) {\n            var currentSeries = series[idx];\n            if (inArray(currentSeries.type, seriesTypes)) {\n                result.push(currentSeries);\n            }\n        }\n\n        return result;\n    }\n\n    var dateCache = new WeakMap();\n\n    function parseDateCategory(category, row, intlService) {\n        if (row === null || typeof row !== 'object') {\n            return parseDate(intlService, category);\n        }\n\n        var date = dateCache.get(row);\n        if (!date) {\n            date = parseDate(intlService, category);\n            dateCache.set(row, date);\n        }\n\n        return date;\n    }\n\n    function hasGradientOverlay(options) {\n        var overlay = options.overlay;\n\n        return overlay && overlay.gradient && overlay.gradient !== \"none\";\n    }\n\n    function hasValue(value) {\n        return defined(value) && value !== null;\n    }\n\n    function isDateAxis(axisOptions, sampleCategory) {\n        var type = axisOptions.type;\n        var dateCategory = sampleCategory instanceof Date;\n\n        return (!type && dateCategory) || equalsIgnoreCase(type, DATE);\n    }\n\n    function singleItemOrArray(array) {\n        return array.length === 1 ? array[0] : array;\n    }\n\n    var AREA_REGEX = /area/i;\n\n    function seriesMissingValues(series) {\n        if (series.missingValues) {\n            return series.missingValues;\n        }\n\n        return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n    }\n\n    function hasValue$1(series, item) {\n        var fields = SeriesBinder.current.bindPoint(series, null, item);\n        var valueFields = fields.valueFields;\n\n        for (var field in valueFields) {\n            if (dataviz.convertableToNumber(valueFields[field])) {\n                return true;\n            }\n        }\n    }\n\n    function findNext(ref) {\n        var start = ref.start;\n        var dir = ref.dir;\n        var min = ref.min;\n        var max = ref.max;\n        var getter$$1 = ref.getter;\n        var hasItem = ref.hasItem;\n        var series = ref.series;\n\n        var pointHasValue, outPoint;\n        var idx = start;\n        do {\n            idx += dir;\n            //aggregating and binding the item takes too much time for large number of categories\n            //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n            if (hasItem(idx)) {\n                outPoint = getter$$1(idx);\n                pointHasValue = hasValue$1(series, outPoint.item);\n            }\n        } while (min <= idx && idx <= max && !pointHasValue);\n\n        if (pointHasValue) {\n            return outPoint;\n        }\n    }\n\n    function createOutOfRangePoints(series, range, count, getter$$1, hasItem) {\n        var min = range.min;\n        var max = range.max;\n        var hasMinPoint = min > 0 && min < count;\n        var hasMaxPoint = max + 1 < count;\n\n        if (hasMinPoint || hasMaxPoint) {\n            var missingValues = seriesMissingValues(series);\n            var minPoint, maxPoint;\n            if (missingValues !== INTERPOLATE) {\n                if (hasMinPoint) {\n                    minPoint = getter$$1(min - 1);\n                }\n\n                if (hasMaxPoint) {\n                    maxPoint = getter$$1(max + 1);\n                }\n            } else {\n                var outPoint, pointHasValue;\n                if (hasMinPoint) {\n                    outPoint = getter$$1(min - 1);\n                    pointHasValue = hasValue$1(series, outPoint.item);\n                    if (!pointHasValue) {\n                        minPoint = findNext({\n                            start: min,\n                            dir: -1,\n                            min: 0,\n                            max: count - 1,\n                            getter: getter$$1,\n                            hasItem: hasItem,\n                            series: series\n                        });\n                    } else {\n                        minPoint = outPoint;\n                    }\n                }\n\n                if (hasMaxPoint) {\n                    outPoint = getter$$1(max + 1);\n                    pointHasValue = hasValue$1(series, outPoint.item);\n                    if (!pointHasValue) {\n                        maxPoint = findNext({\n                            start: max,\n                            dir: 1,\n                            min: 0,\n                            max: count - 1,\n                            getter: getter$$1,\n                            hasItem: hasItem,\n                            series: series\n                        });\n                    } else {\n                        maxPoint = outPoint;\n                    }\n                }\n            }\n\n            if (minPoint) {\n                series._outOfRangeMinPoint = minPoint;\n            }\n\n            if (maxPoint) {\n                series._outOfRangeMaxPoint = maxPoint;\n            }\n        }\n    }\n\n    var CategoricalChart = ChartElement.extend({\n        init: function(plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n            // Value axis ranges grouped by axis name, e.g.:\n            // primary: { min: 0, max: 1 }\n            this.valueAxisRanges = {};\n\n            this.points = [];\n            this.categoryPoints = [];\n            this.seriesPoints = [];\n            this.seriesOptions = [];\n            this._evalSeries = [];\n\n            this.render();\n        },\n\n        render: function() {\n            this.traverseDataPoints(this.addValue.bind(this));\n        },\n\n        pointOptions: function(series, seriesIx) {\n            var options = this.seriesOptions[seriesIx];\n            if (!options) {\n                var defaults = this.pointType().prototype.defaults;\n                this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\n                    vertical: !this.options.invertAxes\n                }, series);\n            }\n\n            return options;\n        },\n\n        plotValue: function(point) {\n            if (!point) {\n                return 0;\n            }\n\n            if (this.options.isStacked100 && isNumber(point.value)) {\n                var categoryIx = point.categoryIx;\n                var categoryPoints = this.categoryPoints[categoryIx];\n                var otherValues = [];\n                var categorySum = 0;\n\n                for (var i = 0; i < categoryPoints.length; i++) {\n                    var other = categoryPoints[i];\n                    if (other) {\n                        var stack = point.series.stack;\n                        var otherStack = other.series.stack;\n\n                        if ((stack && otherStack) && stack.group !== otherStack.group) {\n                            continue;\n                        }\n\n                        if (isNumber(other.value)) {\n                            categorySum += Math.abs(other.value);\n                            otherValues.push(Math.abs(other.value));\n                        }\n                    }\n                }\n\n                if (categorySum > 0) {\n                    return point.value / categorySum;\n                }\n            }\n\n            return point.value;\n        },\n\n        plotRange: function(point, startValue) {\n            var this$1$1 = this;\n            if (startValue === void 0) { startValue = 0; }\n\n            var categoryPoints = this.categoryPoints[point.categoryIx];\n\n            if (this.options.isStacked) {\n                var plotValue = this.plotValue(point);\n                var positive = plotValue >= 0;\n                var prevValue = startValue;\n                var isStackedBar = false;\n                var stack = defined(point.series.stack) ? point.series.stack : this.options.defaultStack;\n                var isNonGroupStack = function (stack) { return stack === true || typeof stack === datavizConstants.OBJECT && !stack.group; };\n\n                if (stack) {\n                    for (var i = 0; i < categoryPoints.length; i++) {\n                        var other = categoryPoints[i];\n\n                        if (point === other) {\n                            break;\n                        }\n\n                        var otherStack = defined(other.series.stack) ? other.series.stack : this$1$1.options.defaultStack;\n\n                        if (!otherStack) {\n                            continue;\n                        }\n\n                        if (typeof stack === datavizConstants.STRING && stack !== otherStack) {\n                            continue;\n                        }\n\n                        if (isNonGroupStack(stack) && !isNonGroupStack(otherStack)) {\n                            continue;\n                        }\n\n                        if (stack.group && stack.group !== otherStack.group) {\n                            continue;\n                        }\n\n                        var otherValue = this$1$1.plotValue(other);\n                        if ((otherValue >= 0 && positive) ||\n                            (otherValue < 0 && !positive)) {\n                            // zero values should be skipped for log axis (startValue !== 0)\n                            if (startValue === 0 || otherValue !== 0) {\n                                prevValue += otherValue;\n                                plotValue += otherValue;\n                                isStackedBar = true;\n\n                                if (this$1$1.options.isStacked100) {\n                                    plotValue = Math.min(plotValue, 1);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (isStackedBar) {\n                    prevValue -= startValue;\n                }\n\n                return [ prevValue, plotValue ];\n            }\n\n            var series = point.series;\n            var valueAxis = this.seriesValueAxis(series);\n            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n            return [ axisCrossingValue, dataviz.convertableToNumber(point.value) ? point.value : axisCrossingValue ];\n        },\n\n        stackLimits: function(axisName, stackName) {\n            var this$1$1 = this;\n\n            var min = MAX_VALUE;\n            var max = MIN_VALUE;\n\n            for (var i = 0; i < this.categoryPoints.length; i++) {\n                var categoryPoints = this$1$1.categoryPoints[i];\n                if (!categoryPoints) {\n                    continue;\n                }\n\n                for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\n                    var point = categoryPoints[pIx];\n                    if (point) {\n                        if (point.series.stack === stackName || point.series.axis === axisName) {\n                            var to = this$1$1.plotRange(point, 0)[1];\n                            if (defined(to) && isFinite(to)) {\n                                max = Math.max(max, to);\n                                min = Math.min(min, to);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return { min: min, max: max };\n        },\n\n        updateStackRange: function() {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var isStacked = ref.isStacked;\n            var chartSeries = ref.series;\n            var limitsCache = {};\n\n            if (isStacked) {\n                for (var i = 0; i < chartSeries.length; i++) {\n                    var series = chartSeries[i];\n                    var axisName = series.axis;\n                    var key = axisName + series.stack;\n\n                    var limits = limitsCache[key];\n                    if (!limits) {\n                        limits = this$1$1.stackLimits(axisName, series.stack);\n\n                        var errorTotals = this$1$1.errorTotals;\n                        if (errorTotals) {\n                            if (errorTotals.negative.length) {\n                                limits.min = Math.min(limits.min, dataviz.sparseArrayLimits(errorTotals.negative).min);\n                            }\n                            if (errorTotals.positive.length) {\n                                limits.max = Math.max(limits.max, dataviz.sparseArrayLimits(errorTotals.positive).max);\n                            }\n                        }\n\n                        if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n                            limitsCache[key] = limits;\n                        } else {\n                            limits = null;\n                        }\n                    }\n\n                    if (limits) {\n                        this$1$1.valueAxisRanges[axisName] = limits;\n                    }\n                }\n            }\n        },\n\n        addErrorBar: function(point, data, categoryIx) {\n            var value = point.value;\n            var series = point.series;\n            var seriesIx = point.seriesIx;\n            var errorBars = point.options.errorBars;\n            var lowValue = data.fields[ERROR_LOW_FIELD];\n            var highValue = data.fields[ERROR_HIGH_FIELD];\n            var errorRange;\n\n            if (isNumber(lowValue) && isNumber(highValue)) {\n                errorRange = { low: lowValue, high: highValue };\n            } else if (errorBars && defined(errorBars.value)) {\n                this.seriesErrorRanges = this.seriesErrorRanges || [];\n                this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\n                    new ErrorRangeCalculator(errorBars.value, series, VALUE);\n\n                errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n            }\n\n            if (errorRange) {\n                point.low = errorRange.low;\n                point.high = errorRange.high;\n                this.addPointErrorBar(point, categoryIx);\n            }\n        },\n\n        addPointErrorBar: function(point, categoryIx) {\n            var isVertical = !this.options.invertAxes;\n            var options = point.options.errorBars;\n            var series = point.series;\n            var low = point.low;\n            var high = point.high;\n\n            if (this.options.isStacked) {\n                var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n                low = stackedErrorRange.low;\n                high = stackedErrorRange.high;\n            } else {\n                var fields = { categoryIx: categoryIx, series: series };\n                this.updateRange({ value: low }, fields);\n                this.updateRange({ value: high }, fields);\n            }\n\n            var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n            point.errorBars = [ errorBar ];\n            point.append(errorBar);\n        },\n\n        stackedErrorRange: function(point, categoryIx) {\n            var plotValue = this.plotRange(point, 0)[1] - point.value;\n            var low = point.low + plotValue;\n            var high = point.high + plotValue;\n\n            this.errorTotals = this.errorTotals || { positive: [], negative: [] };\n\n            if (low < 0) {\n                this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n            }\n\n            if (high > 0) {\n                this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n            }\n\n            return { low: low, high: high };\n        },\n\n        addValue: function(data, fields) {\n            var categoryIx = fields.categoryIx;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n\n            var categoryPoints = this.categoryPoints[categoryIx];\n            if (!categoryPoints) {\n                this.categoryPoints[categoryIx] = categoryPoints = [];\n            }\n\n            var seriesPoints = this.seriesPoints[seriesIx];\n            if (!seriesPoints) {\n                this.seriesPoints[seriesIx] = seriesPoints = [];\n            }\n\n            var point = this.createPoint(data, fields);\n            if (point) {\n                $.extend(point, fields);\n\n                point.owner = this;\n                point.noteText = data.fields.noteText;\n                if (!defined(point.dataItem)) {\n                    point.dataItem = series.data[categoryIx];\n                }\n                this.addErrorBar(point, data, categoryIx);\n            }\n\n            this.points.push(point);\n            seriesPoints.push(point);\n            categoryPoints.push(point);\n\n            this.updateRange(data.valueFields, fields);\n        },\n\n        evalPointOptions: function(options, value, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var state = {\n                defaults: series._defaults,\n                excluded: [\n                    \"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\",\n                    \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\",\n                    \"drilldownSeriesFactory\", \"ariaTemplate\", \"ariaContent\"\n                ]\n            };\n\n            var doEval = this._evalSeries[seriesIx];\n            if (!defined(doEval)) {\n                this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n            }\n\n            var pointOptions = options;\n            if (doEval) {\n                pointOptions = deepExtend({}, pointOptions);\n                evalOptions(pointOptions, {\n                    value: value,\n                    category: category,\n                    index: categoryIx,\n                    series: series,\n                    dataItem: series.data[categoryIx]\n                }, state);\n            }\n\n            return pointOptions;\n        },\n\n        updateRange: function(data, fields) {\n            var axisName = fields.series.axis;\n            var value = data.value;\n            var axisRange = this.valueAxisRanges[axisName];\n\n            if (isFinite(value) && value !== null) {\n                axisRange = this.valueAxisRanges[axisName] =\n                    axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n                axisRange.min = Math.min(axisRange.min, value);\n                axisRange.max = Math.max(axisRange.max, value);\n            }\n        },\n\n        seriesValueAxis: function(series) {\n            var plotArea = this.plotArea;\n            var axisName = series.axis;\n            var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n            if (!axis) {\n                throw new Error(\"Unable to locate value axis with name \" + axisName);\n            }\n\n            return axis;\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var categorySlots = this.categorySlots = [];\n            var chartPoints = this.points;\n            var categoryAxis = this.categoryAxis;\n            var pointIx = 0;\n\n            this.traverseDataPoints(function (data, fields) {\n                var categoryIx = fields.categoryIx;\n                var currentSeries = fields.series;\n\n                var valueAxis = this$1$1.seriesValueAxis(currentSeries);\n                var point = chartPoints[pointIx++];\n\n                var categorySlot = categorySlots[categoryIx];\n                if (!categorySlot) {\n                    categorySlots[categoryIx] = categorySlot =\n                        this$1$1.categorySlot(categoryAxis, categoryIx, valueAxis);\n                }\n\n                if (point) {\n                    var plotRange = this$1$1.plotRange(point, valueAxis.startValue());\n                    var valueSlot = this$1$1.valueSlot(valueAxis, plotRange);\n                    if (valueSlot) {\n                        var pointSlot = this$1$1.pointSlot(categorySlot, valueSlot);\n\n                        point.aboveAxis = this$1$1.aboveAxis(point, valueAxis);\n                        point.stackValue = plotRange[1];\n\n                        if (this$1$1.options.isStacked100) {\n                            point.percentage = this$1$1.plotValue(point);\n                        }\n\n                        this$1$1.reflowPoint(point, pointSlot);\n                    } else {\n                        point.visible = false;\n                    }\n                }\n            });\n\n            this.reflowCategories(categorySlots);\n            if (!this.options.clip && this.options.limitPoints && this.points.length) {\n                this.limitPoints();\n            }\n\n            this.box = targetBox;\n        },\n\n        valueSlot: function(valueAxis, plotRange) {\n            return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n        },\n\n        limitPoints: function() {\n            var this$1$1 = this;\n\n            var categoryPoints = this.categoryPoints;\n            var points = categoryPoints[0].concat(last(categoryPoints));\n            for (var idx = 0; idx < points.length; idx++) {\n                if (points[idx]) {\n                    this$1$1.limitPoint(points[idx]);\n                }\n            }\n        },\n\n        limitPoint: function(point) {\n            var limitedSlot = this.categoryAxis.limitSlot(point.box);\n            if (!limitedSlot.equals(point.box)) {\n                point.reflow(limitedSlot);\n            }\n        },\n\n        aboveAxis: function(point, valueAxis) {\n            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n            var value = point.value;\n\n            return valueAxis.options.reverse ?\n                value < axisCrossingValue : value >= axisCrossingValue;\n        },\n\n        categoryAxisCrossingValue: function(valueAxis) {\n            var categoryAxis = this.categoryAxis;\n            var options = valueAxis.options;\n            var crossingValues = [].concat(\n                options.axisCrossingValues || options.axisCrossingValue\n            );\n\n            return crossingValues[categoryAxis.axisIndex || 0] || 0;\n        },\n\n        reflowPoint: function(point, pointSlot) {\n            point.reflow(pointSlot);\n        },\n\n        reflowCategories: function() { },\n\n        pointSlot: function(categorySlot, valueSlot) {\n            var options = this.options;\n            var invertAxes = options.invertAxes;\n            var slotX = invertAxes ? valueSlot : categorySlot;\n            var slotY = invertAxes ? categorySlot : valueSlot;\n\n            return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n        },\n\n        categorySlot: function(categoryAxis, categoryIx) {\n            return categoryAxis.getSlot(categoryIx);\n        },\n\n        traverseDataPoints: function(callback) {\n            var this$1$1 = this;\n\n            var series = this.options.series;\n            var count = categoriesCount(series);\n            var seriesCount = series.length;\n\n            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n                this$1$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n            }\n\n            for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n                for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\n                    var currentSeries = series[seriesIx$1];\n                    var currentCategory = this$1$1.categoryAxis.categoryAt(categoryIx);\n                    var pointData = this$1$1.plotArea.bindPoint(currentSeries, categoryIx);\n\n                    callback(pointData, {\n                        category: currentCategory,\n                        categoryIx: categoryIx,\n                        categoriesCount: count,\n                        series: currentSeries,\n                        seriesIx: seriesIx$1\n                    });\n                }\n            }\n\n            for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\n                this$1$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\n            }\n        },\n\n        _outOfRangeCallback: function(series, field, seriesIx, callback) {\n            var outOfRangePoint = series[field];\n            if (outOfRangePoint) {\n                var categoryIx = outOfRangePoint.categoryIx;\n                var pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);\n\n                callback(pointData, {\n                    category: outOfRangePoint.category,\n                    categoryIx: categoryIx,\n                    series: series,\n                    seriesIx: seriesIx,\n                    dataItem: outOfRangePoint.item\n                });\n            }\n        },\n\n        formatPointValue: function(point, format) {\n            if (point.value === null) {\n                return \"\";\n            }\n\n            return this.chartService.format.auto(format, point.value);\n        },\n\n        pointValue: function(data) {\n            return data.valueFields.value;\n        }\n    });\n\n    setDefaultOptions(CategoricalChart, {\n        series: [],\n        invertAxes: false,\n        isStacked: false,\n        clip: true,\n        limitPoints: true\n    });\n\n    var PointEventsMixin = {\n        click: function(chart, e) {\n            return chart.trigger(\n                SERIES_CLICK,\n                this.eventArgs(e)\n            );\n        },\n\n        hover: function(chart, e) {\n            return chart.trigger(\n                SERIES_HOVER,\n                this.eventArgs(e)\n            );\n        },\n\n        over: function(chart, e) {\n            return chart.trigger(\n                SERIES_OVER,\n                this.eventArgs(e)\n            );\n        },\n\n        out: function(chart, e) {\n            return chart.trigger(\n                SERIES_LEAVE,\n                this.eventArgs(e)\n            );\n        },\n\n        eventArgs: function(e) {\n            return {\n                value: this.value,\n                percentage: this.percentage,\n                stackValue: this.stackValue,\n                category: this.category,\n                series: this.series,\n                dataItem: this.dataItem,\n                runningTotal: this.runningTotal,\n                total: this.total,\n                element: eventElement(e),\n                originalEvent: e,\n                point: this\n            };\n        }\n    };\n\n    var NoteMixin = {\n        createNote: function() {\n            var options = this.options.notes;\n            var text = this.noteText || options.label.text;\n\n            if (options.visible !== false && defined(text) && text !== null) {\n                this.note = new dataviz.Note({\n                    value: this.value,\n                    text: text,\n                    dataItem: this.dataItem,\n                    category: this.category,\n                    series: this.series\n                }, this.options.notes, this.owner.chartService);\n\n                this.append(this.note);\n            }\n        }\n    };\n\n    function guid() {\n        var id = \"\";\n        var i;\n        var random;\n\n        for (i = 0; i < 32; i++) {\n            random = Math.random() * 16 | 0;\n\n            if (i === 8 || i === 12 || i === 16 || i === 20) {\n                id += \"-\";\n            }\n\n            id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16); // eslint-disable-line no-nested-ternary\n        }\n\n        return id;\n    }\n\n    var LinePoint = ChartElement.extend({\n        init: function(value, options) {\n            ChartElement.fn.init.call(this);\n\n            this.value = value;\n            this.options = options;\n            this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n            this.tooltipTracking = true;\n            this._id = guid();\n        },\n\n        render: function() {\n            var ref = this.options;\n            var markers = ref.markers;\n\n            if (this._rendered) {\n                return;\n            }\n\n            this._rendered = true;\n\n            if (markers.visible && markers.size) {\n                this.marker = this.createMarker();\n                this.append(this.marker);\n            }\n\n            this.createLabel();\n            this.createNote();\n\n            if (this.errorBar) {\n                this.append(this.errorBar);\n            }\n        },\n\n        createLabel: function() {\n            var options = this.options;\n            var labels = options.labels;\n\n            if (labels.visible) {\n                this.label = this.createLabelElement(labels);\n                this.append(this.label);\n            }\n        },\n\n        createLabelElement: function(options) {\n            return new TextBox(this.getLabelText(options),\n                deepExtend({\n                    align: CENTER,\n                    vAlign: CENTER,\n                    margin: {\n                        left: 5,\n                        right: 5\n                    },\n                    zIndex: valueOrDefault(options.zIndex, this.series.zIndex)\n                }, options),\n                this.pointData()\n            );\n        },\n\n        getLabelText: function(options) {\n            var labelTemplate = getTemplate(options);\n\n            if (labelTemplate) {\n                return labelTemplate(this.pointData());\n            } else if (options.format) {\n                return this.formatValue(options.format);\n            }\n\n            return this.value;\n        },\n\n        getAriaLabelText: function() {\n            var labels = this.options.labels;\n            var ariaTemplate = dataviz.getAriaTemplate(labels);\n\n            if (ariaTemplate) {\n                return ariaTemplate(this.pointData());\n            }\n\n            return this.getLabelText(labels);\n        },\n\n        markerBorder: function() {\n            var options = this.options.markers;\n            var background = options.background;\n            var border = deepExtend({ color: this.color }, options.border);\n\n            if (!defined(border.color)) {\n                border.color = new Color(background).brightness(BORDER_BRIGHTNESS).toHex();\n            }\n\n            return border;\n        },\n\n        createVisual: function() {},\n\n        createMarker: function() {\n            var options = this.options.markers;\n            var marker = new ShapeElement({\n                type: options.type,\n                width: options.size,\n                height: options.size,\n                rotation: options.rotation,\n                background: options.background,\n                border: this.markerBorder(),\n                opacity: options.opacity,\n                zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n                animation: options.animation,\n                visual: options.visual,\n                accessibilityOptions: deepExtend({\n                    ariaLabel: this.getAriaLabelText(this.options.labels)\n                }, this.options.accessibility)\n            }, {\n                dataItem: this.dataItem,\n                value: this.value,\n                series: this.series,\n                category: this.category\n            });\n\n            return marker;\n        },\n\n        markerBox: function() {\n            if (!this.marker) {\n                this.marker = this.createMarker();\n                this.marker.reflow(this._childBox);\n            }\n\n            return this.marker.box;\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var aboveAxis = ref.aboveAxis;\n            var vertical = options.vertical;\n\n            this.render();\n\n            this.box = targetBox;\n            var childBox = targetBox.clone();\n\n            if (vertical) {\n                if (aboveAxis) {\n                    childBox.y1 -= childBox.height();\n                } else {\n                    childBox.y2 += childBox.height();\n                }\n            } else {\n                if (aboveAxis) {\n                    childBox.x1 += childBox.width();\n                } else {\n                    childBox.x2 -= childBox.width();\n                }\n            }\n\n            this._childBox = childBox;\n            if (this.marker) {\n                this.marker.reflow(childBox);\n            }\n\n            this.reflowLabel(childBox);\n\n            if (this.errorBars) {\n                for (var i = 0; i < this.errorBars.length; i++) {\n                    this$1$1.errorBars[i].reflow(childBox);\n                }\n            }\n\n            if (this.note) {\n                var noteTargetBox = this.markerBox();\n\n                if (!(options.markers.visible && options.markers.size)) {\n                    var center = noteTargetBox.center();\n                    noteTargetBox = new Box(center.x, center.y, center.x, center.y);\n                }\n\n                this.note.reflow(noteTargetBox);\n            }\n        },\n\n        reflowLabel: function(box) {\n            var ref = this;\n            var options = ref.options;\n            var label = ref.label;\n            var anchor = options.labels.position;\n\n            if (label) {\n                anchor = anchor === ABOVE ? TOP : anchor;\n                anchor = anchor === BELOW ? BOTTOM : anchor;\n\n                label.reflow(box);\n                label.box.alignTo(this.markerBox(), anchor);\n                label.reflow(label.box);\n            }\n        },\n\n        createHighlight: function() {\n            var markers = this.options.highlight.markers;\n            var defaultColor = this.markerBorder().color;\n            var options = this.options.markers;\n            var size = options.size + (options.border.width || 0) + (markers.border.width || 0);\n\n            var shadow = new ShapeElement({\n                type: options.type,\n                width: size,\n                height: size,\n                rotation: options.rotation,\n                background: markers.color || defaultColor,\n                border: {\n                    color: markers.border.color,\n                    width: markers.border.width,\n                    opacity: valueOrDefault(markers.border.opacity, 1)\n                },\n                opacity: valueOrDefault(markers.opacity, 1)\n            });\n            shadow.reflow(this._childBox);\n\n            return shadow.getElement();\n        },\n\n        highlightVisual: function() {\n            return (this.marker || {}).visual;\n        },\n\n        highlightVisualArgs: function() {\n            var marker = this.marker;\n            var visual, rect;\n\n            if (marker) {\n                rect = marker.paddingBox.toRect();\n                visual = marker.visual;\n            } else {\n                var size = this.options.markers.size;\n                var halfSize = size / 2;\n                var center = this.box.center();\n                rect = new geometry.Rect([ center.x - halfSize, center.y - halfSize ], [ size, size ]);\n            }\n\n            return {\n                options: this.options,\n                rect: rect,\n                visual: visual\n            };\n        },\n\n        createFocusHighlight: function() {\n            var markerOptions = this.options.markers;\n            var highlightOptions = this.options.accessibility.highlight;\n            var size = markerOptions.size + (markerOptions.border.width || 0);\n\n            var highlight = new ShapeElement({\n                type: markerOptions.type,\n                width: size,\n                height: size,\n                rotation: markerOptions.rotation,\n                background: highlightOptions.color,\n                border: highlightOptions.border,\n                opacity: highlightOptions.opacity,\n                padding: highlightOptions.border.width / 2,\n                zIndex: highlightOptions.zIndex\n            });\n\n            highlight.reflow(this._childBox);\n\n            return highlight.getElement();\n        },\n\n        tooltipAnchor: function() {\n            var markerBox = this.markerBox();\n            var clipBox = this.owner.pane.clipBox();\n            var showTooltip = !clipBox || clipBox.overlaps(markerBox);\n\n            if (showTooltip) {\n                var x = markerBox.x2 + TOOLTIP_OFFSET;\n                var horizontalAlign = LEFT;\n                var y, verticalAlign;\n\n                if (this.aboveAxis) {\n                    y = markerBox.y1;\n                    verticalAlign = BOTTOM;\n                } else {\n                    y = markerBox.y2;\n                    verticalAlign = TOP;\n                }\n\n                return {\n                    point: new Point(x, y),\n                    align: {\n                        horizontal: horizontalAlign,\n                        vertical: verticalAlign\n                    }\n                };\n            }\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        overlapsBox: function(box) {\n            var markerBox = this.markerBox();\n            return markerBox.overlaps(box);\n        },\n\n        unclipElements: function() {\n            if (this.label) {\n                this.label.options.noclip = true;\n            }\n\n            if (this.note) {\n                this.note.options.noclip = true;\n            }\n        },\n\n        pointData: function() {\n            return {\n                dataItem: this.dataItem,\n                category: this.category,\n                value: this.value,\n                percentage: this.percentage,\n                stackValue: this.stackValue,\n                series: this.series\n            };\n        },\n\n        focusVisual: function() {\n            if (this.marker) {\n                if (this.marker.visual) {\n                    this.marker.visual.options.set(\"id\", this._id);\n                }\n\n                this.toggleFocusHighlight(true);\n            }\n        },\n\n        clearFocusFromVisual: function() {\n            if (this.marker) {\n                if (this.marker.visual) {\n                    this.marker.visual.options.set(\"id\", \"\");\n                }\n\n                this.toggleFocusHighlight(false);\n            }\n        },\n\n        getIndex: function() {\n            return defined(this.categoryIx) ? this.categoryIx : this.pointIx;\n        }\n    });\n\n    LinePoint.prototype.defaults = {\n        vertical: true,\n        markers: {\n            visible: true,\n            background: WHITE,\n            size: LINE_MARKER_SIZE,\n            type: CIRCLE,\n            border: {\n                width: 2\n            },\n            opacity: 1\n        },\n        labels: {\n            visible: false,\n            position: ABOVE,\n            margin: getSpacing(3),\n            padding: getSpacing(4),\n            animation: {\n                type: FADEIN,\n                delay: INITIAL_ANIMATION_DURATION\n            }\n        },\n        notes: {\n            label: {}\n        },\n        highlight: {\n            markers: {\n                border: {\n                    color: \"#fff\",\n                    width: 2\n                }\n            },\n            zIndex: datavizConstants.HIGHLIGHT_ZINDEX\n        },\n        errorBars: {\n            line: {\n                width: 1\n            }\n        },\n        accessibility: {\n            tabIndex: 0,\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    };\n\n    deepExtend(LinePoint.prototype, PointEventsMixin);\n    deepExtend(LinePoint.prototype, NoteMixin);\n\n    var LineSegment = ChartElement.extend({\n        init: function(linePoints, series, seriesIx) {\n            ChartElement.fn.init.call(this);\n\n            this.linePoints = linePoints;\n            this.series = series;\n            this.seriesIx = seriesIx;\n        },\n\n        points: function() {\n            return this.toGeometryPoints(this.linePoints);\n        },\n\n        toGeometryPoints: function(points) {\n            var result = [];\n            for (var i = 0, length = points.length; i < length; i++) {\n                if (points[i] && points[i].visible !== false) {\n                    result.push(points[i]._childBox.toRect().center());\n                }\n            }\n\n            return result;\n        },\n\n        createVisual: function() {\n            var this$1$1 = this;\n\n            var customVisual = this.series.visual;\n            if (customVisual) {\n                this.visual = customVisual({\n                    points: this.toGeometryPoints(this.linePoints),\n                    series: this.series,\n                    sender: this.getSender(),\n                    createVisual: function () {\n                        this$1$1.segmentVisual();\n\n                        return this$1$1.visual;\n                    }\n                });\n                if (this.visual && !defined(this.visual.options.zIndex)) {\n                    this.visual.options.zIndex = this.series.zIndex;\n                }\n            } else {\n                this.segmentVisual();\n            }\n        },\n\n        segmentVisual: function() {\n            var ref = this;\n            var options = ref.options;\n            var series = ref.series;\n            var color = series.color;\n            var defaults = series._defaults;\n\n            if (isFunction(color) && defaults) {\n                color = defaults.color;\n            }\n\n            var line = Path.fromPoints(this.points(), {\n                stroke: {\n                    color: color,\n                    width: series.width,\n                    opacity: series.opacity,\n                    dashType: series.dashType\n                },\n                zIndex: series.zIndex\n            });\n\n            if (options.closed) {\n                line.close();\n            }\n\n            this.visual = line;\n        },\n\n        aliasFor: function(e, coords) {\n            return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\n        }\n    });\n\n    setDefaultOptions(LineSegment, {\n        closed: false\n    });\n\n    var StepLineMixin = {\n        calculateStepPoints: function(points) {\n            var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);\n            var ref = categoryAxis.options;\n            var justified = ref.justified;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n\n            var stepAxis = vertical ? X : Y;\n            var axis = vertical ? Y : X;\n            var stepDir = reverse ? 2 : 1;\n            var dir = stepDir;\n\n            var previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);\n            var result = [ previousPoint ];\n\n            for (var idx = 1; idx < points.length; idx++) {\n                var point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);\n\n                if (previousPoint[stepAxis] !== point[stepAxis]) {\n                    var stepPoint = new GeometryPoint();\n                    stepPoint[stepAxis] = previousPoint[stepAxis];\n                    stepPoint[axis] = point[axis];\n\n                    result.push(stepPoint, point);\n                }\n\n                previousPoint = point;\n            }\n\n            if (!justified) {\n                result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));\n            } else if (previousPoint !== last(result)) {\n                result.push(previousPoint);\n            }\n\n            return result;\n\n        }\n    };\n\n    function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {\n        var box = lintPoint.box;\n        var result = new GeometryPoint();\n\n        result[stepAxis] = box[stepAxis + stepDir];\n        result[axis] = box[axis + dir];\n\n        return result;\n    }\n\n    var StepLineSegment = LineSegment.extend({\n        points: function() {\n            return this.calculateStepPoints(this.linePoints);\n        }\n    });\n\n    deepExtend(StepLineSegment.prototype, StepLineMixin);\n\n    var SplineSegment = LineSegment.extend({\n        segmentVisual: function() {\n            var series = this.series;\n            var defaults = series._defaults;\n            var color = series.color;\n\n            if (isFunction(color) && defaults) {\n                color = defaults.color;\n            }\n\n            var curveProcessor = new CurveProcessor(this.options.closed);\n            var segments = curveProcessor.process(this.points());\n            var curve = new Path({\n                stroke: {\n                    color: color,\n                    width: series.width,\n                    opacity: series.opacity,\n                    dashType: series.dashType\n                },\n                zIndex: series.zIndex\n            });\n\n            curve.segments.push.apply(curve.segments, segments);\n\n            this.visual = curve;\n        }\n    });\n\n    var LineChartMixin = {\n        renderSegments: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var seriesPoints = ref.seriesPoints;\n            var series = options.series;\n            var seriesCount = seriesPoints.length;\n            var lastSegment;\n\n            this._segments = [];\n\n            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var sortedPoints = this$1$1.sortPoints(seriesPoints[seriesIx]);\n                var pointCount = sortedPoints.length;\n                var linePoints = [];\n\n                for (var pointIx = 0; pointIx < pointCount; pointIx++) {\n                    var point = sortedPoints[pointIx];\n                    if (point) {\n                        linePoints.push(point);\n                    } else if (this$1$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {\n                        if (linePoints.length > 1) {\n                            lastSegment = this$1$1.createSegment(\n                                linePoints, currentSeries, seriesIx, lastSegment\n                            );\n                            this$1$1._addSegment(lastSegment);\n                        }\n                        linePoints = [];\n                    }\n                }\n\n                if (linePoints.length > 1) {\n                    lastSegment = this$1$1.createSegment(\n                        linePoints, currentSeries, seriesIx, lastSegment\n                    );\n                    this$1$1._addSegment(lastSegment);\n                }\n            }\n\n            this.children.unshift.apply(this.children, this._segments);\n        },\n\n        _addSegment: function(segment) {\n            this._segments.push(segment);\n            segment.parent = this;\n        },\n\n        sortPoints: function(points) {\n            return points;\n        },\n\n        seriesMissingValues: function(series) {\n            var missingValues = series.missingValues;\n            var assumeZero = !missingValues && this.options.isStacked;\n\n            return assumeZero ? ZERO : missingValues || INTERPOLATE;\n        },\n\n        getNearestPoint: function(x, y, seriesIx) {\n            var target = new Point(x, y);\n            var allPoints = this.seriesPoints[seriesIx];\n            var nearestPointDistance = MAX_VALUE;\n            var nearestPoint;\n\n            for (var i = 0; i < allPoints.length; i++) {\n                var point = allPoints[i];\n\n                if (point && defined(point.value) && point.value !== null && point.visible !== false) {\n                    var pointBox = point.box;\n                    var pointDistance = pointBox.center().distanceTo(target);\n\n                    if (pointDistance < nearestPointDistance) {\n                        nearestPoint = point;\n                        nearestPointDistance = pointDistance;\n                    }\n                }\n            }\n\n            return nearestPoint;\n        }\n    };\n\n    var ClipAnimation = Animation.extend({\n        setup: function() {\n            this._setEnd(this.options.box.x1);\n        },\n\n        step: function(pos) {\n            var box = this.options.box;\n            this._setEnd(dataviz.interpolateValue(box.x1, box.x2, pos));\n        },\n\n        _setEnd: function(x) {\n            var element = this.element;\n            var segments = element.segments;\n            var topRight = segments[1].anchor();\n            var bottomRight = segments[2].anchor();\n\n            element.suspend();\n            topRight.setX(x);\n            element.resume();\n            bottomRight.setX(x);\n        }\n    });\n\n    setDefaultOptions(ClipAnimation, {\n        duration: INITIAL_ANIMATION_DURATION\n    });\n\n    AnimationFactory.current.register(\"clip\", ClipAnimation);\n\n    var ClipAnimationMixin = {\n        createAnimation: function() {\n            var root = this.getRoot();\n            if (root && (root.options || {}).transitions !== false) {\n                var box = root.size();\n                var clipPath = Path.fromRect(box.toRect());\n                this.visual.clip(clipPath);\n                this.animation = new ClipAnimation(clipPath, {\n                    box: box\n                });\n                if (anyHasZIndex(this.options.series)) {\n                    this._setChildrenAnimation(clipPath);\n                }\n            }\n        },\n\n        _setChildrenAnimation: function(clipPath) {\n            var points = this.animationPoints();\n\n            for (var idx = 0; idx < points.length; idx++) {\n                var point = points[idx];\n                if (point && point.visual && defined(point.visual.options.zIndex)) {\n                    point.visual.clip(clipPath);\n                }\n            }\n        }\n    };\n\n    var LineChart = CategoricalChart.extend({\n        render: function() {\n\n            CategoricalChart.fn.render.call(this);\n\n            this.updateStackRange();\n            this.renderSegments();\n        },\n\n        pointType: function() {\n            return LinePoint;\n        },\n\n        createPoint: function(data, fields) {\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var missingValues = this.seriesMissingValues(series);\n            var value = data.valueFields.value;\n\n            if (!defined(value) || value === null) {\n                if (missingValues === ZERO) {\n                    value = 0;\n                } else {\n                    return null;\n                }\n            }\n\n            var pointOptions = this.pointOptions(series, seriesIx);\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            var color = data.fields.color || series.color;\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n\n            var point = new LinePoint(value, pointOptions);\n            point.color = color;\n\n            this.append(point);\n\n            return point;\n        },\n\n        plotRange: function(point) {\n            var this$1$1 = this;\n\n            var plotValue = this.plotValue(point);\n\n            if (this.options.isStacked) {\n                var categoryIx = point.categoryIx;\n                var categoryPoints = this.categoryPoints[categoryIx];\n\n                for (var i = 0; i < categoryPoints.length; i++) {\n                    var other = categoryPoints[i];\n\n                    if (point === other) {\n                        break;\n                    }\n\n                    plotValue += this$1$1.plotValue(other);\n\n                    if (this$1$1.options.isStacked100) {\n                        plotValue = Math.min(plotValue, 1);\n                    }\n                }\n\n            }\n\n            return [ plotValue, plotValue ];\n        },\n\n        createSegment: function(linePoints, currentSeries, seriesIx) {\n            var style = currentSeries.style;\n            var pointType;\n\n            if (style === STEP) {\n                pointType = StepLineSegment;\n            } else if (style === SMOOTH) {\n                pointType = SplineSegment;\n            } else {\n                pointType = LineSegment;\n            }\n\n            return new pointType(linePoints, currentSeries, seriesIx);\n        },\n\n        animationPoints: function() {\n            var points = this.points;\n            var result = [];\n            for (var idx = 0; idx < points.length; idx++) {\n                result.push((points[idx] || {}).marker);\n            }\n            return result.concat(this._segments);\n        },\n\n        supportsPointInactiveOpacity: function() {\n            return false;\n        }\n    });\n\n    deepExtend(LineChart.prototype, LineChartMixin, ClipAnimationMixin);\n\n    var AreaSegment = LineSegment.extend({\n        init: function(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\n            LineSegment.fn.init.call(this, linePoints, currentSeries, seriesIx);\n\n            this.prevSegment = prevSegment;\n            this.stackPoints = stackPoints;\n        },\n\n        createVisual: function() {\n            var series = this.series;\n            var defaults = series._defaults;\n            var lineOptions = series.line || {};\n            var color = series.color;\n\n            if (isFunction(color) && defaults) {\n                color = defaults.color;\n            }\n\n            this.visual = new Group({\n                zIndex: series.zIndex\n            });\n\n            this.createFill({\n                fill: {\n                    color: color,\n                    opacity: series.opacity\n                },\n                stroke: null\n            });\n\n            if (lineOptions.width > 0 && lineOptions.visible !== false) {\n                this.createStroke({\n                    stroke: deepExtend({\n                        color: color,\n                        opacity: series.opacity,\n                        lineCap: \"butt\"\n                    }, lineOptions)\n                });\n            }\n        },\n\n        strokeSegments: function() {\n            var segments = this._strokeSegments;\n\n            if (!segments) {\n                segments = this._strokeSegments = this.createStrokeSegments();\n            }\n\n            return segments;\n        },\n\n        createStrokeSegments: function() {\n            return this.segmentsFromPoints(this.points());\n        },\n\n        stackSegments: function() {\n            if (this.prevSegment) {\n                return this.prevSegment.createStackSegments(this.stackPoints);\n            }\n\n            return this.createStackSegments(this.stackPoints);\n        },\n\n        createStackSegments: function(stackPoints) {\n            return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\n        },\n\n        segmentsFromPoints: function(points) {\n            return points.map(function (point) { return new geometry.Segment(point); });\n        },\n\n        createStroke: function(style) {\n            var stroke = new Path(style);\n            stroke.segments.push.apply(stroke.segments, this.strokeSegments());\n\n            this.visual.append(stroke);\n        },\n\n        hasStackSegment: function() {\n            return this.prevSegment || (this.stackPoints && this.stackPoints.length);\n        },\n\n        createFill: function(style) {\n            var strokeSegments = this.strokeSegments();\n            var fillSegments = strokeSegments.slice(0);\n            var hasStackSegments = this.hasStackSegment();\n\n            if (hasStackSegments) {\n                var stackSegments = this.stackSegments();\n\n                append(fillSegments, stackSegments);\n            }\n\n            var fill = new Path(style);\n            fill.segments.push.apply(fill.segments, fillSegments);\n\n            if (!hasStackSegments && strokeSegments.length > 1) {\n                this.fillToAxes(fill);\n            }\n\n            this.visual.append(fill);\n        },\n\n        fillToAxes: function(fillPath) {\n            var chart = this.parent;\n            var invertAxes = chart.options.invertAxes;\n            var valueAxis = chart.seriesValueAxis(this.series);\n            var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\n            var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\n            var segments = this.strokeSegments();\n            var firstPoint = segments[0].anchor();\n            var lastPoint = last(segments).anchor();\n            var end = invertAxes ? endSlot.x1 : endSlot.y1;\n\n            if (invertAxes) {\n                fillPath.lineTo(end, lastPoint.y)\n                    .lineTo(end, firstPoint.y);\n            } else {\n                fillPath.lineTo(lastPoint.x, end)\n                    .lineTo(firstPoint.x, end);\n            }\n        }\n    });\n\n    var StepAreaSegment = AreaSegment.extend({\n        createStrokeSegments: function() {\n            return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));\n        },\n\n        createStackSegments: function(stackPoints) {\n            return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();\n        }\n    });\n\n    deepExtend(StepAreaSegment.prototype, StepLineMixin);\n\n    var SplineAreaSegment = AreaSegment.extend({\n        createStrokeSegments: function() {\n            var curveProcessor = new CurveProcessor(this.options.closed);\n            var linePoints = this.points();\n\n            return curveProcessor.process(linePoints);\n        },\n\n        createStackSegments: function() {\n            var strokeSegments = this.strokeSegments();\n            var stackSegments = [];\n            for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {\n                var segment = strokeSegments[idx];\n                stackSegments.push(new geometry.Segment(\n                    segment.anchor(),\n                    segment.controlOut(),\n                    segment.controlIn()\n                ));\n            }\n\n            return stackSegments;\n        }\n    });\n\n    var AreaChart = LineChart.extend({\n        createSegment: function(linePoints, currentSeries, seriesIx, prevSegment) {\n            var isStacked = this.options.isStacked;\n            var style = (currentSeries.line || {}).style;\n            var previousSegment;\n\n            var stackPoints;\n            if (isStacked && seriesIx > 0 && prevSegment) {\n                var missingValues = this.seriesMissingValues(currentSeries);\n                if (missingValues !== \"gap\") {\n                    stackPoints = prevSegment.linePoints;\n                    previousSegment = prevSegment;\n                } else {\n                    stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n                }\n            }\n\n            var pointType;\n            if (style === STEP) {\n                pointType = StepAreaSegment;\n            } else if (style === SMOOTH) {\n                pointType = SplineAreaSegment;\n            } else {\n                pointType = AreaSegment;\n            }\n\n            return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            LineChart.fn.reflow.call(this, targetBox);\n\n            var stackPoints = this._stackPoints;\n            if (stackPoints) {\n                for (var idx = 0; idx < stackPoints.length; idx++) {\n                    var stackPoint = stackPoints[idx];\n                    var pointSlot = this$1$1.categoryAxis.getSlot(stackPoint.categoryIx);\n                    stackPoint.reflow(pointSlot);\n                }\n            }\n        },\n\n        _gapStackPoints: function(linePoints, seriesIx, style) {\n            var this$1$1 = this;\n\n            var seriesPoints = this.seriesPoints;\n            var startIdx = linePoints[0].categoryIx;\n            var length = linePoints.length;\n            if (startIdx < 0) {\n                startIdx = 0;\n                length--;\n            }\n\n            var endIdx = startIdx + length;\n            var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n            var stackPoints = [];\n\n            this._stackPoints = this._stackPoints || [];\n            for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n                var pointIx = categoryIx + pointOffset;\n                var currentSeriesIx = seriesIx;\n                var point = (void 0);\n\n                do {\n                    currentSeriesIx--;\n                    point = seriesPoints[currentSeriesIx][pointIx];\n                } while (currentSeriesIx > 0 && !point);\n\n                if (point) {\n                    if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n                        stackPoints.push(this$1$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n                    }\n\n                    stackPoints.push(point);\n\n                    if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n                        stackPoints.push(this$1$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n                    }\n                } else {\n                    var gapStackPoint = this$1$1._createGapStackPoint(categoryIx);\n                    this$1$1._stackPoints.push(gapStackPoint);\n                    stackPoints.push(gapStackPoint);\n                }\n            }\n\n            return stackPoints;\n        },\n\n        _previousSegmentPoint: function(categoryIx, pointIx, segmentIx, seriesIdx) {\n            var seriesPoints = this.seriesPoints;\n            var index = seriesIdx;\n            var point;\n\n            while (index > 0 && !point) {\n                index--;\n                point = seriesPoints[index][segmentIx];\n            }\n\n            if (!point) {\n                point = this._createGapStackPoint(categoryIx);\n                this._stackPoints.push(point);\n            } else {\n                point = seriesPoints[index][pointIx];\n            }\n\n            return point;\n        },\n\n        _createGapStackPoint: function(categoryIx) {\n            var options = this.pointOptions({}, 0);\n            var point = new LinePoint(0, options);\n            point.categoryIx = categoryIx;\n            point.series = {};\n\n            return point;\n        },\n\n        seriesMissingValues: function(series) {\n            return series.missingValues || ZERO;\n        },\n\n        supportsPointInactiveOpacity: function() {\n            return false;\n        }\n    });\n\n    var AxisGroupRangeTracker = Class.extend({\n        init: function() {\n\n            this.axisRanges = {};\n        },\n\n        update: function(chartAxisRanges) {\n            var axisRanges = this.axisRanges;\n\n            for (var axisName in chartAxisRanges) {\n                var chartRange = chartAxisRanges[axisName];\n                var range = axisRanges[axisName];\n                axisRanges[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };\n\n                range.min = Math.min(range.min, chartRange.min);\n                range.max = Math.max(range.max, chartRange.max);\n            }\n        },\n\n        reset: function(axisName) {\n            this.axisRanges[axisName] = undefined;\n        },\n\n        query: function(axisName) {\n            return this.axisRanges[axisName];\n        }\n    });\n\n    var BarLabel = ChartElement.extend({\n        init: function(content, options, pointData) {\n            ChartElement.fn.init.call(this, options);\n\n            this.textBox = new TextBox(content, this.options, pointData);\n            this.append(this.textBox);\n        },\n\n        createVisual: function() {\n            this.textBox.options.noclip = this.options.noclip;\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options;\n            var vertical = options.vertical;\n            var aboveAxis = options.aboveAxis;\n            var text = this.children[0];\n            var textOptions = text.options;\n            var box = text.box;\n            var padding = text.options.padding;\n            var labelBox = targetBox;\n\n            textOptions.align = vertical ? CENTER : LEFT;\n            textOptions.vAlign = vertical ? TOP : CENTER;\n\n            if (options.position === INSIDE_END) {\n                if (vertical) {\n                    textOptions.vAlign = TOP;\n\n                    if (!aboveAxis && box.height() < targetBox.height()) {\n                        textOptions.vAlign = BOTTOM;\n                    }\n                } else {\n                    textOptions.align = aboveAxis ? RIGHT : LEFT;\n                }\n            } else if (options.position === CENTER) {\n                textOptions.vAlign = CENTER;\n                textOptions.align = CENTER;\n            } else if (options.position === INSIDE_BASE) {\n                if (vertical) {\n                    textOptions.vAlign = aboveAxis ? BOTTOM : TOP;\n                } else {\n                    textOptions.align = aboveAxis ? LEFT : RIGHT;\n                }\n            } else if (options.position === OUTSIDE_END) {\n                if (vertical) {\n                    if (aboveAxis) {\n                        labelBox = new Box(\n                            targetBox.x1, targetBox.y1 - box.height(),\n                            targetBox.x2, targetBox.y1\n                        );\n                    } else {\n                        labelBox = new Box(\n                            targetBox.x1, targetBox.y2,\n                            targetBox.x2, targetBox.y2 + box.height()\n                        );\n                    }\n                } else {\n                    textOptions.align = CENTER;\n                    if (aboveAxis) {\n                        labelBox = new Box(\n                            targetBox.x2, targetBox.y1,\n                            targetBox.x2 + box.width(), targetBox.y2\n                        );\n                    } else {\n                        labelBox = new Box(\n                            targetBox.x1 - box.width(), targetBox.y1,\n                            targetBox.x1, targetBox.y2\n                        );\n                    }\n                }\n            }\n\n            if (!options.rotation) {\n                if (vertical) {\n                    padding.left = padding.right =\n                        (labelBox.width() - text.contentBox.width()) / 2;\n                } else {\n                    padding.top = padding.bottom =\n                        (labelBox.height() - text.contentBox.height()) / 2;\n                }\n            }\n\n            text.reflow(labelBox);\n        },\n\n        alignToClipBox: function(clipBox) {\n            var vertical = this.options.vertical;\n            var field = vertical ? Y : X;\n            var start = field + \"1\";\n            var end = field + \"2\";\n            var text = this.children[0];\n            var parentBox = this.parent.box;\n\n            if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {\n                var targetBox = text.paddingBox.clone();\n                targetBox[start] = Math.max(parentBox[start], clipBox[start]);\n                targetBox[end] = Math.min(parentBox[end], clipBox[end]);\n\n                this.reflow(targetBox);\n            }\n        }\n    });\n\n    setDefaultOptions(BarLabel, {\n        position: OUTSIDE_END,\n        margin: getSpacing(3),\n        padding: getSpacing(4),\n        color: BLACK,\n        background: \"\",\n        border: {\n            width: 1,\n            color: \"\"\n        },\n        aboveAxis: true,\n        vertical: false,\n        animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n        },\n        zIndex: 2\n    });\n\n    function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {\n        if (accessibilityOptions) {\n            visual.options.className = accessibilityOptions.className;\n            visual.options.role = accessibilityOptions.role;\n            visual.options.ariaLabel = accessibilityOptions.ariaLabel;\n            visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;\n            visual.options.ariaChecked = accessibilityOptions.ariaChecked;\n        }\n    }\n\n    var AccessibilityAttributesMixin = {\n        addAccessibilityAttributesToVisual: function() {\n            this._id = this._id || guid();\n\n            var accessibilityOptions = deepExtend({\n                ariaLabel: this.getAriaLabelText()\n            }, this.options.accessibility);\n\n            addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);\n        },\n\n        getAriaLabelText: function getAriaLabelText() {\n            var labels = this.options.labels;\n            var ariaTemplate = dataviz.getAriaTemplate(labels);\n\n            if (ariaTemplate) {\n                return ariaTemplate(this.pointData());\n            }\n\n            return this.getLabelText(labels);\n        },\n\n        focusVisual: function focusVisual() {\n            this.visual.options.set(\"id\", this._id);\n            this.toggleFocusHighlight(true);\n        },\n\n        clearFocusFromVisual: function clearFocusFromVisual() {\n            this.visual.options.set(\"id\", \"\");\n            this.toggleFocusHighlight(false);\n        }\n    };\n\n    var BAR_ALIGN_MIN_WIDTH = 6;\n\n    var Bar = ChartElement.extend({\n        init: function(value, options) {\n            ChartElement.fn.init.call(this);\n\n            this.options = options;\n            this.color = options.color || WHITE;\n            this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n            this.value = value;\n        },\n\n        render: function() {\n            if (this._rendered) {\n                return;\n            }\n\n            this._rendered = true;\n\n            this.createLabel();\n            this.createNote();\n\n            if (this.errorBar) {\n                this.append(this.errorBar);\n            }\n        },\n\n        createLabel: function() {\n            var options = this.options;\n            var labels = options.labels;\n\n            if (labels.visible) {\n                this.label = this.createLabelElement(labels);\n                this.append(this.label);\n            }\n        },\n\n        createLabelElement: function(options) {\n            return new BarLabel(this.getLabelText(options),\n                deepExtend({\n                    vertical: this.options.vertical\n                },\n                options\n                ), this.pointData());\n        },\n\n        getLabelText: function(options) {\n            var labelTemplate = getTemplate(options);\n\n            if (labelTemplate) {\n                return labelTemplate(this.pointData());\n            }\n\n            return this.formatValue(options.format);\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            this.render();\n\n            var label = this.label;\n\n            this.box = targetBox;\n\n            if (label) {\n                label.options.aboveAxis = this.aboveAxis;\n                label.reflow(targetBox);\n            }\n\n            if (this.note) {\n                this.note.reflow(targetBox);\n            }\n\n            if (this.errorBars) {\n                for (var i = 0; i < this.errorBars.length; i++) {\n                    this$1$1.errorBars[i].reflow(targetBox);\n                }\n            }\n        },\n\n        createVisual: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var box = ref.box;\n            var options = ref.options;\n            var customVisual = options.visual;\n\n            if (this.visible !== false) {\n                ChartElement.fn.createVisual.call(this);\n\n                this.addAccessibilityAttributesToVisual();\n\n                if (customVisual) {\n                    var visual = this.rectVisual = customVisual({\n                        category: this.category,\n                        dataItem: this.dataItem,\n                        value: this.value,\n                        sender: this.getSender(),\n                        series: this.series,\n                        percentage: this.percentage,\n                        stackValue: this.stackValue,\n                        runningTotal: this.runningTotal,\n                        total: this.total,\n                        rect: box.toRect(),\n                        createVisual: function () {\n                            var group = new Group();\n                            this$1$1.createRect(group);\n                            return group;\n                        },\n                        options: options\n                    });\n\n                    if (visual) {\n                        this.visual.append(visual);\n                    }\n                } else if (box.width() > 0 && box.height() > 0) {\n                    this.createRect(this.visual);\n                }\n            }\n        },\n\n        createRect: function(visual) {\n            var options = this.options;\n            var border = options.border;\n            var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\n            var rect = this.box.toRect();\n\n            rect.size.width = Math.round(rect.size.width);\n\n            var path = this.rectVisual = Path.fromRect(rect, {\n                fill: {\n                    color: this.color,\n                    opacity: options.opacity\n                },\n                stroke: {\n                    color: this.getBorderColor(),\n                    width: border.width,\n                    opacity: strokeOpacity,\n                    dashType: border.dashType\n                }\n            });\n\n            var width = this.box.width();\n            var height = this.box.height();\n\n            var size = options.vertical ? width : height;\n\n            if (size > BAR_ALIGN_MIN_WIDTH) {\n                alignPathToPixel(path);\n\n                // Fixes lineJoin issue in firefox when the joined lines are parallel\n                if (width < 1 || height < 1) {\n                    path.options.stroke.lineJoin = \"round\";\n                }\n            }\n\n            visual.append(path);\n\n            if (hasGradientOverlay(options)) {\n                var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({\n                    end: !options.vertical ? [ 0, 1 ] : undefined\n                }, options.overlay));\n\n                visual.append(overlay);\n            }\n        },\n\n        createHighlight: function(style) {\n            var highlight = Path.fromRect(this.box.toRect(), style);\n\n            return alignPathToPixel(highlight);\n        },\n\n        highlightVisual: function() {\n            return this.rectVisual;\n        },\n\n        highlightVisualArgs: function() {\n            return {\n                options: this.options,\n                rect: this.box.toRect(),\n                visual: this.rectVisual\n            };\n        },\n\n        createFocusHighlight: function(style) {\n            var borderWidth = this.options.accessibility.highlight.border.width;\n            var highlight = Path.fromRect(this.box.pad(borderWidth / 2).toRect(), style);\n\n            return alignPathToPixel(highlight);\n        },\n\n        getBorderColor: function() {\n            var color = this.color;\n            var border = this.options.border;\n            var brightness = border._brightness || BORDER_BRIGHTNESS;\n            var borderColor = border.color;\n\n            if (!defined(borderColor)) {\n                borderColor = new Color(color).brightness(brightness).toHex();\n            }\n\n            return borderColor;\n        },\n\n        tooltipAnchor: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var aboveAxis = ref.aboveAxis;\n            var clipBox = this.owner.pane.clipBox() || box;\n            var horizontalAlign = LEFT;\n            var verticalAlign = TOP;\n            var x, y;\n\n            if (options.vertical) {\n                x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\n                if (aboveAxis) {\n                    y = Math.max(box.y1, clipBox.y1);\n                } else {\n                    y = Math.min(box.y2, clipBox.y2);\n                    verticalAlign = BOTTOM;\n                }\n            } else {\n                var x1 = Math.max(box.x1, clipBox.x1);\n                var x2 = Math.min(box.x2, clipBox.x2);\n\n                if (options.isStacked) {\n                    verticalAlign = BOTTOM;\n                    if (aboveAxis) {\n                        horizontalAlign = RIGHT;\n                        x = x2;\n                    } else {\n                        x = x1;\n                    }\n                    y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\n                } else {\n                    if (aboveAxis) {\n                        x = x2 + TOOLTIP_OFFSET;\n                    } else {\n                        x = x1 - TOOLTIP_OFFSET;\n                        horizontalAlign = RIGHT;\n                    }\n                    y = Math.max(box.y1, clipBox.y1);\n                }\n            }\n\n            return {\n                point: new Point(x, y),\n                align: {\n                    horizontal: horizontalAlign,\n                    vertical: verticalAlign\n                }\n            };\n        },\n\n        overlapsBox: function(box) {\n            return this.box.overlaps(box);\n        },\n\n        pointData: function() {\n            return {\n                dataItem: this.dataItem,\n                category: this.category,\n                value: this.value,\n                percentage: this.percentage,\n                stackValue: this.stackValue,\n                runningTotal: this.runningTotal,\n                total: this.total,\n                series: this.series\n            };\n        },\n\n        getIndex: function() {\n            return this.categoryIx;\n        }\n    });\n\n    deepExtend(Bar.prototype, PointEventsMixin);\n    deepExtend(Bar.prototype, NoteMixin);\n    deepExtend(Bar.prototype, AccessibilityAttributesMixin);\n\n    Bar.prototype.defaults = {\n        border: {\n            width: 1\n        },\n        vertical: true,\n        overlay: {\n            gradient: \"glass\"\n        },\n        labels: {\n            visible: false,\n            format: \"{0}\"\n        },\n        opacity: 1,\n        notes: {\n            label: {}\n        },\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    };\n\n    function forEach(elements, callback) {\n        elements.forEach(callback);\n    }\n\n    function forEachReverse(elements, callback) {\n        var length = elements.length;\n\n        for (var idx = length - 1; idx >= 0; idx--) {\n            callback(elements[idx], idx - length - 1);\n        }\n    }\n\n    var ClusterLayout = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.forEach = options.rtl ? forEachReverse : forEach;\n        },\n\n        reflow: function(box) {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var gap = ref.gap;\n            var spacing = ref.spacing;\n            var children = this.children;\n            var count = children.length;\n            var axis = vertical ? Y : X;\n            var slots = count + gap + (spacing * (count - 1));\n            var slotSize = (vertical ? box.height() : box.width()) / slots;\n            var position = box[axis + 1] + slotSize * (gap / 2);\n\n            this.forEach(children, function (child, idx) {\n                var childBox = (child.box || box).clone();\n\n                childBox[axis + 1] = position;\n                childBox[axis + 2] = position + slotSize;\n\n                child.reflow(childBox);\n                if (idx < count - 1) {\n                    position += (slotSize * spacing);\n                }\n\n                position += slotSize;\n            });\n        }\n    });\n\n    setDefaultOptions(ClusterLayout, {\n        vertical: false,\n        gap: 0,\n        spacing: 0\n    });\n\n    var StackWrap = ChartElement.extend({\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var positionAxis = this.options.vertical ? X : Y;\n            var children = this.children;\n            var childrenCount = children.length;\n            var box = this.box = new Box();\n\n            for (var i = 0; i < childrenCount; i++) {\n                var currentChild = children[i];\n\n                if (currentChild.visible !== false) {\n                    var childBox = currentChild.box.clone();\n                    childBox.snapTo(targetBox, positionAxis);\n\n                    if (i === 0) {\n                        box = this$1$1.box = childBox.clone();\n                    }\n\n                    currentChild.reflow(childBox);\n                    box.wrap(childBox);\n                }\n            }\n        }\n    });\n\n    setDefaultOptions(StackWrap, {\n        vertical: true\n    });\n\n    var BarChart = CategoricalChart.extend({\n        render: function() {\n            CategoricalChart.fn.render.call(this);\n            this.updateStackRange();\n        },\n\n        pointType: function() {\n            return Bar;\n        },\n\n        clusterType: function() {\n            return ClusterLayout;\n        },\n\n        stackType: function() {\n            return StackWrap;\n        },\n\n        stackLimits: function(axisName, stackName) {\n            var limits = CategoricalChart.fn.stackLimits.call(this, axisName, stackName);\n\n            return limits;\n        },\n\n        createPoint: function(data, fields) {\n            var categoryIx = fields.categoryIx;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var stackOrDefault = defined(series.stack) ? series.stack : options.defaultStack;\n            var value = this.pointValue(data);\n            var pointOptions = this.pointOptions(series, seriesIx);\n\n            var labelOptions = pointOptions.labels;\n            if (stackOrDefault) {\n                if (labelOptions.position === OUTSIDE_END) {\n                    labelOptions.position = INSIDE_END;\n                }\n            }\n\n            pointOptions.isStacked = stackOrDefault;\n\n            var color = data.fields.color || series.color;\n            if (value < 0 && pointOptions.negativeColor) {\n                color = pointOptions.negativeColor;\n            }\n\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n\n            var pointType = this.pointType();\n            var point = new pointType(value, pointOptions);\n            point.color = color;\n\n            var cluster = children[categoryIx];\n            if (!cluster) {\n                var clusterType = this.clusterType();\n                cluster = new clusterType({\n                    vertical: options.invertAxes,\n                    gap: options.gap,\n                    spacing: options.spacing,\n                    rtl: !options.invertAxes && (this.chartService || {}).rtl\n                });\n                this.append(cluster);\n            }\n\n            if (options.isStacked) {\n                var stackWrap = this.getStackWrap(stackOrDefault, cluster);\n                stackWrap.append(point);\n            } else {\n                cluster.append(point);\n            }\n\n            return point;\n        },\n\n        getStackWrap: function(stack, cluster) {\n            var stackGroup = (typeof stack === datavizConstants.OBJECT) ? (stack.group || true) : stack;\n            var wraps = cluster.children;\n            var stackWrap;\n\n            if (typeof stackGroup === datavizConstants.STRING || stackGroup === true) {\n                for (var i = 0; i < wraps.length; i++) {\n                    if (wraps[i]._stackGroup === stackGroup) {\n                        stackWrap = wraps[i];\n                        break;\n                    }\n                }\n            }\n\n            if (!stackWrap) {\n                var stackType = this.stackType();\n                stackWrap = new stackType({\n                    vertical: !this.options.invertAxes\n                });\n                stackWrap._stackGroup = stackGroup;\n                cluster.append(stackWrap);\n            }\n\n            return stackWrap;\n        },\n\n        categorySlot: function(categoryAxis, categoryIx, valueAxis) {\n            var options = this.options;\n            var categorySlot = categoryAxis.getSlot(categoryIx);\n            var startValue = valueAxis.startValue();\n\n            if (options.isStacked) {\n                var zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n                var stackAxis = options.invertAxes ? X : Y;\n                categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n            }\n\n            return categorySlot;\n        },\n\n        reflowCategories: function(categorySlots) {\n            var children = this.children;\n            var childrenLength = children.length;\n\n            for (var i = 0; i < childrenLength; i++) {\n                children[i].reflow(categorySlots[i]);\n            }\n        },\n\n        createAnimation: function() {\n            this._setAnimationOptions();\n            CategoricalChart.fn.createAnimation.call(this);\n\n            if (anyHasZIndex(this.options.series)) {\n                this._setChildrenAnimation();\n            }\n        },\n\n        _setChildrenAnimation: function() {\n            var this$1$1 = this;\n\n            var points = this.points;\n\n            for (var idx = 0; idx < points.length; idx++) {\n                var point = points[idx];\n                var pointVisual = point.visual;\n                if (pointVisual && defined(pointVisual.options.zIndex)) {\n                    point.options.animation = this$1$1.options.animation;\n                    point.createAnimation();\n                }\n            }\n        },\n\n        _setAnimationOptions: function() {\n            var options = this.options;\n            var animation = options.animation || {};\n            var origin;\n\n            if (options.isStacked) {\n                var valueAxis = this.seriesValueAxis(options.series[0]);\n                origin = valueAxis.getSlot(valueAxis.startValue());\n            } else {\n                origin = this.categoryAxis.getSlot(0);\n            }\n\n            animation.origin = new GeometryPoint(origin.x1, origin.y1);\n            animation.vertical = !options.invertAxes;\n        }\n    });\n\n    setDefaultOptions(BarChart, {\n        animation: {\n            type: BAR\n        }\n    });\n\n    var Candlestick = ChartElement.extend({\n        init: function(value, options) {\n            ChartElement.fn.init.call(this, options);\n            this.value = value;\n        },\n\n        getLabelText: function(options) {\n            return this.formatValue(options.format);\n        },\n\n        reflow: function(box) {\n            var ref = this;\n            var options = ref.options;\n            var value = ref.value;\n            var chart = ref.owner;\n            var valueAxis = chart.seriesValueAxis(options);\n            var ocSlot = valueAxis.getSlot(value.open, value.close);\n            var lhSlot = valueAxis.getSlot(value.low, value.high);\n\n            ocSlot.x1 = lhSlot.x1 = box.x1;\n            ocSlot.x2 = lhSlot.x2 = box.x2;\n\n            this.realBody = ocSlot;\n\n            var mid = lhSlot.center().x;\n            var points = [];\n\n            points.push([ [ mid, lhSlot.y1 ], [ mid, ocSlot.y1 ] ]);\n            points.push([ [ mid, ocSlot.y2 ], [ mid, lhSlot.y2 ] ]);\n\n            this.lines = points;\n\n            this.box = lhSlot.clone().wrap(ocSlot);\n\n            if (!this._rendered) {\n                this._rendered = true;\n                this.createNote();\n            }\n\n            this.reflowNote();\n        },\n\n        reflowNote: function() {\n            if (this.note) {\n                this.note.reflow(this.box);\n            }\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            this.addAccessibilityAttributesToVisual();\n\n            this._mainVisual = this.mainVisual(this.options);\n            this.visual.append(\n                this._mainVisual\n            );\n\n            this.createOverlay();\n        },\n\n        mainVisual: function(options) {\n            var group = new Group();\n\n            this.createBody(group, options);\n            this.createLines(group, options);\n\n            return group;\n        },\n\n        createBody: function(container, options) {\n            var body = Path.fromRect(this.realBody.toRect(), {\n                fill: {\n                    color: this.color,\n                    opacity: options.opacity\n                },\n                stroke: null\n            });\n\n            if (options.border.width > 0) {\n                body.options.set(\"stroke\", {\n                    color: this.getBorderColor(),\n                    width: options.border.width,\n                    dashType: options.border.dashType,\n                    opacity: valueOrDefault(options.border.opacity, options.opacity)\n                });\n            }\n\n            alignPathToPixel(body);\n            container.append(body);\n\n            if (hasGradientOverlay(options)) {\n                container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({\n                    end: !options.vertical ? [ 0, 1 ] : undefined\n                }, options.overlay)));\n            }\n        },\n\n        createLines: function(container, options) {\n            this.drawLines(container, options, this.lines, options.line);\n        },\n\n        drawLines: function(container, options, lines, lineOptions) {\n            if (!lines) {\n                return;\n            }\n\n            var lineStyle = {\n                stroke: {\n                    color: lineOptions.color || this.color,\n                    opacity: valueOrDefault(lineOptions.opacity, options.opacity),\n                    width: lineOptions.width,\n                    dashType: lineOptions.dashType,\n                    lineCap: \"butt\"\n                }\n            };\n\n            for (var i = 0; i < lines.length; i++) {\n                var line = Path.fromPoints(lines[i], lineStyle);\n                alignPathToPixel(line);\n                container.append(line);\n            }\n        },\n\n        getBorderColor: function() {\n            var border = this.options.border;\n            var borderColor = border.color;\n\n            if (!defined(borderColor)) {\n                borderColor = new Color(this.color).brightness(border._brightness).toHex();\n            }\n\n            return borderColor;\n        },\n\n        createOverlay: function() {\n            var overlay = Path.fromRect(this.box.toRect(), {\n                fill: {\n                    color: WHITE,\n                    opacity: 0\n                },\n                stroke: null\n            });\n\n            this.visual.append(overlay);\n        },\n\n        createHighlight: function() {\n            var highlight = this.options.highlight;\n            var normalColor = this.color;\n\n            this.color = highlight.color || this.color;\n            var overlay = this.mainVisual(\n                deepExtend({}, this.options, {\n                    line: {\n                        color: this.getBorderColor()\n                    }\n                }, highlight)\n            );\n            this.color = normalColor;\n\n            return overlay;\n        },\n\n        highlightVisual: function() {\n            return this._mainVisual;\n        },\n\n        highlightVisualArgs: function() {\n            return {\n                options: this.options,\n                rect: this.box.toRect(),\n                visual: this._mainVisual\n            };\n        },\n\n        tooltipAnchor: function() {\n            var box = this.box;\n            var clipBox = this.owner.pane.clipBox() || box;\n\n            return {\n                point: new Point(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),\n                align: {\n                    horizontal: LEFT,\n                    vertical: TOP\n                }\n            };\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        overlapsBox: function(box) {\n            return this.box.overlaps(box);\n        },\n\n        pointData: function() {\n            return {\n                dataItem: this.dataItem,\n                value: this.value,\n                meanPoints: this.meanPoints,\n                medianPoints: this.medianPoints,\n                whiskerPoints: this.whiskerPoints,\n                stackValue: this.stackValue,\n                series: this.series\n            };\n        },\n\n        getIndex: function() {\n            return this.categoryIx;\n        }\n    });\n\n    Candlestick.prototype.createFocusHighlight = Bar.prototype.createFocusHighlight;\n\n    setDefaultOptions(Candlestick, {\n        vertical: true,\n        border: {\n            _brightness: 0.8\n        },\n        line: {\n            width: 2\n        },\n        overlay: {\n            gradient: \"glass\"\n        },\n        tooltip: {\n            format: \"<table>\" +\n                        \"<tr><th colspan='2'>{4:d}</th></tr>\" +\n                        \"<tr><td>Open:</td><td>{0:C}</td></tr>\" +\n                        \"<tr><td>High:</td><td>{1:C}</td></tr>\" +\n                        \"<tr><td>Low:</td><td>{2:C}</td></tr>\" +\n                        \"<tr><td>Close:</td><td>{3:C}</td></tr>\" +\n                    \"</table>\"\n        },\n        labels: {\n            format: \"\"\n        },\n        highlight: {\n            opacity: 1,\n            border: {\n                width: 1,\n                opacity: 1\n            },\n            line: {\n                width: 1,\n                opacity: 1\n            }\n        },\n        notes: {\n            visible: true,\n            label: {}\n        },\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    });\n\n    deepExtend(Candlestick.prototype, PointEventsMixin);\n    deepExtend(Candlestick.prototype, NoteMixin);\n    deepExtend(Candlestick.prototype, AccessibilityAttributesMixin);\n\n    var CandlestickChart = CategoricalChart.extend({\n        reflowCategories: function(categorySlots) {\n            var children = this.children;\n            var childrenLength = children.length;\n\n            for (var i = 0; i < childrenLength; i++) {\n                children[i].reflow(categorySlots[i]);\n            }\n        },\n\n        addValue: function(data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var children = ref.children;\n            var options = ref.options;\n            var value = data.valueFields;\n            var valueParts = this.splitValue(value);\n            var hasValue = areNumbers(valueParts);\n            var dataItem = series.data[categoryIx];\n            var categoryPoints = this.categoryPoints[categoryIx];\n            var point;\n\n            if (!categoryPoints) {\n                this.categoryPoints[categoryIx] = categoryPoints = [];\n            }\n\n            if (hasValue) {\n                point = this.createPoint(data, fields);\n            }\n\n            var cluster = children[categoryIx];\n            if (!cluster) {\n                cluster = new ClusterLayout({\n                    vertical: options.invertAxes,\n                    gap: options.gap,\n                    spacing: options.spacing,\n                    rtl: !options.invertAxes && (this.chartService || {}).rtl\n                });\n                this.append(cluster);\n            }\n\n            if (point) {\n                this.updateRange(value, fields);\n\n                cluster.append(point);\n\n                point.categoryIx = categoryIx;\n                point.category = category;\n                point.series = series;\n                point.seriesIx = seriesIx;\n                point.owner = this;\n                point.dataItem = dataItem;\n                point.noteText = data.fields.noteText;\n            }\n\n            this.points.push(point);\n            categoryPoints.push(point);\n        },\n\n        pointType: function() {\n            return Candlestick;\n        },\n\n        createPoint: function(data, fields) {\n            var series = fields.series;\n            var pointType = this.pointType();\n            var value = data.valueFields;\n            var pointOptions = deepExtend({}, series);\n            var color = data.fields.color || series.color;\n\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            if (series.type === CANDLESTICK || series.type === OHLC) {\n                if (value.open > value.close) {\n                    color = data.fields.downColor || series.downColor || series.color;\n                }\n            }\n\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n\n            pointOptions.vertical = !this.options.invertAxes;\n\n            var point = new pointType(value, pointOptions);\n            point.color = color;\n\n            return point;\n        },\n\n        splitValue: function(value) {\n            return [ value.low, value.open, value.close, value.high ];\n        },\n\n        updateRange: function(value, fields) {\n            var axisName = fields.series.axis;\n            var parts = this.splitValue(value);\n            var axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };\n\n            this.valueAxisRanges[axisName] = {\n                min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\n                max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\n            };\n        },\n\n        formatPointValue: function(point, format) {\n            var value = point.value;\n\n            return this.chartService.format.auto(format,\n                value.open, value.high,\n                value.low, value.close, point.category\n            );\n        },\n\n        animationPoints: function() {\n            return this.points;\n        }\n    });\n\n    deepExtend(CandlestickChart.prototype, ClipAnimationMixin);\n\n    var BoxPlot = Candlestick.extend({\n        init: function(value, options) {\n            Candlestick.fn.init.call(this, value, options);\n\n            this.createNote();\n        },\n\n        reflow: function(box) {\n            var ref = this;\n            var options = ref.options;\n            var value = ref.value;\n            var chart = ref.owner;\n            var valueAxis = chart.seriesValueAxis(options);\n            var whiskerSlot, boxSlot;\n\n            this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);\n            this.realBody = boxSlot;\n            this.reflowBoxSlot(box);\n\n            this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);\n            this.reflowWhiskerSlot(box);\n\n            var medianSlot = valueAxis.getSlot(value.median);\n\n            if (value.mean) {\n                var meanSlot = valueAxis.getSlot(value.mean);\n                this.meanPoints = this.calcMeanPoints(box, meanSlot);\n            }\n\n            this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);\n            this.medianPoints = this.calcMedianPoints(box, medianSlot);\n\n            this.box = whiskerSlot.clone().wrap(boxSlot);\n            this.reflowNote();\n        },\n\n        reflowBoxSlot: function(box) {\n            this.boxSlot.x1 = box.x1;\n            this.boxSlot.x2 = box.x2;\n        },\n\n        reflowWhiskerSlot: function(box) {\n            this.whiskerSlot.x1 = box.x1;\n            this.whiskerSlot.x2 = box.x2;\n        },\n\n        calcMeanPoints: function(box, meanSlot) {\n            return [\n                [ [ box.x1, meanSlot.y1 ], [ box.x2, meanSlot.y1 ] ]\n            ];\n        },\n\n        calcWhiskerPoints: function(boxSlot, whiskerSlot) {\n            var mid = whiskerSlot.center().x;\n            return [ [\n                [ mid - 5, whiskerSlot.y1 ], [ mid + 5, whiskerSlot.y1 ],\n                [ mid, whiskerSlot.y1 ], [ mid, boxSlot.y1 ]\n            ], [\n                [ mid - 5, whiskerSlot.y2 ], [ mid + 5, whiskerSlot.y2 ],\n                [ mid, whiskerSlot.y2 ], [ mid, boxSlot.y2 ]\n            ] ];\n        },\n\n        calcMedianPoints: function(box, medianSlot) {\n            return [\n                [ [ box.x1, medianSlot.y1 ], [ box.x2, medianSlot.y1 ] ]\n            ];\n        },\n\n        renderOutliers: function(options) {\n            var this$1$1 = this;\n\n            var value = this.value;\n            var outliers = value.outliers || [];\n            var outerFence = Math.abs(value.q3 - value.q1) * 3;\n            var elements = [];\n            var markers = options.markers || {};\n\n            for (var i = 0; i < outliers.length; i++) {\n                var outlierValue = outliers[i];\n                if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {\n                    markers = options.outliers;\n                } else {\n                    markers = options.extremes;\n                }\n                var markersBorder = deepExtend({}, markers.border);\n\n                if (!defined(markersBorder.color)) {\n                    if (defined(this$1$1.color)) {\n                        markersBorder.color = this$1$1.color;\n                    } else {\n                        markersBorder.color =\n                            new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex();\n                    }\n                }\n\n                var shape = new ShapeElement({\n                    type: markers.type,\n                    width: markers.size,\n                    height: markers.size,\n                    rotation: markers.rotation,\n                    background: markers.background,\n                    border: markersBorder,\n                    opacity: markers.opacity\n                });\n\n                shape.value = outlierValue;\n\n                elements.push(shape);\n            }\n\n            this.reflowOutliers(elements);\n            return elements;\n        },\n\n        reflowOutliers: function(outliers) {\n            var this$1$1 = this;\n\n            var valueAxis = this.owner.seriesValueAxis(this.options);\n            var center = this.box.center();\n\n            for (var i = 0; i < outliers.length; i++) {\n                var outlierValue = outliers[i].value;\n                var markerBox = valueAxis.getSlot(outlierValue);\n\n                if (this$1$1.options.vertical) {\n                    markerBox.move(center.x);\n                } else {\n                    markerBox.move(undefined, center.y);\n                }\n\n                this$1$1.box = this$1$1.box.wrap(markerBox);\n                outliers[i].reflow(markerBox);\n            }\n        },\n\n        mainVisual: function(options) {\n            var group = Candlestick.fn.mainVisual.call(this, options);\n            var outliers = this.renderOutliers(options);\n\n            for (var i = 0; i < outliers.length; i++) {\n                var element = outliers[i].getElement();\n                if (element) {\n                    group.append(element);\n                }\n            }\n\n            return group;\n        },\n\n        createLines: function(container, options) {\n            this.drawLines(container, options, this.whiskerPoints, options.whiskers);\n            this.drawLines(container, options, this.medianPoints, options.median);\n            this.drawLines(container, options, this.meanPoints, options.mean);\n        },\n\n        getBorderColor: function() {\n            if ((this.options.border || {}).color) {\n                return this.options.border.color;\n            }\n\n            if (this.color) {\n                return this.color;\n            }\n\n            return Candlestick.fn.getBorderColor.call(this);\n        }\n    });\n\n    setDefaultOptions(BoxPlot, {\n        border: {\n            _brightness: 0.8\n        },\n        line: {\n            width: 2\n        },\n        median: {\n            color: \"#f6f6f6\"\n        },\n        mean: {\n            width: 2,\n            dashType: \"dash\",\n            color: \"#f6f6f6\"\n        },\n        overlay: {\n            gradient: \"glass\"\n        },\n        tooltip: {\n            format: \"<table>\" +\n                        \"<tr><th colspan='2'>{6:d}</th></tr>\" +\n                        \"<tr><td>Lower:</td><td>{0:C}</td></tr>\" +\n                        \"<tr><td>Q1:</td><td>{1:C}</td></tr>\" +\n                        \"<tr><td>Median:</td><td>{2:C}</td></tr>\" +\n                        \"<tr><td>Mean:</td><td>{5:C}</td></tr>\" +\n                        \"<tr><td>Q3:</td><td>{3:C}</td></tr>\" +\n                        \"<tr><td>Upper:</td><td>{4:C}</td></tr>\" +\n                    \"</table>\"\n        },\n        highlight: {\n            opacity: 1,\n            border: {\n                width: 1,\n                opacity: 1\n            },\n            line: {\n                width: 1,\n                opacity: 1\n            }\n        },\n        notes: {\n            visible: true,\n            label: {}\n        },\n        outliers: {\n            visible: true,\n            size: LINE_MARKER_SIZE,\n            type: datavizConstants.CROSS,\n            background: WHITE,\n            border: {\n                width: 2,\n                opacity: 1\n            },\n            opacity: 0\n        },\n        extremes: {\n            visible: true,\n            size: LINE_MARKER_SIZE,\n            type: CIRCLE,\n            background: WHITE,\n            border: {\n                width: 2,\n                opacity: 1\n            },\n            opacity: 0\n        }\n    });\n\n    deepExtend(BoxPlot.prototype, PointEventsMixin);\n\n    var VerticalBoxPlot = BoxPlot.extend({\n        reflowBoxSlot: function(box) {\n            this.boxSlot.y1 = box.y1;\n            this.boxSlot.y2 = box.y2;\n        },\n\n        reflowWhiskerSlot: function(box) {\n            this.whiskerSlot.y1 = box.y1;\n            this.whiskerSlot.y2 = box.y2;\n        },\n\n        calcMeanPoints: function(box, meanSlot) {\n            return [\n                [ [ meanSlot.x1, box.y1 ], [ meanSlot.x1, box.y2 ] ]\n            ];\n        },\n\n        calcWhiskerPoints: function(boxSlot, whiskerSlot) {\n            var mid = whiskerSlot.center().y;\n            return [ [\n                [ whiskerSlot.x1, mid - 5 ], [ whiskerSlot.x1, mid + 5 ],\n                [ whiskerSlot.x1, mid ], [ boxSlot.x1, mid ]\n            ], [\n                [ whiskerSlot.x2, mid - 5 ], [ whiskerSlot.x2, mid + 5 ],\n                [ whiskerSlot.x2, mid ], [ boxSlot.x2, mid ]\n            ] ];\n        },\n\n        calcMedianPoints: function(box, medianSlot) {\n            return [\n                [ [ medianSlot.x1, box.y1 ], [ medianSlot.x1, box.y2 ] ]\n            ];\n        }\n    });\n\n    var BoxPlotChart = CandlestickChart.extend({\n        addValue: function(data, fields) {\n            var categoryIx = fields.categoryIx;\n            var category = fields.category;\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var ref = this;\n            var children = ref.children;\n            var options = ref.options;\n            var value = data.valueFields;\n            var valueParts = this.splitValue(value);\n            var hasValue = areNumbers(valueParts);\n            var dataItem = series.data[categoryIx];\n            var categoryPoints = this.categoryPoints[categoryIx];\n            var point;\n\n            if (!categoryPoints) {\n                this.categoryPoints[categoryIx] = categoryPoints = [];\n            }\n\n            if (hasValue) {\n                point = this.createPoint(data, fields);\n            }\n\n            var cluster = children[categoryIx];\n            if (!cluster) {\n                cluster = new ClusterLayout({\n                    vertical: options.invertAxes,\n                    gap: options.gap,\n                    spacing: options.spacing,\n                    rtl: !options.invertAxes && (this.chartService || {}).rtl\n                });\n                this.append(cluster);\n            }\n\n            if (point) {\n                this.updateRange(value, fields);\n\n                cluster.append(point);\n\n                point.categoryIx = categoryIx;\n                point.category = category;\n                point.series = series;\n                point.seriesIx = seriesIx;\n                point.owner = this;\n                point.dataItem = dataItem;\n            }\n\n            this.points.push(point);\n            categoryPoints.push(point);\n        },\n\n        pointType: function() {\n            if (this.options.invertAxes) {\n                return VerticalBoxPlot;\n            }\n\n            return BoxPlot;\n        },\n\n        splitValue: function(value) {\n            return [\n                value.lower, value.q1, value.median,\n                value.q3, value.upper\n            ];\n        },\n\n        updateRange: function(value, fields) {\n            var axisName = fields.series.axis;\n            var parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));\n\n            if (defined(value.mean)) {\n                parts = parts.concat(value.mean);\n            }\n\n            var axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };\n\n            this.valueAxisRanges[axisName] = {\n                min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\n                max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\n            };\n        },\n\n        formatPointValue: function(point, format) {\n            var value = point.value;\n\n            return this.chartService.format.auto(format,\n                value.lower, value.q1, value.median,\n                value.q3, value.upper, value.mean, point.category\n            );\n        },\n\n        filterOutliers: function(items) {\n            var length = (items || []).length;\n            var result = [];\n\n            for (var i = 0; i < length; i++) {\n                var item = items[i];\n                if (defined(item) && item !== null) {\n                    result.push(item);\n                }\n            }\n\n            return result;\n        },\n\n        supportsPointInactiveOpacity: function() {\n            return false;\n        }\n    });\n\n    var ScatterErrorBar = ErrorBarBase.extend({\n        getAxis: function() {\n            var axes = this.chart.seriesAxes(this.series);\n            var axis = this.isVertical ? axes.y : axes.x;\n\n            return axis;\n        }\n    });\n\n    var ScatterChart = ChartElement.extend({\n        init: function(plotArea, options) {\n\n            ChartElement.fn.init.call(this, options);\n\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this._initFields();\n\n            this.render();\n        },\n\n        _initFields: function() {\n            // X and Y axis ranges grouped by name, e.g.:\n            // primary: { min: 0, max: 1 }\n            this.xAxisRanges = {};\n            this.yAxisRanges = {};\n\n            this.points = [];\n            this.seriesPoints = [];\n            this.seriesOptions = [];\n            this._evalSeries = [];\n        },\n\n        render: function() {\n            this.traverseDataPoints(this.addValue.bind(this));\n        },\n\n        addErrorBar: function(point, field, fields) {\n            var value = point.value[field];\n            var valueErrorField = field + \"Value\";\n            var lowField = field + \"ErrorLow\";\n            var highField = field + \"ErrorHigh\";\n            var seriesIx = fields.seriesIx;\n            var series = fields.series;\n            var errorBars = point.options.errorBars;\n            var lowValue = fields[lowField];\n            var highValue = fields[highField];\n\n            if (isNumber(value)) {\n                var errorRange;\n                if (isNumber(lowValue) && isNumber(highValue)) {\n                    errorRange = { low: lowValue, high: highValue };\n                }\n\n                if (errorBars && defined(errorBars[valueErrorField])) {\n                    this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };\n                    this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] ||\n                        new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n\n                    errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n                }\n\n                if (errorRange) {\n                    this.addPointErrorBar(errorRange, point, field);\n                }\n            }\n        },\n\n        addPointErrorBar: function(errorRange, point, field) {\n            var low = errorRange.low;\n            var high = errorRange.high;\n            var series = point.series;\n            var options = point.options.errorBars;\n            var isVertical = field === Y;\n            var item = {};\n\n            point[field + \"Low\"] = low;\n            point[field + \"High\"] = high;\n\n            point.errorBars = point.errorBars || [];\n            var errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\n            point.errorBars.push(errorBar);\n            point.append(errorBar);\n\n            item[field] = low;\n            this.updateRange(item, series);\n            item[field] = high;\n            this.updateRange(item, series);\n        },\n\n        addValue: function(value, fields) {\n            var x = value.x;\n            var y = value.y;\n            var seriesIx = fields.seriesIx;\n            var series = this.options.series[seriesIx];\n            var missingValues = this.seriesMissingValues(series);\n            var seriesPoints = this.seriesPoints[seriesIx];\n\n            var pointValue = value;\n            if (!(hasValue(x) && hasValue(y))) {\n                pointValue = this.createMissingValue(pointValue, missingValues);\n            }\n\n            var point;\n            if (pointValue) {\n                point = this.createPoint(pointValue, fields);\n                if (point) {\n                    $.extend(point, fields);\n                    this.addErrorBar(point, X, fields);\n                    this.addErrorBar(point, Y, fields);\n                }\n                this.updateRange(pointValue, fields.series);\n            }\n\n            this.points.push(point);\n            seriesPoints.push(point);\n        },\n\n        seriesMissingValues: function(series) {\n            return series.missingValues;\n        },\n\n        createMissingValue: function() {},\n\n        updateRange: function(value, series) {\n            var intlService = this.chartService.intl;\n            var xAxisName = series.xAxis;\n            var yAxisName = series.yAxis;\n            var x = value.x;\n            var y = value.y;\n            var xAxisRange = this.xAxisRanges[xAxisName];\n            var yAxisRange = this.yAxisRanges[yAxisName];\n\n            if (hasValue(x)) {\n                xAxisRange = this.xAxisRanges[xAxisName] =\n                    xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n                if (isString(x)) {\n                    x = parseDate(intlService, x);\n                }\n\n                xAxisRange.min = Math.min(xAxisRange.min, x);\n                xAxisRange.max = Math.max(xAxisRange.max, x);\n            }\n\n            if (hasValue(y)) {\n                yAxisRange = this.yAxisRanges[yAxisName] =\n                    yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n                if (isString(y)) {\n                    y = parseDate(intlService, y);\n                }\n\n                yAxisRange.min = Math.min(yAxisRange.min, y);\n                yAxisRange.max = Math.max(yAxisRange.max, y);\n            }\n        },\n\n        evalPointOptions: function(options, value, fields) {\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var state = {\n                defaults: series._defaults,\n                excluded: [\n                    \"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\",\n                    \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\",\n                    \"drilldownSeriesFactory\", \"ariaTemplate\", \"ariaContent\"\n                ]\n            };\n\n            var doEval = this._evalSeries[seriesIx];\n            if (!defined(doEval)) {\n                this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n            }\n\n            var pointOptions = options;\n            if (doEval) {\n                pointOptions = deepExtend({}, options);\n                evalOptions(pointOptions, {\n                    value: value,\n                    series: series,\n                    dataItem: fields.dataItem\n                }, state);\n            }\n\n            return pointOptions;\n        },\n\n        pointType: function() {\n            return LinePoint;\n        },\n\n        pointOptions: function(series, seriesIx) {\n            var options = this.seriesOptions[seriesIx];\n            if (!options) {\n                var defaults = this.pointType().prototype.defaults;\n                this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                    markers: {\n                        opacity: series.opacity\n                    },\n                    tooltip: {\n                        format: this.options.tooltip.format\n                    },\n                    labels: {\n                        format: this.options.labels.format\n                    }\n                }, series);\n            }\n\n            return options;\n        },\n\n        createPoint: function(value, fields) {\n            var series = fields.series;\n            var pointOptions = this.pointOptions(series, fields.seriesIx);\n            var color = fields.color || series.color;\n\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n\n            var point = new LinePoint(value, pointOptions);\n            point.color = color;\n\n            this.append(point);\n\n            return point;\n        },\n\n        seriesAxes: function(series) {\n            var xAxisName = series.xAxis;\n            var yAxisName = series.yAxis;\n            var plotArea = this.plotArea;\n            var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n            var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n            if (!xAxis) {\n                throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n            }\n\n            if (!yAxis) {\n                throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n            }\n\n            return {\n                x: xAxis,\n                y: yAxis\n            };\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var chartPoints = this.points;\n            var limit = !this.options.clip;\n            var pointIx = 0;\n\n            this.traverseDataPoints(function (value, fields) {\n                var point = chartPoints[pointIx++];\n                var seriesAxes = this$1$1.seriesAxes(fields.series);\n                var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n                var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n\n                if (point) {\n                    if (slotX && slotY) {\n                        var pointSlot = this$1$1.pointSlot(slotX, slotY);\n                        point.reflow(pointSlot);\n                    } else {\n                        point.visible = false;\n                    }\n                }\n            });\n\n            this.box = targetBox;\n        },\n\n        pointSlot: function(slotX, slotY) {\n            return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n        },\n\n        traverseDataPoints: function(callback) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var series = ref.options.series;\n            var seriesPoints = ref.seriesPoints;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var currentSeriesPoints = seriesPoints[seriesIx];\n                if (!currentSeriesPoints) {\n                    seriesPoints[seriesIx] = [];\n                }\n\n                for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                    var ref$1 = this$1$1.plotArea.bindPoint(currentSeries, pointIx);\n                    var value = ref$1.valueFields;\n                    var fields = ref$1.fields;\n\n                    callback(value, deepExtend({\n                        pointIx: pointIx,\n                        series: currentSeries,\n                        seriesIx: seriesIx,\n                        dataItem: currentSeries.data[pointIx],\n                        owner: this$1$1\n                    }, fields));\n                }\n            }\n        },\n\n        formatPointValue: function(point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.x, value.y);\n        },\n\n        animationPoints: function() {\n            var points = this.points;\n            var result = [];\n            for (var idx = 0; idx < points.length; idx++) {\n                result.push((points[idx] || {}).marker);\n            }\n            return result;\n        }\n    });\n    setDefaultOptions(ScatterChart, {\n        series: [],\n        tooltip: {\n            format: \"{0}, {1}\"\n        },\n        labels: {\n            format: \"{0}, {1}\"\n        },\n        clip: true\n    });\n    deepExtend(ScatterChart.prototype, ClipAnimationMixin);\n\n    var Bubble = LinePoint.extend({\n        init: function(value, options) {\n            LinePoint.fn.init.call(this, value, options);\n\n            this.category = value.category;\n        },\n\n        createHighlight: function() {\n            var highlight = this.options.highlight;\n            var border = highlight.border;\n            var markers = this.options.markers;\n            var center = this.box.center();\n            var radius = (markers.size + markers.border.width + border.width) / 2;\n            var highlightGroup = new Group();\n            var shadow = new Circle(new GeometryCircle([ center.x, center.y + radius / 5 + border.width / 2 ], radius + border.width / 2), {\n                stroke: {\n                    color: 'none'\n                },\n                fill: this.createGradient({\n                    gradient: 'bubbleShadow',\n                    color: markers.background,\n                    stops: [ {\n                        offset: 0,\n                        color: markers.background,\n                        opacity: 0.3\n                    }, {\n                        offset: 1,\n                        color: markers.background,\n                        opacity: 0\n                    } ]\n                })\n            });\n            var overlay = new Circle(new GeometryCircle([ center.x, center.y ], radius), {\n                stroke: {\n                    color: border.color ||\n                        new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),\n                    width: border.width,\n                    opacity: border.opacity\n                },\n                fill: {\n                    color: markers.background,\n                    opacity: highlight.opacity\n                }\n            });\n\n            highlightGroup.append(shadow, overlay);\n\n            return highlightGroup;\n        },\n\n        createFocusHighlight: function(style) {\n            var highlightOptions = this.options.accessibility.highlight;\n            var markers = this.options.markers;\n            var center = this.box.center();\n            var radius = (markers.size + markers.border.width) / 2 + highlightOptions.border.width / 2;\n            var highlight = new Circle(new GeometryCircle([ center.x, center.y ], radius), style);\n\n            return highlight;\n        }\n    });\n\n    Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {\n        labels: {\n            position: CENTER\n        },\n        highlight: {\n            opacity: 1,\n            border: {\n                color: \"#fff\",\n                width: 2,\n                opacity: 1\n            }\n        }\n    });\n\n    Bubble.prototype.defaults.highlight.zIndex = undefined;\n\n    var BubbleChart = ScatterChart.extend({\n        _initFields: function() {\n            this._maxSize = MIN_VALUE;\n            ScatterChart.fn._initFields.call(this);\n        },\n\n        addValue: function(value, fields) {\n            if (value.size !== null && (value.size > 0 || (value.size < 0 && fields.series.negativeValues.visible))) {\n                this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n                ScatterChart.fn.addValue.call(this, value, fields);\n            } else {\n                this.points.push(null);\n                this.seriesPoints[fields.seriesIx].push(null);\n            }\n        },\n\n        reflow: function(box) {\n            this.updateBubblesSize(box);\n            ScatterChart.fn.reflow.call(this, box);\n        },\n\n        pointType: function() {\n            return Bubble;\n        },\n\n        createPoint: function(value, fields) {\n            var series = fields.series;\n            var pointsCount = series.data.length;\n            var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n            var animationOptions = {\n                delay: delay,\n                duration: INITIAL_ANIMATION_DURATION - delay,\n                type: BUBBLE\n            };\n\n            var color = fields.color || series.color;\n            if (value.size < 0 && series.negativeValues.visible) {\n                color = valueOrDefault(\n                    series.negativeValues.color, color\n                );\n            }\n\n            var pointOptions = deepExtend({\n                labels: {\n                    animation: {\n                        delay: delay,\n                        duration: INITIAL_ANIMATION_DURATION - delay\n                    }\n                }\n            }, this.pointOptions(series, fields.seriesIx), {\n                markers: {\n                    type: CIRCLE,\n                    border: series.border,\n                    opacity: series.opacity,\n                    animation: animationOptions\n                }\n            });\n\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n\n            pointOptions.markers.background = color;\n\n            var point = new Bubble(value, pointOptions);\n            point.color = color;\n\n            this.append(point);\n\n            return point;\n        },\n\n        updateBubblesSize: function(box) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var series = ref.options.series;\n            var boxSize = Math.min(box.width(), box.height());\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var seriesPoints = this$1$1.seriesPoints[seriesIx];\n                var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n                var maxSize = currentSeries.maxSize || boxSize * 0.2;\n                var minR = minSize / 2;\n                var maxR = maxSize / 2;\n                var minArea = Math.PI * minR * minR;\n                var maxArea = Math.PI * maxR * maxR;\n                var areaRange = maxArea - minArea;\n                var areaRatio = areaRange / this$1$1._maxSize;\n\n                for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n                    var point = seriesPoints[pointIx];\n                    if (point) {\n                        var area = Math.abs(point.value.size) * areaRatio;\n                        var radius = Math.sqrt((minArea + area) / Math.PI);\n                        var baseZIndex = valueOrDefault(point.options.zIndex, 0);\n                        var zIndex = baseZIndex + (1 - radius / maxR);\n\n                        deepExtend(point.options, {\n                            zIndex: zIndex,\n                            markers: {\n                                size: radius * 2,\n                                zIndex: zIndex\n                            },\n                            labels: {\n                                zIndex: zIndex + 1\n                            }\n                        });\n                    }\n                }\n            }\n        },\n\n        formatPointValue: function(point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n        },\n\n        createAnimation: function() {},\n\n        createVisual: function() {}\n    });\n\n    setDefaultOptions(BubbleChart, {\n        tooltip: {\n            format: \"{3}\"\n        },\n        labels: {\n            format: \"{3}\"\n        }\n    });\n\n    var Target = ShapeElement.extend({\n\n    });\n\n    deepExtend(Target.prototype, PointEventsMixin);\n\n    var Bullet = ChartElement.extend({\n        init: function(value, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.aboveAxis = this.options.aboveAxis;\n            this.color = options.color || WHITE;\n            this.value = value;\n        },\n\n        render: function() {\n            var options = this.options;\n\n            if (!this._rendered) {\n                this._rendered = true;\n\n                if (defined(this.value.target)) {\n                    this.target = new Target({\n                        type: options.target.shape,\n                        background: options.target.color || this.color,\n                        opacity: options.opacity,\n                        zIndex: options.zIndex,\n                        border: options.target.border,\n                        vAlign: TOP,\n                        align: RIGHT\n                    });\n\n                    this.target.value = this.value;\n                    this.target.dataItem = this.dataItem;\n                    this.target.series = this.series;\n\n                    this.append(this.target);\n                }\n\n                this.createLabel();\n                this.createNote();\n            }\n        },\n\n        createLabel: function() {\n            var options = this.options;\n            var labels = options.labels;\n\n            if (labels.visible) {\n                this.label = this.createLabelElement(labels);\n                this.append(this.label);\n            }\n        },\n\n        createLabelElement: function(options) {\n            return new BarLabel(this.getLabelText(options),\n                options,\n                this.pointData());\n        },\n\n        getLabelText: function(options) {\n            var labelTemplate = getTemplate(options);\n\n            if (labelTemplate) {\n                return labelTemplate(this.pointData());\n            }\n\n            return this.formatValue(options.format);\n        },\n\n        reflow: function(box) {\n            this.render();\n\n            var ref = this;\n            var options = ref.options;\n            var target = ref.target;\n            var chart = ref.owner;\n            var invertAxes = options.invertAxes;\n            var valueAxis = chart.seriesValueAxis(this.options);\n            var categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);\n            var targetValueSlot = valueAxis.getSlot(this.value.target);\n            var targetSlotX = invertAxes ? targetValueSlot : categorySlot;\n            var targetSlotY = invertAxes ? categorySlot : targetValueSlot;\n\n            if (target) {\n                var targetSlot = new Box(\n                    targetSlotX.x1, targetSlotY.y1,\n                    targetSlotX.x2, targetSlotY.y2\n                );\n                target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;\n                target.options.width = invertAxes ? options.target.line.width : targetSlot.width();\n                target.reflow(targetSlot);\n            }\n\n            var label = this.label;\n            if (label) {\n                label.options.aboveAxis = this.aboveAxis;\n                label.reflow(box);\n            }\n\n            if (this.note) {\n                this.note.reflow(box);\n            }\n\n            this.box = box;\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            this.addAccessibilityAttributesToVisual();\n\n            var options = this.options;\n            var body = Path.fromRect(this.box.toRect(), {\n                fill: {\n                    color: this.color,\n                    opacity: options.opacity\n                },\n                stroke: null\n            });\n\n            if (options.border.width > 0) {\n                body.options.set(\"stroke\", {\n                    color: options.border.color || this.color,\n                    width: options.border.width,\n                    dashType: options.border.dashType,\n                    opacity: valueOrDefault(options.border.opacity, options.opacity)\n                });\n            }\n\n            this.bodyVisual = body;\n\n            alignPathToPixel(body);\n            this.visual.append(body);\n        },\n\n        createAnimation: function() {\n            if (this.bodyVisual) {\n                this.animation = Animation.create(\n                    this.bodyVisual, this.options.animation\n                );\n            }\n        },\n\n        createHighlight: function(style) {\n            return Path.fromRect(this.box.toRect(), style);\n        },\n\n        highlightVisual: function() {\n            return this.bodyVisual;\n        },\n\n        highlightVisualArgs: function() {\n            return {\n                rect: this.box.toRect(),\n                visual: this.bodyVisual,\n                options: this.options\n            };\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        pointData: function() {\n            return {\n                dataItem: this.dataItem,\n                category: this.category,\n                value: this.value,\n                series: this.series\n            };\n        },\n\n        overlapsBox: function(box) {\n            return this.box.overlaps(box);\n        },\n\n        getIndex: function() {\n            return this.categoryIx;\n        }\n    });\n\n    Bullet.prototype.tooltipAnchor = Bar.prototype.tooltipAnchor;\n    Bullet.prototype.createFocusHighlight = Bar.prototype.createFocusHighlight;\n\n    setDefaultOptions(Bullet, {\n        border: {\n            width: 1\n        },\n        vertical: false,\n        opacity: 1,\n        target: {\n            shape: \"\",\n            border: {\n                width: 0,\n                color: \"green\"\n            },\n            line: {\n                width: 2\n            }\n        },\n        labels: {\n            visible: false\n        },\n        tooltip: {\n            format: \"Current: {0}<br />Target: {1}\"\n        },\n        notes: {\n            label: {}\n        },\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    });\n\n    deepExtend(Bullet.prototype, PointEventsMixin);\n    deepExtend(Bullet.prototype, NoteMixin);\n    deepExtend(Bullet.prototype, AccessibilityAttributesMixin);\n\n    var BulletChart = CategoricalChart.extend({\n        init: function(plotArea, options) {\n\n            wrapData(options);\n\n            CategoricalChart.fn.init.call(this, plotArea, options);\n        },\n\n        reflowCategories: function(categorySlots) {\n            var children = this.children;\n            var childrenLength = children.length;\n\n            for (var i = 0; i < childrenLength; i++) {\n                children[i].reflow(categorySlots[i]);\n            }\n        },\n\n        plotRange: function(point) {\n            var series = point.series;\n            var valueAxis = this.seriesValueAxis(series);\n            var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n            return [ axisCrossingValue, point.value.current || axisCrossingValue ];\n        },\n\n        createPoint: function(data, fields) {\n            var categoryIx = fields.categoryIx;\n            var series = fields.series;\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var value = data.valueFields;\n\n            var bulletOptions = deepExtend({\n                vertical: !options.invertAxes,\n                overlay: series.overlay,\n                categoryIx: categoryIx,\n                invertAxes: options.invertAxes\n            }, series);\n\n            var color = data.fields.color || series.color;\n            bulletOptions = this.evalPointOptions(bulletOptions, value, fields);\n            if (isFunction(series.color)) {\n                color = bulletOptions.color;\n            }\n\n            var bullet = new Bullet(value, bulletOptions);\n            bullet.color = color;\n\n            var cluster = children[categoryIx];\n            if (!cluster) {\n                cluster = new ClusterLayout({\n                    vertical: options.invertAxes,\n                    gap: options.gap,\n                    spacing: options.spacing,\n                    rtl: !options.invertAxes && (this.chartService || {}).rtl\n                });\n                this.append(cluster);\n            }\n\n            cluster.append(bullet);\n\n            return bullet;\n        },\n\n        updateRange: function(value, fields) {\n            var current = value.current;\n            var target = value.target;\n            var axisName = fields.series.axis;\n            var axisRange = this.valueAxisRanges[axisName];\n\n            if (defined(current) && !isNaN(current) && defined(target && !isNaN(target))) {\n                axisRange = this.valueAxisRanges[axisName] =\n                    axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n                axisRange.min = Math.min(axisRange.min, current, target);\n                axisRange.max = Math.max(axisRange.max, current, target);\n            }\n        },\n\n        formatPointValue: function(point, format) {\n            return this.chartService.format.auto(format, point.value.current, point.value.target);\n        },\n\n        pointValue: function(data) {\n            return data.valueFields.current;\n        },\n\n        aboveAxis: function(point) {\n            var value = point.value.current;\n\n            return value > 0;\n        },\n\n        createAnimation: function() {\n            var this$1$1 = this;\n\n            var points = this.points;\n\n            this._setAnimationOptions();\n\n            for (var idx = 0; idx < points.length; idx++) {\n                var point = points[idx];\n                point.options.animation = this$1$1.options.animation;\n                point.createAnimation();\n            }\n        }\n    });\n\n    BulletChart.prototype._setAnimationOptions = BarChart.prototype._setAnimationOptions;\n\n    setDefaultOptions(BulletChart, {\n        animation: {\n            type: BAR\n        }\n    });\n\n    function wrapData(options) {\n        var series = options.series;\n\n        for (var i = 0; i < series.length; i++) {\n            var seriesItem = series[i];\n            var data = seriesItem.data;\n            if (data && !isArray(data[0]) && !isObject(data[0])) {\n                seriesItem.data = [ data ];\n            }\n        }\n    }\n\n    var BaseTooltip = Class.extend({\n        init: function(chartService, options) {\n\n            this.chartService = chartService;\n            this.options = deepExtend({}, this.options, options);\n        },\n\n        getStyle: function(options, point) {\n            var background = options.background;\n            var border = options.border.color;\n\n            if (point) {\n                var pointColor = point.color || point.options.color;\n                background = valueOrDefault(background, pointColor);\n                border = valueOrDefault(border, pointColor);\n            }\n\n            var padding = getSpacing(options.padding || {}, \"auto\");\n\n            return {\n                backgroundColor: background,\n                borderColor: border,\n                font: options.font,\n                color: options.color,\n                opacity: options.opacity,\n                borderWidth: styleValue(options.border.width),\n                paddingTop: styleValue(padding.top),\n                paddingBottom: styleValue(padding.bottom),\n                paddingLeft: styleValue(padding.left),\n                paddingRight: styleValue(padding.right)\n            };\n        },\n\n        show: function(options, tooltipOptions, point) {\n            options.format = tooltipOptions.format;\n\n            var style = this.getStyle(tooltipOptions, point);\n            options.style = style;\n\n            var background = new Color(style.backgroundColor);\n            if (!defined(tooltipOptions.color) && !background.isDark()) {\n                options.className = \"k-chart-tooltip-inverse\";\n            }\n\n            this.chartService.notify(SHOW_TOOLTIP, options);\n\n            this.visible = true;\n        },\n\n        hide: function() {\n            if (this.chartService) {\n                this.chartService.notify(HIDE_TOOLTIP);\n            }\n\n            this.visible = false;\n        },\n\n        destroy: function() {\n            delete this.chartService;\n        }\n    });\n\n    setDefaultOptions(BaseTooltip, {\n        border: {\n            width: 1\n        },\n        opacity: 1\n    });\n\n    var CrosshairTooltip = BaseTooltip.extend({\n        init: function(chartService, crosshair, options) {\n            BaseTooltip.fn.init.call(this, chartService, options);\n\n            this.crosshair = crosshair;\n            this.formatService = chartService.format;\n            this.initAxisName();\n        },\n\n        initAxisName: function() {\n            var axis = this.crosshair.axis;\n            var plotArea = axis.plotArea;\n            var name;\n            if (plotArea.categoryAxis) {\n                name = axis.getCategory ? \"categoryAxis\" : \"valueAxis\";\n            } else {\n                name = axis.options.vertical ? \"yAxis\" : \"xAxis\";\n            }\n            this.axisName = name;\n        },\n\n        showAt: function(point) {\n            var ref = this;\n            var axis = ref.crosshair.axis;\n            var options = ref.options;\n            var value = axis[options.stickyMode ? \"getCategory\" : \"getValue\"](point);\n            var formattedValue = value;\n\n            if (options.format) {\n                formattedValue = this.formatService.auto(options.format, value);\n            } else if (axis.options.type === DATE) {\n                formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\n            }\n\n            this.show({\n                point: point,\n                anchor: this.getAnchor(),\n                crosshair: this.crosshair,\n                value: formattedValue,\n                axisName: this.axisName,\n                axisIndex: this.crosshair.axis.axisIndex\n            }, this.options);\n        },\n\n        hide: function() {\n            this.chartService.notify(HIDE_TOOLTIP, {\n                crosshair: this.crosshair,\n                axisName: this.axisName,\n                axisIndex: this.crosshair.axis.axisIndex\n            });\n        },\n\n        getAnchor: function() {\n            var ref = this;\n            var crosshair = ref.crosshair;\n            var ref_options = ref.options;\n            var position = ref_options.position;\n            var padding = ref_options.padding;\n            var vertical = !crosshair.axis.options.vertical;\n            var lineBox = crosshair.line.bbox();\n            var horizontalAlign, verticalAlign, point;\n\n            if (vertical) {\n                horizontalAlign = CENTER;\n                if (position === BOTTOM) {\n                    verticalAlign = TOP;\n                    point = lineBox.bottomLeft().translate(0, padding);\n                } else {\n                    verticalAlign = BOTTOM;\n                    point = lineBox.topLeft().translate(0, -padding);\n                }\n            } else {\n                verticalAlign = CENTER;\n                if (position === LEFT) {\n                    horizontalAlign = RIGHT;\n                    point = lineBox.topLeft().translate(-padding, 0);\n                } else {\n                    horizontalAlign = LEFT;\n                    point = lineBox.topRight().translate(padding, 0);\n                }\n            }\n\n            return {\n                point: point,\n                align: {\n                    horizontal: horizontalAlign,\n                    vertical: verticalAlign\n                }\n            };\n        }\n    });\n\n    setDefaultOptions(CrosshairTooltip, {\n        padding: 10\n    });\n\n    var Crosshair = ChartElement.extend({\n        init: function(chartService, axis, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.axis = axis;\n            this.stickyMode = axis instanceof CategoryAxis;\n\n            var tooltipOptions = this.options.tooltip;\n\n            if (tooltipOptions.visible) {\n                this.tooltip = new CrosshairTooltip(chartService, this,\n                    deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })\n                );\n            }\n        },\n\n        showAt: function(point) {\n            this.point = point;\n            this.moveLine();\n            this.line.visible(true);\n\n            if (this.tooltip) {\n                this.tooltip.showAt(point);\n            }\n        },\n\n        hide: function() {\n            this.line.visible(false);\n\n            if (this.tooltip) {\n                this.tooltip.hide();\n            }\n        },\n\n        moveLine: function() {\n            var ref = this;\n            var axis = ref.axis;\n            var point = ref.point;\n            var vertical = axis.options.vertical;\n            var box = this.getBox();\n            var dim = vertical ? Y : X;\n            var lineStart = new GeometryPoint(box.x1, box.y1);\n            var lineEnd;\n\n            if (vertical) {\n                lineEnd = new GeometryPoint(box.x2, box.y1);\n            } else {\n                lineEnd = new GeometryPoint(box.x1, box.y2);\n            }\n\n            if (point) {\n                if (this.stickyMode) {\n                    var slot = axis.getSlot(axis.pointCategoryIndex(point));\n                    lineStart[dim] = lineEnd[dim] = slot.center()[dim];\n                } else {\n                    lineStart[dim] = lineEnd[dim] = point[dim];\n                }\n            }\n\n            this.box = box;\n\n            this.line.moveTo(lineStart).lineTo(lineEnd);\n        },\n\n        getBox: function() {\n            var axis = this.axis;\n            var axes = axis.pane.axes;\n            var length = axes.length;\n            var vertical = axis.options.vertical;\n            var box = axis.lineBox().clone();\n            var dim = vertical ? X : Y;\n            var axisLineBox;\n\n            for (var i = 0; i < length; i++) {\n                var currentAxis = axes[i];\n                if (currentAxis.options.vertical !== vertical) {\n                    if (!axisLineBox) {\n                        axisLineBox = currentAxis.lineBox().clone();\n                    } else {\n                        axisLineBox.wrap(currentAxis.lineBox());\n                    }\n                }\n            }\n\n            box[dim + 1] = axisLineBox[dim + 1];\n            box[dim + 2] = axisLineBox[dim + 2];\n\n            return box;\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            var options = this.options;\n            this.line = new Path({\n                stroke: {\n                    color: options.color,\n                    width: options.width,\n                    opacity: options.opacity,\n                    dashType: options.dashType\n                },\n                visible: false\n            });\n\n            this.moveLine();\n            this.visual.append(this.line);\n        },\n\n        destroy: function() {\n            if (this.tooltip) {\n                this.tooltip.destroy();\n            }\n\n            ChartElement.fn.destroy.call(this);\n        }\n    });\n\n    setDefaultOptions(Crosshair, {\n        color: BLACK,\n        width: 2,\n        zIndex: -1,\n        tooltip: {\n            visible: false\n        }\n    });\n\n    var ChartContainer = ChartElement.extend({\n        init: function(options, pane) {\n            ChartElement.fn.init.call(this, options);\n            this.pane = pane;\n        },\n\n        shouldClip: function() {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n                if (children[i].options.clip === true) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        _clipBox: function() {\n            return this.pane.chartsBox();\n        },\n\n        createVisual: function() {\n            this.visual = new Group({\n                zIndex: 0\n            });\n\n            if (this.shouldClip()) {\n                var clipBox = this.clipBox = this._clipBox();\n                var clipRect = clipBox.toRect();\n                var clipPath = Path.fromRect(clipRect);\n                alignPathToPixel(clipPath);\n\n                this.visual.clip(clipPath);\n                this.unclipLabels();\n            }\n        },\n\n        stackRoot: function() {\n            return this;\n        },\n\n        unclipLabels: function() {\n            var ref = this;\n            var charts = ref.children;\n            var clipBox = ref.clipBox;\n\n            for (var i = 0; i < charts.length; i++) {\n                var points = charts[i].points || {};\n                var length = points.length;\n\n                for (var j = 0; j < length; j++) {\n                    var point = points[j];\n                    if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\n                        if (point.unclipElements) {\n                            point.unclipElements();\n                        } else {\n                            var label = point.label;\n                            var note = point.note;\n\n                            if (label && label.options.visible) {\n                                if (label.alignToClipBox) {\n                                    label.alignToClipBox(clipBox);\n                                }\n                                label.options.noclip = true;\n                            }\n\n                            if (note && note.options.visible) {\n                                note.options.noclip = true;\n                            }\n                        }\n                    }\n                }\n            }\n        },\n\n        destroy: function() {\n            ChartElement.fn.destroy.call(this);\n\n            delete this.parent;\n        }\n    });\n\n    ChartContainer.prototype.isStackRoot = true;\n\n    var Pane = BoxElement.extend({\n        init: function(options) {\n            BoxElement.fn.init.call(this, options);\n\n            this.id = paneID();\n\n            this.createTitle();\n\n            this.content = new ChartElement();\n\n            this.chartContainer = new ChartContainer({}, this);\n            this.append(this.content);\n\n            this.axes = [];\n            this.charts = [];\n        },\n\n        createTitle: function() {\n            var titleOptions = this.options.title;\n            if (isObject(titleOptions)) {\n                titleOptions = deepExtend({}, titleOptions, {\n                    align: titleOptions.position,\n                    position: TOP\n                });\n            }\n\n            this.title = Title.buildTitle(titleOptions, Pane.prototype.options.title);\n            if (this.title) {\n                this.append(this.title);\n            }\n        },\n\n        appendAxis: function(axis) {\n            this.content.append(axis);\n            this.axes.push(axis);\n            axis.pane = this;\n        },\n\n        appendAxisAt: function(axis, pos) {\n            this.content.append(axis);\n            this.axes.splice(pos, 0, axis);\n            axis.pane = this;\n        },\n\n        appendChart: function(chart) {\n            if (this.chartContainer.parent !== this.content) {\n                this.content.append(this.chartContainer);\n            }\n\n            this.charts.push(chart);\n            this.chartContainer.append(chart);\n            chart.pane = this;\n        },\n\n        empty: function() {\n            var this$1$1 = this;\n\n            var plotArea = this.parent;\n\n            if (plotArea) {\n                for (var i = 0; i < this.axes.length; i++) {\n                    plotArea.removeAxis(this$1$1.axes[i]);\n                }\n\n                for (var i$1 = 0; i$1 < this.charts.length; i$1++) {\n                    plotArea.removeChart(this$1$1.charts[i$1]);\n                }\n            }\n\n            this.axes = [];\n            this.charts = [];\n\n            this.content.destroy();\n            this.content.children = [];\n            this.chartContainer.children = [];\n        },\n\n        reflow: function(targetBox) {\n            // Content (such as charts) is rendered, but excluded from reflows\n            var content;\n            if (last(this.children) === this.content) {\n                content = this.children.pop();\n            }\n\n            BoxElement.fn.reflow.call(this, targetBox);\n\n            if (content) {\n                this.children.push(content);\n            }\n\n            if (this.title) {\n                this.contentBox.y1 += this.title.box.height();\n            }\n        },\n\n        visualStyle: function() {\n            var style = BoxElement.fn.visualStyle.call(this);\n            style.zIndex = -10;\n\n            return style;\n        },\n\n        renderComplete: function() {\n            if (this.options.visible) {\n                this.createGridLines();\n            }\n        },\n\n        stackRoot: function() {\n            return this;\n        },\n\n        clipRoot: function() {\n            return this;\n        },\n\n        createGridLines: function() {\n            var axes = this.axes;\n            var allAxes = axes.concat(this.parent.axes);\n            var vGridLines = [];\n            var hGridLines = [];\n\n            // TODO\n            // Is full combination really necessary?\n            for (var i = 0; i < axes.length; i++) {\n                var axis = axes[i];\n                var vertical = axis.options.vertical;\n                var gridLines = vertical ? vGridLines : hGridLines;\n                for (var j = 0; j < allAxes.length; j++) {\n                    if (gridLines.length === 0) {\n                        var altAxis = allAxes[j];\n                        if (vertical !== altAxis.options.vertical) {\n                            append(gridLines, axis.createGridLines(altAxis));\n                        }\n                    }\n                }\n            }\n        },\n\n        refresh: function() {\n            this.visual.clear();\n\n            this.content.parent = null;\n            this.content.createGradient = this.createGradient.bind(this);\n            this.content.renderVisual();\n            this.content.parent = this;\n\n            if (this.title) {\n                this.visual.append(this.title.visual);\n            }\n\n            this.visual.append(this.content.visual);\n\n            this.renderComplete();\n            this.notifyRender();\n        },\n\n        chartsBox: function() {\n            var axes = this.axes;\n            var length = axes.length;\n            var chartsBox = new Box();\n\n            for (var idx = 0; idx < length; idx++) {\n                var axis = axes[idx];\n                var axisValueField = axis.options.vertical ? Y : X;\n                var lineBox = axis.lineBox();\n                chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];\n                chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];\n            }\n\n            if (chartsBox.x2 === 0) {\n                var allAxes = this.parent.axes;\n                var length$1 = allAxes.length;\n\n                for (var idx$1 = 0; idx$1 < length$1; idx$1++) {\n                    var axis$1 = allAxes[idx$1];\n                    if (!axis$1.options.vertical) {\n                        var lineBox$1 = axis$1.lineBox();\n                        chartsBox.x1 = lineBox$1.x1;\n                        chartsBox.x2 = lineBox$1.x2;\n                    }\n                }\n            }\n            return chartsBox;\n        },\n\n        clipBox: function() {\n            return this.chartContainer.clipBox;\n        },\n\n        notifyRender: function() {\n            var service = this.getService();\n            if (service) {\n                service.notify(PANE_RENDER, {\n                    pane: new ChartPane(this),\n                    index: this.paneIndex,\n                    name: this.options.name\n                });\n            }\n        }\n    });\n\n    var ID = 1;\n\n    function paneID() {\n        return \"pane\" + ID++;\n    }\n\n    Pane.prototype.isStackRoot = true;\n\n    setDefaultOptions(Pane, {\n        zIndex: -1,\n        shrinkToFit: true,\n        title: {\n            align: LEFT\n        },\n        visible: true\n    });\n\n    var PlotAreaBase = ChartElement.extend({\n        init: function(series, options, chartService) {\n            ChartElement.fn.init.call(this, options);\n\n            this.initFields(series, options);\n            this.series = series;\n            this.initSeries();\n            this.charts = [];\n            this.options.legend = this.options.legend || {};\n            this.options.legend.data = [];\n            this.axes = [];\n            this.crosshairs = [];\n            this.chartService = chartService;\n            this.originalOptions = options;\n            this.originalSeries = series;\n            this._bindCache = new WeakMap();\n\n            this.createPanes();\n            this.render();\n            this.createCrosshairs();\n        },\n\n        initFields: function() { },\n\n        initSeries: function() {\n            var series = this.series;\n\n            for (var i = 0; i < series.length; i++) {\n                series[i].index = i;\n            }\n        },\n\n        bindPoint: function(series, pointIx, item) {\n            var cached = this._bindCache.get(series);\n            if (!cached) {\n                cached = [];\n                this._bindCache.set(series, cached);\n            }\n\n            var data = cached[pointIx];\n            if (!data) {\n                data = cached[pointIx] = SeriesBinder.current.bindPoint(series, pointIx, item);\n            }\n\n            return data;\n        },\n\n        createPanes: function() {\n            var this$1$1 = this;\n\n            var titleOptions = this.options.title || {};\n            var paneDefaults = this.options.paneDefaults;\n            var paneOptions = this.options.panes || [];\n            var panesLength = Math.max(paneOptions.length, 1);\n            var panes = [];\n\n            var defaults = deepExtend({\n                title: {\n                    color: titleOptions.color\n                }\n            }, paneDefaults);\n\n            for (var i = 0; i < panesLength; i++) {\n                var options = deepExtend({}, defaults, paneOptions[i]);\n                if (isString(options.title)) {\n                    options.title = deepExtend({ text: options.title }, defaults.title);\n                }\n\n                var currentPane = new Pane(options);\n                currentPane.paneIndex = i;\n\n                panes.push(currentPane);\n                this$1$1.append(currentPane);\n            }\n\n            this.panes = panes;\n        },\n\n        crosshairOptions: function(axis) {\n            return axis.options.crosshair;\n        },\n\n        createCrosshairs: function(panes) {\n            var this$1$1 = this;\n            if (panes === void 0) { panes = this.panes; }\n\n            for (var i = 0; i < panes.length; i++) {\n                var pane = panes[i];\n                for (var j = 0; j < pane.axes.length; j++) {\n                    var axis = pane.axes[j];\n                    var options = this$1$1.crosshairOptions(axis);\n                    if (options && options.visible) {\n                        var currentCrosshair = new Crosshair(this$1$1.chartService, axis, options);\n\n                        this$1$1.crosshairs.push(currentCrosshair);\n                        pane.content.append(currentCrosshair);\n                    }\n                }\n            }\n        },\n\n        removeCrosshairs: function(pane) {\n            var crosshairs = this.crosshairs;\n            var axes = pane.axes;\n\n            for (var i = crosshairs.length - 1; i >= 0; i--) {\n                for (var j = 0; j < axes.length; j++) {\n                    if (crosshairs[i].axis === axes[j]) {\n                        crosshairs.splice(i, 1);\n                        break;\n                    }\n                }\n            }\n        },\n\n        hideCrosshairs: function() {\n            var crosshairs = this.crosshairs;\n            for (var idx = 0; idx < crosshairs.length; idx++) {\n                crosshairs[idx].hide();\n            }\n        },\n\n        findPane: function(name) {\n            var panes = this.panes;\n            var matchingPane;\n\n            for (var i = 0; i < panes.length; i++) {\n                if (panes[i].options.name === name) {\n                    matchingPane = panes[i];\n                    break;\n                }\n            }\n\n            return matchingPane || panes[0];\n        },\n\n        findPointPane: function(point) {\n            var panes = this.panes;\n            var matchingPane;\n\n            for (var i = 0; i < panes.length; i++) {\n                if (panes[i].box.containsPoint(point)) {\n                    matchingPane = panes[i];\n                    break;\n                }\n            }\n\n            return matchingPane;\n        },\n\n        appendAxis: function(axis) {\n            var pane = this.findPane(axis.options.pane);\n\n            pane.appendAxis(axis);\n            this.axes.push(axis);\n            axis.plotArea = this;\n        },\n\n        removeAxis: function(axisToRemove) {\n            var this$1$1 = this;\n\n            var filteredAxes = [];\n\n            for (var i = 0; i < this.axes.length; i++) {\n                var axis = this$1$1.axes[i];\n                if (axisToRemove !== axis) {\n                    filteredAxes.push(axis);\n                } else {\n                    axis.destroy();\n                }\n            }\n\n            this.axes = filteredAxes;\n        },\n\n        appendChart: function(chart, pane) {\n            this.charts.push(chart);\n            if (pane) {\n                pane.appendChart(chart);\n            } else {\n                this.append(chart);\n            }\n        },\n\n        removeChart: function(chartToRemove) {\n            var this$1$1 = this;\n\n            var filteredCharts = [];\n\n            for (var i = 0; i < this.charts.length; i++) {\n                var chart = this$1$1.charts[i];\n                if (chart !== chartToRemove) {\n                    filteredCharts.push(chart);\n                } else {\n                    chart.destroy();\n                }\n            }\n\n            this.charts = filteredCharts;\n        },\n\n        addToLegend: function(series) {\n            var count = series.length;\n            var legend = this.options.legend;\n            var labels = legend.labels || {};\n            var inactiveItems = legend.inactiveItems || {};\n            var inactiveItemsLabels = inactiveItems.labels || {};\n            var data = [];\n\n            for (var i = 0; i < count; i++) {\n                var currentSeries = series[i];\n                var seriesVisible = currentSeries.visible !== false;\n                if (currentSeries.visibleInLegend === false) {\n                    continue;\n                }\n\n                var text = currentSeries.name;\n                var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n                if (labelTemplate) {\n                    text = labelTemplate({\n                        text: hasValue(text) ? text : \"\",\n                        series: currentSeries\n                    });\n                }\n\n                var defaults = currentSeries._defaults;\n                var color = currentSeries.color;\n                if (isFunction(color) && defaults) {\n                    color = defaults.color;\n                }\n\n                var itemLabelOptions = (void 0), markerColor = (void 0);\n                if (seriesVisible) {\n                    itemLabelOptions = {};\n                    markerColor = color;\n                } else {\n                    itemLabelOptions = {\n                        color: inactiveItemsLabels.color,\n                        font: inactiveItemsLabels.font\n                    };\n                    markerColor = inactiveItems.markers.color;\n                }\n\n                if (hasValue(text) && text !== \"\") {\n                    data.push({\n                        text: text,\n                        labels: itemLabelOptions,\n                        markerColor: markerColor,\n                        series: currentSeries,\n                        active: seriesVisible\n                    });\n                }\n            }\n\n            append(legend.data, data);\n        },\n\n        groupAxes: function(panes) {\n            var xAxes = [];\n            var yAxes = [];\n\n            for (var paneIx = 0; paneIx < panes.length; paneIx++) {\n                var paneAxes = panes[paneIx].axes;\n                for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n                    var axis = paneAxes[axisIx];\n                    if (axis.options.vertical) {\n                        yAxes.push(axis);\n                    } else {\n                        xAxes.push(axis);\n                    }\n                }\n            }\n\n            return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };\n        },\n\n        groupSeriesByPane: function() {\n            var this$1$1 = this;\n\n            var series = this.series;\n            var seriesByPane = {};\n\n            for (var i = 0; i < series.length; i++) {\n                var currentSeries = series[i];\n                var pane = this$1$1.seriesPaneName(currentSeries);\n\n                if (seriesByPane[pane]) {\n                    seriesByPane[pane].push(currentSeries);\n                } else {\n                    seriesByPane[pane] = [ currentSeries ];\n                }\n            }\n\n            return seriesByPane;\n        },\n\n        filterVisibleSeries: function(series) {\n            var result = [];\n\n            for (var i = 0; i < series.length; i++) {\n                var currentSeries = series[i];\n                if (currentSeries.visible !== false) {\n                    result.push(currentSeries);\n                }\n            }\n\n            return result;\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options.plotArea;\n            var panes = this.panes;\n            var margin = getSpacing(options.margin);\n\n            this.box = targetBox.clone().unpad(margin);\n            this.reflowPanes();\n\n            this.detachLabels();\n            this.reflowAxes(panes);\n            this.reflowCharts(panes);\n        },\n\n        redraw: function(panes) {\n            var this$1$1 = this;\n\n            var panesArray = [].concat(panes);\n            this.initSeries();\n\n            //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n            var root = this.getRoot();\n            if (root) {\n                root.cleanGradients();\n            }\n\n            for (var i = 0; i < panesArray.length; i++) {\n                this$1$1.removeCrosshairs(panesArray[i]);\n                panesArray[i].empty();\n            }\n\n            this._bindCache = new WeakMap();\n\n            this.render(panesArray);\n            this.detachLabels();\n            this.reflowAxes(this.panes);\n            this.reflowCharts(panesArray);\n\n            this.createCrosshairs(panesArray);\n\n            for (var i$1 = 0; i$1 < panesArray.length; i$1++) {\n                panesArray[i$1].refresh();\n            }\n        },\n\n        axisCrossingValues: function(axis, crossingAxes) {\n            var options = axis.options;\n            var crossingValues = [].concat(\n                options.axisCrossingValues || options.axisCrossingValue\n            );\n            var valuesToAdd = crossingAxes.length - crossingValues.length;\n            var defaultValue = crossingValues[0] || 0;\n\n            for (var i = 0; i < valuesToAdd; i++) {\n                crossingValues.push(defaultValue);\n            }\n\n            return crossingValues;\n        },\n\n        alignAxisTo: function(axis, targetAxis, crossingValue, targetCrossingValue) {\n            var slot = axis.getSlot(crossingValue, crossingValue, true);\n            var slotEdge = axis.options.reverse ? 2 : 1;\n            var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n            var targetEdge = targetAxis.options.reverse ? 2 : 1;\n            var axisBox = axis.box.translate(\n                targetSlot[X + targetEdge] - slot[X + slotEdge],\n                targetSlot[Y + targetEdge] - slot[Y + slotEdge]\n            );\n\n            if (axis.pane !== targetAxis.pane) {\n                axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n            }\n\n            axis.reflow(axisBox);\n        },\n\n        alignAxes: function(xAxes, yAxes) {\n            var this$1$1 = this;\n\n            var xAnchor = xAxes[0];\n            var yAnchor = yAxes[0];\n            var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n            var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n            var leftAnchors = {};\n            var rightAnchors = {};\n            var topAnchors = {};\n            var bottomAnchors = {};\n\n            for (var i = 0; i < yAxes.length; i++) {\n                var axis = yAxes[i];\n                var pane = axis.pane;\n                var paneId = pane.id;\n                var visible = axis.options.visible !== false;\n\n                // Locate pane anchor, if any, and use its axisCrossingValues\n                var anchor = paneAnchor(xAxes, pane) || xAnchor;\n                var anchorCrossings = xAnchorCrossings;\n\n                if (anchor !== xAnchor) {\n                    anchorCrossings = this$1$1.axisCrossingValues(anchor, yAxes);\n                }\n\n                this$1$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n                if (axis.options._overlap) {\n                    continue;\n                }\n\n                if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n                    // Push the axis to the left the previous y-axis so they don't overlap\n                    if (leftAnchors[paneId]) {\n                        axis.reflow(axis.box\n                            .alignTo(leftAnchors[paneId].box, LEFT)\n                            .translate(-axis.options.margin, 0)\n                        );\n                    }\n\n                    if (visible) {\n                        leftAnchors[paneId] = axis;\n                    }\n                }\n\n                if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n                    // Flip the labels on the right if we're at the right end of the pane\n                    if (!axis._mirrored) {\n                        axis.options.labels.mirror = !axis.options.labels.mirror;\n                        axis._mirrored = true;\n                    }\n\n                    this$1$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n                    // Push the axis to the right the previous y-axis so they don't overlap\n                    if (rightAnchors[paneId]) {\n                        axis.reflow(axis.box\n                            .alignTo(rightAnchors[paneId].box, RIGHT)\n                            .translate(axis.options.margin, 0)\n                        );\n                    }\n\n                    if (visible) {\n                        rightAnchors[paneId] = axis;\n                    }\n                }\n\n                // Locate pane anchor, if any, and align the axis to it\n                var paneYAnchor = paneAnchor(yAxes, pane) || yAnchor;\n                if (paneYAnchor !== axis) {\n                    axis.alignTo(paneYAnchor);\n                    axis.reflow(axis.box);\n                }\n            }\n\n            for (var i$1 = 0; i$1 < xAxes.length; i$1++) {\n                var axis$1 = xAxes[i$1];\n                var pane$1 = axis$1.pane;\n                var paneId$1 = pane$1.id;\n                var visible$1 = axis$1.options.visible !== false;\n\n                // Locate pane anchor and use its axisCrossingValues\n                var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;\n                var anchorCrossings$1 = yAnchorCrossings;\n                if (anchor$1 !== yAnchor) {\n                    anchorCrossings$1 = this$1$1.axisCrossingValues(anchor$1, xAxes);\n                }\n\n                this$1$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\n\n                if (axis$1.options._overlap) {\n                    continue;\n                }\n\n                if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {\n                    // Flip the labels on top if we're at the top of the pane\n                    if (!axis$1._mirrored) {\n                        axis$1.options.labels.mirror = !axis$1.options.labels.mirror;\n                        axis$1._mirrored = true;\n                    }\n                    this$1$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\n\n                    // Push the axis above the previous x-axis so they don't overlap\n                    if (topAnchors[paneId$1]) {\n                        axis$1.reflow(axis$1.box\n                            .alignTo(topAnchors[paneId$1].box, TOP)\n                            .translate(0, -axis$1.options.margin)\n                        );\n                    }\n\n                    if (visible$1) {\n                        topAnchors[paneId$1] = axis$1;\n                    }\n                }\n\n                if (round(axis$1.lineBox().y2, COORD_PRECISION) === round(anchor$1.lineBox().y2, COORD_PRECISION)) {\n                    // Push the axis below the previous x-axis so they don't overlap\n                    if (bottomAnchors[paneId$1]) {\n                        axis$1.reflow(axis$1.box\n                            .alignTo(bottomAnchors[paneId$1].box, BOTTOM)\n                            .translate(0, axis$1.options.margin)\n                        );\n                    }\n\n                    if (visible$1) {\n                        bottomAnchors[paneId$1] = axis$1;\n                    }\n                }\n\n                if (i$1 !== 0) {\n                    axis$1.alignTo(xAnchor);\n                    axis$1.reflow(axis$1.box);\n                }\n            }\n        },\n\n        shrinkAxisWidth: function(panes) {\n            var axes = this.groupAxes(panes).any;\n            var axisBox = axisGroupBox(axes);\n            var overflowX = 0;\n\n            for (var i = 0; i < panes.length; i++) {\n                var currentPane = panes[i];\n\n                if (currentPane.axes.length > 0) {\n                    overflowX = Math.max(\n                        overflowX,\n                        axisBox.width() - currentPane.contentBox.width()\n                    );\n                }\n            }\n\n            if (overflowX !== 0) {\n                for (var i$1 = 0; i$1 < axes.length; i$1++) {\n                    var currentAxis = axes[i$1];\n\n                    if (!currentAxis.options.vertical) {\n                        currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n                    }\n                }\n            }\n        },\n\n        shrinkAxisHeight: function(panes) {\n            var shrinked;\n\n            for (var i = 0; i < panes.length; i++) {\n                var currentPane = panes[i];\n                var axes = currentPane.axes;\n                var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n                if (overflowY !== 0) {\n                    for (var j = 0; j < axes.length; j++) {\n                        var currentAxis = axes[j];\n\n                        if (currentAxis.options.vertical) {\n                            currentAxis.reflow(\n                                currentAxis.box.shrink(0, overflowY)\n                            );\n                        }\n                    }\n                    shrinked = true;\n                }\n            }\n\n            return shrinked;\n        },\n\n        fitAxes: function(panes) {\n            var axes = this.groupAxes(panes).any;\n            var offsetX = 0;\n\n            for (var i = 0; i < panes.length; i++) {\n                var currentPane = panes[i];\n                var paneAxes = currentPane.axes;\n                var paneBox = currentPane.contentBox;\n\n                if (paneAxes.length > 0) {\n                    var axisBox = axisGroupBox(paneAxes);\n                    // OffsetY is calculated and applied per pane\n                    var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);\n\n                    // OffsetX is calculated and applied globally\n                    offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n                    for (var j = 0; j < paneAxes.length; j++) {\n                        var currentAxis = paneAxes[j];\n\n                        currentAxis.reflow(\n                            currentAxis.box.translate(0, offsetY)\n                        );\n                    }\n                }\n            }\n\n            for (var i$1 = 0; i$1 < axes.length; i$1++) {\n                var currentAxis$1 = axes[i$1];\n\n                currentAxis$1.reflow(\n                    currentAxis$1.box.translate(offsetX, 0)\n                );\n            }\n        },\n\n        reflowAxes: function(panes) {\n            var this$1$1 = this;\n\n            var axes = this.groupAxes(panes);\n\n            for (var i = 0; i < panes.length; i++) {\n                this$1$1.reflowPaneAxes(panes[i]);\n            }\n\n            if (axes.x.length > 0 && axes.y.length > 0) {\n                this.alignAxes(axes.x, axes.y);\n                this.shrinkAxisWidth(panes);\n\n                this.autoRotateAxisLabels(axes);\n\n                this.alignAxes(axes.x, axes.y);\n                if (this.shrinkAxisWidth(panes)) {\n                    this.alignAxes(axes.x, axes.y);\n                }\n\n                this.shrinkAxisHeight(panes);\n                this.alignAxes(axes.x, axes.y);\n\n                if (this.shrinkAxisHeight(panes)) {\n                    this.alignAxes(axes.x, axes.y);\n                }\n\n                this.fitAxes(panes);\n            }\n        },\n\n        autoRotateAxisLabels: function(groupedAxes) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var panes = ref.panes;\n            var axes = allPaneAxes(panes);\n            var rotated;\n\n            for (var idx = 0; idx < axes.length; idx++) {\n                var axis = axes[idx];\n                if (axis.autoRotateLabels()) {\n                    rotated = true;\n                }\n            }\n\n            if (rotated) {\n                for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {\n                    this$1$1.reflowPaneAxes(panes[idx$1]);\n                }\n\n                if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n                    this.alignAxes(groupedAxes.x, groupedAxes.y);\n                    this.shrinkAxisWidth(panes);\n                }\n            }\n        },\n\n        reflowPaneAxes: function(pane) {\n            var axes = pane.axes;\n            var length = axes.length;\n\n            if (length > 0) {\n                for (var i = 0; i < length; i++) {\n                    axes[i].reflow(pane.contentBox);\n                }\n            }\n        },\n\n        reflowCharts: function(panes) {\n            var charts = this.charts;\n            var count = charts.length;\n            var box = this.box;\n\n            for (var i = 0; i < count; i++) {\n                var chartPane = charts[i].pane;\n                if (!chartPane || inArray(chartPane, panes)) {\n                    charts[i].reflow(box);\n                }\n            }\n        },\n\n        reflowPanes: function() {\n            var ref = this;\n            var box = ref.box;\n            var panes = ref.panes;\n            var panesLength = panes.length;\n            var remainingHeight = box.height();\n            var autoHeightPanes = 0;\n            var top = box.y1;\n\n            for (var i = 0; i < panesLength; i++) {\n                var currentPane = panes[i];\n                var height = currentPane.options.height;\n\n                currentPane.options.width = box.width();\n\n                if (!currentPane.options.height) {\n                    autoHeightPanes++;\n                } else {\n                    if (height.indexOf && height.indexOf(\"%\")) {\n                        var percents = parseInt(height, 10) / 100;\n                        currentPane.options.height = percents * box.height();\n                    }\n\n                    currentPane.reflow(box.clone());\n\n                    remainingHeight -= currentPane.options.height;\n                }\n            }\n\n            for (var i$1 = 0; i$1 < panesLength; i$1++) {\n                var currentPane$1 = panes[i$1];\n\n                if (!currentPane$1.options.height) {\n                    currentPane$1.options.height = remainingHeight / autoHeightPanes;\n                }\n            }\n\n            for (var i$2 = 0; i$2 < panesLength; i$2++) {\n                var currentPane$2 = panes[i$2];\n                var paneBox = box\n                    .clone()\n                    .move(box.x1, top);\n\n                currentPane$2.reflow(paneBox);\n\n                top += currentPane$2.options.height;\n            }\n        },\n\n        backgroundBox: function() {\n            var axes = this.axes;\n            var axesCount = axes.length;\n            var box;\n\n            for (var i = 0; i < axesCount; i++) {\n                var axisA = axes[i];\n\n                for (var j = 0; j < axesCount; j++) {\n                    var axisB = axes[j];\n\n                    if (axisA.options.vertical !== axisB.options.vertical) {\n                        var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n                        if (!box) {\n                            box = lineBox;\n                        } else {\n                            box = box.wrap(lineBox);\n                        }\n                    }\n                }\n            }\n\n            return box || this.box;\n        },\n\n        chartsBoxes: function() {\n            var panes = this.panes;\n            var boxes = [];\n\n            for (var idx = 0; idx < panes.length; idx++) {\n                boxes.push(panes[idx].chartsBox());\n            }\n\n            return boxes;\n        },\n\n        addBackgroundPaths: function(multipath) {\n            var boxes = this.chartsBoxes();\n            for (var idx = 0; idx < boxes.length; idx++) {\n                multipath.paths.push(Path.fromRect(boxes[idx].toRect()));\n            }\n        },\n\n        backgroundContainsPoint: function(point) {\n            var boxes = this.chartsBoxes();\n            for (var idx = 0; idx < boxes.length; idx++) {\n                if (boxes[idx].containsPoint(point)) {\n                    return true;\n                }\n            }\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            var options = this.options.plotArea;\n            var opacity = options.opacity;\n            var background = options.background;\n            var border = options.border; if (border === void 0) { border = {}; }\n            if (isTransparent(background)) {\n                background = WHITE;\n                opacity = 0;\n            }\n\n            var bg = this._bgVisual = new MultiPath({\n                fill: {\n                    color: background,\n                    opacity: opacity\n                },\n                stroke: {\n                    color: border.width ? border.color : \"\",\n                    width: border.width,\n                    dashType: border.dashType\n                },\n                zIndex: -1\n            });\n\n            this.addBackgroundPaths(bg);\n\n            this.appendVisual(bg);\n        },\n\n        pointsByCategoryIndex: function(categoryIndex) {\n            var charts = this.charts;\n            var result = [];\n\n            if (categoryIndex !== null) {\n                for (var i = 0; i < charts.length; i++) {\n                    var chart = charts[i];\n\n                    if (chart.pane.options.name === \"_navigator\") {\n                        continue;\n                    }\n\n                    var points = charts[i].categoryPoints[categoryIndex];\n                    if (points && points.length) {\n                        for (var j = 0; j < points.length; j++) {\n                            var point = points[j];\n                            if (point && defined(point.value) && point.value !== null) {\n                                result.push(point);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        pointsBySeriesIndex: function(seriesIndex) {\n            return this.filterPoints(function(point) {\n                return point.series.index === seriesIndex;\n            });\n        },\n\n        pointsByPointIndex: function(pointIndex) {\n            return this.filterPoints(function(point) {\n                return point.getIndex() === pointIndex;\n            });\n        },\n\n        pointsBySeriesName: function(name) {\n            return this.filterPoints(function(point) {\n                return point.series.name === name;\n            });\n        },\n\n        filterPoints: function(callback) {\n            var charts = this.charts;\n            var result = [];\n\n            for (var i = 0; i < charts.length; i++) {\n                var chart = charts[i];\n                var points = chart.points;\n                for (var j = 0; j < points.length; j++) {\n                    var point = points[j];\n                    if (point && point.visible !== false && callback(point)) {\n                        result.push(point);\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        findPoint: function(callback) {\n            var charts = this.charts;\n\n            for (var i = 0; i < charts.length; i++) {\n                var chart = charts[i];\n                var points = chart.points;\n                for (var j = 0; j < points.length; j++) {\n                    var point = points[j];\n                    if (point && point.visible !== false && callback(point)) {\n                        return point;\n                    }\n                }\n            }\n        },\n\n        paneByPoint: function(point) {\n            var panes = this.panes;\n\n            for (var i = 0; i < panes.length; i++) {\n                var pane = panes[i];\n                if (pane.box.containsPoint(point)) {\n                    return pane;\n                }\n            }\n        },\n\n        detachLabels: function() {\n            var axes = this.groupAxes(this.panes);\n            var xAxes = axes.x;\n            var yAxes = axes.y;\n\n            this.detachAxisGroupLabels(yAxes, xAxes);\n            this.detachAxisGroupLabels(xAxes, yAxes);\n        },\n\n        detachAxisGroupLabels: function(axes, crossingAxes) {\n            var this$1$1 = this;\n\n            var labelAxisCount = 0;\n\n            for (var i = 0; i < axes.length; i++) {\n                var axis = axes[i];\n                var pane = axis.pane;\n                var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n                var axisIndex = i + labelAxisCount;\n                var labelAxis = this$1$1.createLabelAxis(axis, axisIndex, anchor);\n\n                if (labelAxis) {\n                    labelAxisCount++;\n\n                    var pos = pane.axes.indexOf(axis) + labelAxisCount;\n                    pane.appendAxisAt(labelAxis, pos);\n                }\n            }\n        },\n\n        createLabelAxis: function(axis, axisIndex, anchor) {\n            var labelOptions = axis.options.labels;\n            var position = labelOptions.position;\n            var onAxis = position !== END && position !== START;\n            var visible = labelOptions.visible;\n\n            if (onAxis || visible === false) {\n                return null;\n            }\n\n            var allAxes = this.groupAxes(this.panes);\n            var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n            var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n            var end = position === END;\n            var range = anchor.range();\n            var edge = end ? range.max : range.min;\n            var crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n            if (crossingValue - edge === 0) {\n                return null;\n            }\n\n            anchorCrossings.splice(axisIndex + 1, 0, edge);\n            anchor.options.axisCrossingValues = anchorCrossings;\n\n            var labelAxis = axis.clone();\n            axis.clear();\n\n            labelAxis.options.name = undefined;\n            labelAxis.options.line.visible = false;\n\n            labelAxis.options.crosshair = undefined;\n            labelAxis.options.notes = undefined;\n            labelAxis.options.plotBands = undefined;\n\n            return labelAxis;\n        },\n\n        isTrendline: function(series) {\n            return series && inArray(series.type, TRENDLINE_SERIES);\n        },\n\n        trendlineFactory: function() { /* abstract */ },\n\n        createTrendlineSeries: function() {\n            var this$1$1 = this;\n\n            var modifiedSeries = [];\n\n            this.series = this.series.map(function (series) {\n                if (!this$1$1.isTrendline(series)) {\n                    return series;\n                }\n\n                var forSeries = this$1$1.seriesByName(series.for);\n                if (!forSeries) {\n                    throw new Error('Invalid Configuration: Unable to locate linked series ' +\n                        \"\\\"\" + (series.for) + \"\\\" for trendline \\\"\" + (series.name) + \"\\\".\");\n                }\n\n                var valueFields = SeriesBinder.current.valueFields(forSeries);\n                var field = last(valueFields); // Use the last field for multi-field series\n\n                var trendlineSeries = this$1$1.trendlineFactory($.extend({}, {field: field}, series), forSeries);\n                if (trendlineSeries) {\n                    if (forSeries.visible === false) {\n                        trendlineSeries.visible = false;\n                    }\n\n                    if (trendlineSeries.color === datavizConstants.INHERIT) {\n                        trendlineSeries.color = forSeries.color;\n                    }\n\n                    modifiedSeries.push(trendlineSeries);\n                }\n\n                return trendlineSeries;\n            }).filter(function (series) { return series !== null; });\n\n            return modifiedSeries;\n        },\n\n        seriesByName: function(name) {\n            return this.series.find(function (series) { return series.name === name; });\n        },\n\n        getFirstPoint: function() {\n            return this.pointsBySeriesIndex(0)[0];\n        },\n\n        getPointBelow: function(point) {\n            return this._getNextPoint(point, this._pointsByVertical, 1);\n        },\n\n        getPointAbove: function(point) {\n            return this._getNextPoint(point, this._pointsByVertical, -1);\n        },\n\n        getPointToTheRight: function(point) {\n            return this._getNextPoint(point, this._pointsByHorizontal, 1);\n        },\n\n        getPointToTheLeft: function(point) {\n            return this._getNextPoint(point, this._pointsByHorizontal, -1);\n        },\n\n        _getNextPoint: function(point, getPointsFunc, increment) {\n            var this$1$1 = this;\n\n            var points = getPointsFunc.call(this, point);\n            var pointIndex = points.indexOf(point);\n            var nextIndex = pointIndex + increment;\n            var loopPoints = function (direction) {\n                // loop over to last non-empty collection\n                var result;\n                var offset = 0;\n                do {\n                    offset += direction;\n                    result = getPointsFunc.call(this$1$1, point, offset);\n                } while (result.length === 0);\n\n                return result;\n            };\n\n            if (nextIndex < 0) {\n                points = loopPoints(-1);\n\n                return points.at(-1);\n            } else if (nextIndex >= points.length) {\n                points = loopPoints(1);\n\n                return points.at(0);\n            }\n\n            return points[nextIndex];\n        },\n\n        _pointsByVertical: function(basePoint) {\n            return this.pointsByPointIndex(basePoint.getIndex());\n        },\n\n        _pointsByHorizontal: function(basePoint, offset) {\n            if (offset === void 0) { offset = 0; }\n\n            var index = cycleIndex(basePoint.series.index + offset, this.series.length);\n            return this.pointsBySeriesIndex(index);\n        }\n    });\n\n    function isSingleAxis(axis) {\n        return !axis.pane.axes.some(function (a) { return a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false; }\n        );\n    }\n\n    function axisGroupBox(axes) {\n        var length = axes.length;\n        var box;\n\n        for (var i = 0; i < length; i++) {\n            var axis = axes[i];\n            var visible = axis.options.visible !== false;\n            if (visible || isSingleAxis(axis)) {\n                var axisBox = visible ? axis.contentBox() : axis.lineBox();\n\n                if (!box) {\n                    box = axisBox.clone();\n                } else {\n                    box.wrap(axisBox);\n                }\n            }\n        }\n\n        return box || new Box();\n    }\n\n    function paneAnchor(axes, pane) {\n        for (var i = 0; i < axes.length; i++) {\n            var anchor = axes[i];\n            if (anchor && anchor.pane === pane) {\n                return anchor;\n            }\n        }\n    }\n\n    function isTransparent(color) {\n        return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n    }\n\n    var allPaneAxes = function (panes) { return panes.reduce(function (acc, pane) { return acc.concat(pane.axes); }, []); };\n\n    setDefaultOptions(PlotAreaBase, {\n        series: [],\n        plotArea: {\n            margin: {}\n        },\n        background: \"\",\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        paneDefaults: {\n            title: {}\n        },\n        legend: {\n            inactiveItems: {\n                labels: {\n                    color: \"#919191\"\n                },\n                markers: {\n                    color: \"#919191\"\n                }\n            }\n        }\n    });\n\n    var PlotAreaEventsMixin = {\n        hover: function(chart, e) {\n            this._dispatchEvent(chart, e, PLOT_AREA_HOVER);\n        },\n\n        click: function(chart, e) {\n            this._dispatchEvent(chart, e, PLOT_AREA_CLICK);\n        }\n    };\n\n    var SeriesAggregator = Class.extend({\n        init: function(series, binder, defaultAggregates) {\n\n            var canonicalFields = binder.canonicalFields(series);\n            var valueFields = binder.valueFields(series);\n            var sourceFields = binder.sourceFields(series, canonicalFields);\n            var seriesFields = this._seriesFields = [];\n            var defaults = defaultAggregates.query(series.type);\n            var rootAggregate = series.aggregate || defaults;\n\n            this._series = series;\n            this._binder = binder;\n\n            for (var i = 0; i < canonicalFields.length; i++) {\n                var field = canonicalFields[i];\n                var fieldAggregate = (void 0);\n\n                if (isObject(rootAggregate)) {\n                    fieldAggregate = rootAggregate[field];\n                } else if (i === 0 || inArray(field, valueFields)) {\n                    fieldAggregate = rootAggregate;\n                } else {\n                    break;\n                }\n\n                if (fieldAggregate) {\n                    seriesFields.push({\n                        canonicalName: field,\n                        name: sourceFields[i],\n                        transform: isFunction(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]\n                    });\n                }\n            }\n        },\n\n        aggregatePoints: function(srcPoints, group) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var series = ref._series;\n            var seriesFields = ref._seriesFields;\n            var data = this._bindPoints(srcPoints || []);\n            var firstDataItem = data.dataItems[0];\n            var result = {};\n\n            if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\n                var fn = function() {};\n                fn.prototype = firstDataItem;\n                result = new fn();\n            }\n\n            for (var i = 0; i < seriesFields.length; i++) {\n                var field = seriesFields[i];\n                var srcValues = this$1$1._bindField(data.values, field.canonicalName);\n                var value = field.transform(srcValues, series, data.dataItems, group);\n\n                if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\n                    result = value;\n                    break;\n                } else {\n                    if (defined(value)) {\n                        setValue(field.name, result, value);\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        _bindPoints: function(points) {\n            var ref = this;\n            var binder = ref._binder;\n            var series = ref._series;\n            var values = [];\n            var dataItems = [];\n\n            for (var i = 0; i < points.length; i++) {\n                var pointIx = points[i];\n\n                values.push(binder.bindPoint(series, pointIx));\n                dataItems.push(series.data[pointIx]);\n            }\n\n            return {\n                values: values,\n                dataItems: dataItems\n            };\n        },\n\n        _bindField: function(data, field) {\n            var values = [];\n            var count = data.length;\n\n            for (var i = 0; i < count; i++) {\n                var item = data[i];\n                var valueFields = item.valueFields;\n                var value = (void 0);\n\n                if (defined(valueFields[field])) {\n                    value = valueFields[field];\n                } else {\n                    value = item.fields[field];\n                }\n\n                values.push(value);\n            }\n\n            return values;\n        }\n    });\n\n    function setValue(fieldName, target, value) {\n        var parentObj = target;\n        var field = fieldName;\n\n        if (fieldName.indexOf(\".\") > -1) {\n            var parts = fieldName.split(\".\");\n\n            while (parts.length > 1) {\n                field = parts.shift();\n                if (!defined(parentObj[field])) {\n                    parentObj[field] = {};\n                }\n                parentObj = parentObj[field];\n            }\n            field = parts.shift();\n        }\n\n        parentObj[field] = value;\n    }\n\n    var DefaultAggregates = Class.extend({\n        init: function() {\n\n            this._defaults = {};\n        },\n\n        register: function(seriesTypes, aggregates) {\n            var this$1$1 = this;\n\n            for (var i = 0; i < seriesTypes.length; i++) {\n                this$1$1._defaults[seriesTypes[i]] = aggregates;\n            }\n        },\n\n        query: function(seriesType) {\n            return this._defaults[seriesType];\n        }\n    });\n\n    DefaultAggregates.current = new DefaultAggregates();\n\n    var RangeBar = Bar.extend({\n        createLabel: function() {\n            var labels = this.options.labels;\n            var fromOptions = deepExtend({}, labels, labels.from);\n            var toOptions = deepExtend({}, labels, labels.to);\n\n            if (fromOptions.visible) {\n                this.labelFrom = this.createLabelElement(fromOptions);\n                this.append(this.labelFrom);\n            }\n\n            if (toOptions.visible) {\n                this.labelTo = this.createLabelElement(toOptions);\n                this.append(this.labelTo);\n            }\n        },\n\n        reflow: function(targetBox) {\n            this.render();\n\n            var ref = this;\n            var labelFrom = ref.labelFrom;\n            var labelTo = ref.labelTo;\n            var value = ref.value;\n\n            this.box = targetBox;\n\n            if (labelFrom) {\n                labelFrom.options.aboveAxis = value.from > value.to;\n                labelFrom.reflow(targetBox);\n            }\n\n            if (labelTo) {\n                labelTo.options.aboveAxis = value.to > value.from;\n                labelTo.reflow(targetBox);\n            }\n\n            if (this.note) {\n                this.note.reflow(targetBox);\n            }\n        }\n    });\n\n    RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {\n        labels: {\n            format: \"{0} - {1}\"\n        },\n        tooltip: {\n            format: \"{1}\"\n        }\n    });\n\n    var RangeBarChart = BarChart.extend({\n        pointType: function() {\n            return RangeBar;\n        },\n\n        pointValue: function(data) {\n            return data.valueFields;\n        },\n\n        formatPointValue: function(point, format) {\n            if (point.value.from === null && point.value.to === null) {\n                return \"\";\n            }\n\n            return this.chartService.format.auto(format, point.value.from, point.value.to);\n        },\n\n        plotRange: function(point) {\n            if (!point) {\n                return 0;\n            }\n\n            return [ point.value.from, point.value.to ];\n        },\n\n        updateRange: function(value, fields) {\n            var axisName = fields.series.axis;\n            var from = value.from;\n            var to = value.to;\n            var axisRange = this.valueAxisRanges[axisName];\n\n            if (value !== null && isNumber(from) && isNumber(to)) {\n                axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n                axisRange.min = Math.min(axisRange.min, from);\n                axisRange.max = Math.max(axisRange.max, from);\n\n                axisRange.min = Math.min(axisRange.min, to);\n                axisRange.max = Math.max(axisRange.max, to);\n            }\n        },\n\n        aboveAxis: function(point) {\n            var value = point.value;\n            return value.from < value.to;\n        }\n    });\n\n    RangeBarChart.prototype.plotLimits = CategoricalChart.prototype.plotLimits;\n\n    var RangeLinePoint = LinePoint.extend({\n        aliasFor: function() {\n            return this.parent;\n        }\n    });\n\n    var AUTO = 'auto';\n    var DEFAULT_FROM_FORMAT = '{0}';\n    var DEFAULT_TO_FORMAT = '{1}';\n\n    var RangeAreaPoint = ChartElement.extend({\n        init: function(value, options) {\n            ChartElement.fn.init.call(this);\n\n            this.value = value;\n            this.options = options;\n            this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\n            this.tooltipTracking = true;\n            this._id = guid();\n            this.initLabelsFormat();\n        },\n\n        render: function() {\n            if (this._rendered) {\n                return;\n            }\n\n            this._rendered = true;\n\n            var ref = this.options;\n            var markers = ref.markers;\n            var labels = ref.labels;\n            var value = this.value;\n\n            var fromPoint = this.fromPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\n                labels: labels.from,\n                markers: markers.from\n            }));\n\n            var toPoint = this.toPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\n                labels: labels.to,\n                markers: markers.to\n            }));\n\n            this.copyFields(fromPoint);\n            this.copyFields(toPoint);\n\n            this.append(fromPoint);\n            this.append(toPoint);\n        },\n\n        reflow: function(targetBox) {\n            this.render();\n\n            var fromBox = targetBox.from;\n            var toBox = targetBox.to;\n\n            this.positionLabels(fromBox, toBox);\n\n            this.fromPoint.reflow(fromBox);\n            this.toPoint.reflow(toBox);\n\n            this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());\n        },\n\n        createHighlight: function() {\n            var group = new Group();\n            group.append(this.fromPoint.createHighlight());\n            group.append(this.toPoint.createHighlight());\n\n            return group;\n        },\n\n        highlightVisual: function() {\n            return this.visual;\n        },\n\n        highlightVisualArgs: function() {\n            return {\n                options: this.options,\n                from: this.fromPoint.highlightVisualArgs(),\n                to: this.toPoint.highlightVisualArgs()\n            };\n        },\n\n        createFocusHighlight: function() {\n            var group = new Group();\n            group.append(this.fromPoint.createFocusHighlight());\n            group.append(this.toPoint.createFocusHighlight());\n\n            return group;\n        },\n\n        tooltipAnchor: function() {\n            var clipBox = this.owner.pane.clipBox();\n            var showTooltip = !clipBox || clipBox.overlaps(this.box);\n\n            if (showTooltip) {\n                var box = this.box;\n                var center = box.center();\n                var horizontalAlign = LEFT;\n                var x, y, verticalAlign;\n\n                if (this.options.vertical) {\n                    x = center.x;\n                    y = box.y1 - TOOLTIP_OFFSET;\n                    verticalAlign = BOTTOM;\n                } else {\n                    x = box.x2 + TOOLTIP_OFFSET;\n                    y = center.y;\n                    verticalAlign = CENTER;\n                }\n\n                return {\n                    point: new Point(x, y),\n                    align: {\n                        horizontal: horizontalAlign,\n                        vertical: verticalAlign\n                    }\n                };\n            }\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        overlapsBox: function(box) {\n            return this.box.overlaps(box);\n        },\n\n        unclipElements: function() {\n            this.fromPoint.unclipElements();\n            this.toPoint.unclipElements();\n        },\n\n        initLabelsFormat: function() {\n            var labels = this.options.labels;\n            if (!labels.format) {\n                if (!labels.from || !labels.from.format) {\n                    labels.from = $.extend({}, labels.from, {\n                        format: DEFAULT_FROM_FORMAT\n                    });\n                }\n\n                if (!labels.to || !labels.to.format) {\n                    labels.to = $.extend({}, labels.to, {\n                        format: DEFAULT_TO_FORMAT\n                    });\n                }\n            }\n        },\n\n        positionLabels: function(fromBox, toBox) {\n            var ref = this.options;\n            var labels = ref.labels;\n            var vertical = ref.vertical;\n\n            if (labels.position === AUTO) {\n                var fromLabelPosition, toLabelPosition;\n                if (vertical) {\n                    if (toBox.y1 <= fromBox.y1) {\n                        toLabelPosition = ABOVE;\n                        fromLabelPosition = BELOW;\n                    } else {\n                        toLabelPosition = BELOW;\n                        fromLabelPosition = ABOVE;\n                    }\n                } else {\n                    if (toBox.x1 <= fromBox.x1) {\n                        toLabelPosition = LEFT;\n                        fromLabelPosition = RIGHT;\n                    } else {\n                        toLabelPosition = RIGHT;\n                        fromLabelPosition = LEFT;\n                    }\n                }\n\n                if (!labels.from || !labels.from.position) {\n                    this.fromPoint.options.labels.position = fromLabelPosition;\n                }\n\n                if (!labels.to || !labels.to.position) {\n                    this.toPoint.options.labels.position = toLabelPosition;\n                }\n            }\n        },\n\n        copyFields: function(point) {\n            point.dataItem = this.dataItem;\n            point.category = this.category;\n            point.series = this.series;\n            point.color = this.color;\n            point.owner = this.owner;\n        },\n\n        focusVisual: function() {\n            this.fromPoint.focusVisual();\n        },\n\n        clearFocusFromVisual: function() {\n            this.toPoint.clearFocusFromVisual();\n        },\n\n        getIndex: function() {\n            return this.categoryIx;\n        }\n    });\n\n    deepExtend(RangeAreaPoint.prototype, PointEventsMixin);\n    deepExtend(RangeAreaPoint.prototype, NoteMixin);\n\n    RangeAreaPoint.prototype.defaults = {\n        markers: {\n            visible: false,\n            background: WHITE,\n            size: LINE_MARKER_SIZE,\n            type: CIRCLE,\n            border: {\n                width: 2\n            },\n            opacity: 1\n        },\n        labels: {\n            visible: false,\n            margin: getSpacing(3),\n            padding: getSpacing(4),\n            animation: {\n                type: FADEIN,\n                delay: INITIAL_ANIMATION_DURATION\n            },\n            position: AUTO\n        },\n        notes: {\n            label: {}\n        },\n        highlight: {\n            markers: {\n                border: {\n                    color: WHITE,\n                    width: 2\n                }\n            },\n            zIndex: datavizConstants.HIGHLIGHT_ZINDEX\n        },\n        tooltip: {\n            format: '{0} - {1}'\n        },\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    };\n\n    var RangeAreaSegment = AreaSegment.extend({\n        createStrokeSegments: function() {\n            return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));\n        },\n\n        stackSegments: function() {\n            var fromSegments = this.fromSegments;\n            if (!this.fromSegments) {\n                fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));\n            }\n\n            return fromSegments;\n        },\n\n        createStroke: function(style) {\n            var toPath = new Path(style);\n            var fromPath = new Path(style);\n\n            toPath.segments.push.apply(toPath.segments, this.strokeSegments());\n            fromPath.segments.push.apply(fromPath.segments, this.stackSegments());\n\n            this.visual.append(toPath);\n            this.visual.append(fromPath);\n        },\n\n        hasStackSegment: function() {\n            return true;\n        },\n\n        fromPoints: function() {\n            return this.linePoints.map(function (point) { return point.fromPoint; });\n        },\n\n        toPoints: function() {\n            return this.linePoints.map(function (point) { return point.toPoint; });\n        }\n    });\n\n    var SplineRangeAreaSegment = RangeAreaSegment.extend({\n        createStrokeSegments: function() {\n            return this.createCurveSegments(this.toPoints());\n        },\n\n        stackSegments: function() {\n            var fromSegments = this.fromSegments;\n            if (!this.fromSegments) {\n                fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());\n            }\n\n            return fromSegments;\n        },\n\n        createCurveSegments: function(points) {\n            var curveProcessor = new CurveProcessor();\n\n            return curveProcessor.process(this.toGeometryPoints(points));\n        }\n    });\n\n    var StepRangeAreaSegment = RangeAreaSegment.extend({\n        createStrokeSegments: function() {\n            return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));\n        },\n\n        stackSegments: function() {\n            var fromSegments = this.fromSegments;\n            if (!this.fromSegments) {\n                fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));\n                fromSegments.reverse();\n            }\n\n            return fromSegments;\n        }\n    });\n\n    deepExtend(StepRangeAreaSegment.prototype, StepLineMixin);\n\n    var RangeAreaChart = CategoricalChart.extend({\n        render: function() {\n            CategoricalChart.fn.render.call(this);\n\n            this.renderSegments();\n        },\n\n        pointType: function() {\n            return RangeAreaPoint;\n        },\n\n        createPoint: function(data, fields) {\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var value = data.valueFields;\n\n            if (!hasValue(value.from) && !hasValue(value.to)) {\n                if (this.seriesMissingValues(series) === ZERO) {\n                    value = {\n                        from: 0,\n                        to: 0\n                    };\n                } else {\n                    return null;\n                }\n            }\n\n            var pointOptions = this.pointOptions(series, seriesIx);\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            var color = data.fields.color || series.color;\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            }\n\n            var point = new RangeAreaPoint(value, pointOptions);\n            point.color = color;\n\n            this.append(point);\n\n            return point;\n        },\n\n        createSegment: function(linePoints, currentSeries, seriesIx) {\n            var style = (currentSeries.line || {}).style;\n            var segmentType;\n            if (style === \"smooth\") {\n                segmentType = SplineRangeAreaSegment;\n            } else if (style === \"step\") {\n                segmentType = StepRangeAreaSegment;\n            } else {\n                segmentType = RangeAreaSegment;\n            }\n\n            return new segmentType(linePoints, currentSeries, seriesIx);\n        },\n\n        plotRange: function(point, startValue) {\n            if (!point) {\n                return [ startValue, startValue ];\n            }\n\n            return [ point.value.from, point.value.to ];\n        },\n\n        valueSlot: function(valueAxis, plotRange) {\n            var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);\n            var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);\n            if (fromSlot && toSlot) {\n                return {\n                    from: fromSlot,\n                    to: toSlot\n                };\n            }\n        },\n\n        pointSlot: function(categorySlot, valueSlot) {\n            var from = valueSlot.from;\n            var to = valueSlot.to;\n            var fromSlot, toSlot;\n\n            if (this.options.invertAxes) {\n                fromSlot = new Box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);\n                toSlot = new Box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);\n            } else {\n                fromSlot = new Box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);\n                toSlot = new Box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);\n            }\n\n            return {\n                from: fromSlot,\n                to: toSlot\n            };\n        },\n\n        addValue: function(data, fields) {\n            var valueFields = data.valueFields;\n            if (!isNumber(valueFields.from)) {\n                valueFields.from = valueFields.to;\n            }\n\n            if (!isNumber(valueFields.to)) {\n                valueFields.to = valueFields.from;\n            }\n\n            CategoricalChart.fn.addValue.call(this, data, fields);\n        },\n\n        updateRange: function(value, fields) {\n            if (value !== null && isNumber(value.from) && isNumber(value.to)) {\n                var axisName = fields.series.axis;\n                var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };\n                var from = value.from;\n                var to = value.to;\n\n                axisRange.min = Math.min(axisRange.min, from, to);\n                axisRange.max = Math.max(axisRange.max, from, to);\n            }\n        },\n\n        formatPointValue: function(point, format) {\n            var value = point.value;\n\n            return this.chartService.format.auto(format, value.from, value.to);\n        },\n\n        animationPoints: function() {\n            var points = this.points;\n            var result = [];\n            for (var idx = 0; idx < points.length; idx++) {\n                var point = points[idx];\n                if (point) {\n                    result.push((point.fromPoint || {}).marker);\n                    result.push((point.toPoint || {}).marker);\n                }\n            }\n\n            return result.concat(this._segments);\n        }\n    });\n\n    deepExtend(RangeAreaChart.prototype, LineChartMixin, ClipAnimationMixin);\n\n    var OHLCPoint = Candlestick.extend({\n        reflow: function(box) {\n            var ref = this;\n            var options = ref.options;\n            var value = ref.value;\n            var chart = ref.owner;\n            var valueAxis = chart.seriesValueAxis(options);\n            var oPoints = [];\n            var cPoints = [];\n            var lhPoints = [];\n\n            var lhSlot = valueAxis.getSlot(value.low, value.high);\n            var oSlot = valueAxis.getSlot(value.open, value.open);\n            var cSlot = valueAxis.getSlot(value.close, value.close);\n\n            oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;\n            oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;\n\n            var mid = lhSlot.center().x;\n\n            oPoints.push([ oSlot.x1, oSlot.y1 ]);\n            oPoints.push([ mid, oSlot.y1 ]);\n            cPoints.push([ mid, cSlot.y1 ]);\n            cPoints.push([ cSlot.x2, cSlot.y1 ]);\n            lhPoints.push([ mid, lhSlot.y1 ]);\n            lhPoints.push([ mid, lhSlot.y2 ]);\n\n            this.lines = [\n                oPoints, cPoints, lhPoints\n            ];\n\n            this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));\n\n            this.reflowNote();\n        },\n\n        createBody: function() {}\n    });\n\n    var OHLCChart = CandlestickChart.extend({\n        pointType: function() {\n            return OHLCPoint;\n        }\n    });\n\n    var WaterfallSegment = ChartElement.extend({\n        init: function(from, to, series) {\n            ChartElement.fn.init.call(this);\n\n            this.from = from;\n            this.to = to;\n            this.series = series;\n        },\n\n        linePoints: function() {\n            var from = this.from;\n            var ref = this;\n            var fromBox = ref.from.box;\n            var toBox = ref.to.box;\n            var points = [];\n\n            if (from.isVertical) {\n                var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;\n                points.push(\n                    [ fromBox.x1, y ],\n                    [ toBox.x2, y ]\n                );\n            } else {\n                var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;\n                points.push(\n                    [ x, fromBox.y1 ],\n                    [ x, toBox.y2 ]\n                );\n            }\n\n            return points;\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            var line = this.series.line || {};\n\n            var path = Path.fromPoints(this.linePoints(), {\n                stroke: {\n                    color: line.color,\n                    width: line.width,\n                    opacity: line.opacity,\n                    dashType: line.dashType\n                }\n            });\n\n            alignPathToPixel(path);\n            this.visual.append(path);\n        }\n    });\n\n    setDefaultOptions(WaterfallSegment, {\n        animation: {\n            type: FADEIN,\n            delay: INITIAL_ANIMATION_DURATION\n        }\n    });\n\n    var WaterfallChart = BarChart.extend({\n        render: function() {\n            BarChart.fn.render.call(this);\n            this.createSegments();\n        },\n\n        traverseDataPoints: function(callback) {\n            var this$1$1 = this;\n\n            var series = this.options.series;\n            var totalCategories = categoriesCount(series);\n            var isVertical = !this.options.invertAxes;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var total = 0;\n                var runningTotal = 0;\n\n                for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n                    var data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n                    var value = data.valueFields.value;\n                    var summary = data.fields.summary;\n                    var from = total;\n                    var to = (void 0);\n\n                    if (summary) {\n                        if (summary.toLowerCase() === \"total\") {\n                            data.valueFields.value = total;\n                            from = 0;\n                            to = total;\n                        } else {\n                            data.valueFields.value = runningTotal;\n                            to = from - runningTotal;\n                            runningTotal = 0;\n                        }\n                    } else if (isNumber(value)) {\n                        runningTotal += value;\n                        total += value;\n                        to = total;\n                    }\n\n                    callback(data, {\n                        category: this$1$1.categoryAxis.categoryAt(categoryIx),\n                        categoryIx: categoryIx,\n                        series: currentSeries,\n                        seriesIx: seriesIx,\n                        total: total,\n                        runningTotal: runningTotal,\n                        from: from,\n                        to: to,\n                        isVertical: isVertical\n                    });\n                }\n            }\n        },\n\n        updateRange: function(value, fields) {\n            BarChart.fn.updateRange.call(this, { value: fields.to }, fields);\n        },\n\n        aboveAxis: function(point) {\n            return point.value >= 0;\n        },\n\n        plotRange: function(point) {\n            return [ point.from, point.to ];\n        },\n\n        createSegments: function() {\n            var this$1$1 = this;\n\n            var series = this.options.series;\n            var seriesPoints = this.seriesPoints;\n            var segments = this.segments = [];\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var points = seriesPoints[seriesIx];\n\n                if (points) {\n                    var prevPoint = (void 0);\n                    for (var pointIx = 0; pointIx < points.length; pointIx++) {\n                        var point = points[pointIx];\n\n                        if (point && prevPoint) {\n                            var segment = new WaterfallSegment(prevPoint, point, currentSeries);\n                            segments.push(segment);\n                            this$1$1.append(segment);\n                        }\n\n                        prevPoint = point;\n                    }\n                }\n            }\n        }\n    });\n\n    function trendlineFactory(registry, type, context) {\n        var impl = registry[String(type)];\n        if (impl) {\n            return impl(context);\n        }\n\n        return null;\n    }\n\n    // Optimized version of calculatePolynomial for order = 1\n    function calculateSlope(sourceValues, valueGetter) {\n        var x = 0;\n        var y = 0;\n        var x2 = 0;\n        var xy = 0;\n        var count = 0;\n        var slope, intercept;\n        var xMin = Number.MAX_VALUE;\n        var xMax = Number.MIN_VALUE;\n\n        for (var i = 0; i < sourceValues.length; i++) {\n            var value = sourceValues[i];\n            var ref = valueGetter(value);\n            var xValue = ref.xValue;\n            var yValue = ref.yValue;\n\n            if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {\n                xMin = Math.min(xValue, xMin);\n                xMax = Math.max(xValue, xMax);\n\n                count++;\n                x += xValue;\n                y += yValue;\n                x2 += Math.pow(xValue, 2);\n                xy += xValue * yValue;\n            }\n        }\n\n        if (count > 0) {\n            slope = (count * xy - x * y) / (count * x2 - Math.pow(x, 2));\n            intercept = (y - slope * x) / count;\n        }\n\n        return { slope: slope, intercept: intercept, count: count, xMin: xMin, xMax: xMax };\n    }\n\n    var checkAllPositive = function (sourceValues, fieldName) { return sourceValues.every(function (ref) {\n            var valueFields = ref.valueFields;\n\n            return !hasValue(valueFields[fieldName]) || valueFields[fieldName] > 0;\n            }); };\n\n    function getTrendlineData(valueMapper, categoryAxis) {\n        var data = [];\n        var totalRange = categoryAxis.totalRangeIndices();\n        var currentRange = categoryAxis.currentRangeIndices();\n        var range = {\n            min: Math.floor(Math.max(currentRange.min - 1, totalRange.min)),\n            max: Math.ceil(Math.min(currentRange.max + 2, totalRange.max))\n        };\n\n        for (var i = range.min; i < range.max; i++) {\n            var x = (i + 1);\n            data[i] = {\n                category: categoryAxis.categoryAt(i, true),\n                value: valueMapper(x)\n            };\n        }\n\n        return data;\n    }\n\n    function exponentialTrendline(context) {\n        var options = context.options;\n        var categoryAxis = context.categoryAxis;\n        var seriesValues = context.seriesValues;\n\n        var data = getData({ seriesValues: seriesValues, categoryAxis: categoryAxis, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'line',\n                data: data,\n                categoryField: 'category',\n                field: 'value'});\n        }\n\n        return null;\n    }\n\n    var valueGetter = function (fieldName) { return function (ref) {\n            var categoryIx = ref.categoryIx;\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: categoryIx + 1, yValue: Math.log(valueFields[fieldName]) });\n     }    };\n\n    function getData(ref) {\n        var seriesValues = ref.seriesValues;\n        var categoryAxis = ref.categoryAxis;\n        var options = ref.options;\n\n        var sourceValues = seriesValues();\n        if (!checkAllPositive(sourceValues, options.field)) {\n            return null;\n        }\n\n        var ref$1 = calculateSlope(sourceValues, valueGetter(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        if (count > 0) {\n            // Exponential trendline equation:\n            // y = a * e ^ (b * x)\n            var a = Math.exp(intercept);\n            var b = slope;\n\n            return getTrendlineData(function (x) { return a * Math.exp(b * x); }, categoryAxis);\n        }\n\n        return null;\n    }\n\n    function linearTrendline(context) {\n        var options = context.options;\n        var categoryAxis = context.categoryAxis;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$1({ seriesValues: seriesValues, categoryAxis: categoryAxis, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'line',\n                data: data,\n                categoryField: 'category',\n                field: 'value'});\n        }\n\n        return null;\n    }\n\n    var valueGetter$1 = function (fieldName) { return function (ref) {\n            var categoryIx = ref.categoryIx;\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: categoryIx + 1, yValue: valueFields[fieldName] });\n     }    };\n\n    function getData$1(ref) {\n        var seriesValues = ref.seriesValues;\n        var categoryAxis = ref.categoryAxis;\n        var options = ref.options;\n\n        var ref$1 = calculateSlope(seriesValues(), valueGetter$1(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n\n        if (count > 0) {\n            return getTrendlineData(function (x) { return slope * x + intercept; }, categoryAxis);\n        }\n\n        return null;\n    }\n\n    function logarithmicTrendline(context) {\n        var options = context.options;\n        var categoryAxis = context.categoryAxis;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$2({ seriesValues: seriesValues, categoryAxis: categoryAxis, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'line',\n                data: data,\n                categoryField: 'category',\n                field: 'value'});\n        }\n\n        return null;\n    }\n\n    var valueGetter$2 = function (fieldName) { return function (ref) {\n            var categoryIx = ref.categoryIx;\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: Math.log(categoryIx + 1), yValue: valueFields[fieldName] });\n     }    };\n\n    function getData$2(ref) {\n        var seriesValues = ref.seriesValues;\n        var categoryAxis = ref.categoryAxis;\n        var options = ref.options;\n\n        var ref$1 = calculateSlope(seriesValues(), valueGetter$2(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        if (count > 0) {\n            // Logarithmic trendline equation:\n            // y = a * ln (x) + b\n            var a = slope;\n            var b = intercept;\n            return getTrendlineData(function (x) { return a * Math.log(x) + b; }, categoryAxis);\n        }\n\n        return null;\n    }\n\n    function calculateMovingAverage(sourceValues, valueGetter, period) {\n        var averagePoints = [];\n        var values = [];\n        var start = Math.max(MIN_MOVING_AVERAGE_PERIOD, period) - 1;\n\n        var end = 0;\n        var sum = 0;\n\n        for (var i = 0; i < sourceValues.length; i++) {\n            var value = sourceValues[i];\n            var ref = valueGetter(value);\n            var xValue = ref.xValue;\n            var yValue = ref.yValue;\n\n            if (isFinite(yValue) && yValue !== null) {\n                values.push(yValue);\n                sum += yValue;\n                end = Math.max(i, end);\n            } else {\n                values.push(null);\n            }\n\n            if (i >= start) {\n                var count = values.filter(function (value) { return value !== null; }).length;\n                var lastValue = values.shift() || 0;\n\n                if (count > 0) {\n                    var average = sum / count;\n                    averagePoints.push([xValue, average]);\n\n                    sum -= lastValue;\n                    continue;\n                }\n            }\n\n            averagePoints.push([xValue, null]);\n        }\n\n        return averagePoints.slice(0, end + 1);\n    }\n\n    function movingAverageTrendline(context) {\n        var options = context.options;\n\n        var data = getData$3(context);\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'line',\n                data: data,\n                categoryField: 'category',\n                field: 'value'});\n        }\n\n        return null;\n    }\n\n    var valueGetter$3 = function (fieldName) { return function (ref) {\n            var categoryIx = ref.categoryIx;\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: categoryIx, yValue: valueFields[fieldName] });\n     }    };\n\n    function calculatePoints(ref) {\n        var options = ref.options;\n        var categoryAxis = ref.categoryAxis;\n        var seriesValues = ref.seriesValues;\n\n        var period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;\n        var totalRange = categoryAxis.totalRangeIndices();\n        var currentRange = categoryAxis.currentRangeIndices();\n        var range = {\n            min: Math.floor(Math.max(currentRange.min - period, totalRange.min)),\n            max: Math.ceil(Math.min(currentRange.max + period + 2, totalRange.max))\n        };\n\n        return calculateMovingAverage(seriesValues(range), valueGetter$3(options.field), period);\n    }\n\n    function getData$3(context) {\n        var categoryAxis = context.categoryAxis;\n        var points = calculatePoints(context);\n        var data = [];\n        points.forEach(function (ref) {\n            var categoryIx = ref[0];\n            var value = ref[1];\n\n            data[categoryIx] = {\n                category: categoryAxis.categoryAt(categoryIx, true),\n                value: value\n            };\n        });\n\n        if (data.length > 0) {\n            return data;\n        }\n\n        return null;\n    }\n\n    var MIN_ORDER = 1;\n    var MAX_ORDER = 6;\n\n    function calculatePolynomial(sourceValues, valueGetter, order) {\n        var k = Math.min(Math.max(order || MIN_ORDER, MIN_ORDER), MAX_ORDER) + 1;\n        var X$$1 = new dataviz.Matrix();\n        var Y$$1 = new dataviz.Matrix();\n        var count = 0;\n        var xMin = Number.MAX_VALUE;\n        var xMax = Number.MIN_VALUE;\n        var valueMapper = function (x) { return x; };\n        var coefficients = [];\n\n        for (var i = 0; i < sourceValues.length; i++) {\n            var value = sourceValues[i];\n            var ref = valueGetter(value);\n            var xValue = ref.xValue;\n            var yValue = ref.yValue;\n\n            if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {\n                xMin = Math.min(xValue, xMin);\n                xMax = Math.max(xValue, xMax);\n                count++;\n\n                // Set Y value in matrix\n                Y$$1.set(i, 0, yValue);\n\n                // Set indicator column to 1 for valid values\n                X$$1.set(i, 0, 1);\n                X$$1.set(i, 1, xValue);\n                for (var pow = 2; pow <= k; pow++) {\n                    X$$1.set(i, pow, Math.pow(X$$1.get(i, 1), pow));\n                }\n            } else {\n                // Set indicator column to 0 for missing values\n                X$$1.set(i, 0, 0);\n            }\n        }\n\n        // Limit order to number of values.\n        X$$1.width = Math.min(k, count);\n\n        if (count > 0) {\n            // Polynomial trendline equation:\n            // y = aN * x^N + ... + a2 * x^2 + a1 * x + a0\n            coefficients = linearRegression(X$$1, Y$$1);\n            valueMapper = function (x) { return coefficients.reduce(function (y, a, n) { return y + a * Math.pow(x, n); }, 0); };\n        }\n\n        return {\n            coefficients: coefficients,\n            count: count,\n            valueMapper: valueMapper,\n            xMin: xMin,\n            xMax: xMax\n        };\n    }\n\n    function linearRegression(X$$1, Y$$1) {\n        var Xt = X$$1.transpose();\n        var B = Xt.multiply(X$$1).inverse().multiply(Xt).multiply(Y$$1); // the last square estimate of the coefficients\n\n        var coefficients = [];\n        for (var i = 0; i < B.height; i++) {\n            coefficients.push(B.get(i, 0));\n        }\n\n        // y_intercept and regression coefficients ('slopes')\n        return coefficients;\n\n        // It's possible to calculate statistics for the regression based on\n        // the LINEST function implementation in kendo-spreadsheet-common/src/calc.js\n        //\n        // * The standard errors (of coefficients and y-intercept)\n        // * The coefficient of determination (R^2)\n        // * The standard error for the y estimate\n        // * The F statistic\n        // * The degrees of freedom\n        // * The regression sum of squares (SSR)\n        // * The residual sum of squares (SSE)\n    }\n\n    function polynomialTrendline(context) {\n        var options = context.options;\n        var categoryAxis = context.categoryAxis;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$4({ seriesValues: seriesValues, categoryAxis: categoryAxis, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'line',\n                data: data,\n                categoryField: 'category',\n                field: 'value'});\n        }\n\n        return null;\n    }\n\n    var valueGetter$4 = function (fieldName) { return function (ref) {\n            var categoryIx = ref.categoryIx;\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: categoryIx + 1, yValue: valueFields[fieldName] });\n     }    };\n\n    function getData$4(ref) {\n        var seriesValues = ref.seriesValues;\n        var categoryAxis = ref.categoryAxis;\n        var options = ref.options;\n\n        var order = (options.trendline || {}).order;\n        var ref$1 = calculatePolynomial(seriesValues(), valueGetter$4(options.field), order);\n        var count = ref$1.count;\n        var valueMapper = ref$1.valueMapper;\n\n        if (count > 0) {\n            // Polynomial trendline equation:\n            // y = aN * x^N + ... + a2 * x^2 + a1 * x + a0\n\n            return getTrendlineData(function (x) { return valueMapper(x); }, categoryAxis);\n        }\n\n        return null;\n    }\n\n    function powerTrendline(context) {\n        var options = context.options;\n        var categoryAxis = context.categoryAxis;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$5({ seriesValues: seriesValues, categoryAxis: categoryAxis, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'line',\n                data: data,\n                categoryField: 'category',\n                field: 'value'});\n        }\n\n        return null;\n    }\n\n    var valueGetter$5 = function (fieldName) { return function (ref) {\n            var categoryIx = ref.categoryIx;\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: Math.log(categoryIx + 1), yValue: Math.log(valueFields[fieldName]) });\n     }    };\n\n    function getData$5(ref) {\n        var seriesValues = ref.seriesValues;\n        var categoryAxis = ref.categoryAxis;\n        var options = ref.options;\n\n        var sourceValues = seriesValues();\n        if (!checkAllPositive(sourceValues, options.field)) {\n            return null;\n        }\n\n        var ref$1 = calculateSlope(sourceValues, valueGetter$5(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        if (count > 0) {\n            // Power trendline equation:\n            // y = a * x ^ b\n            var a = Math.exp(intercept);\n            var b = slope;\n\n            return getTrendlineData(function (x) { return a * Math.pow(x, b); }, categoryAxis);\n        }\n\n        return null;\n    }\n\n    var registry = {};\n    registry[TRENDLINE_EXPONENTIAL] = exponentialTrendline;\n    registry[TRENDLINE_LINEAR] = linearTrendline;\n    registry[TRENDLINE_LOGARITHMIC] = logarithmicTrendline;\n    registry[TRENDLINE_MOVING_AVERAGE] = movingAverageTrendline;\n    registry[TRENDLINE_POLYNOMIAL] = polynomialTrendline;\n    registry[TRENDLINE_POWER] = powerTrendline;\n\n    var AREA_SERIES = [ AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA ];\n    var OUT_OF_RANGE_SERIES = [ LINE, VERTICAL_LINE ].concat(AREA_SERIES);\n\n    var CategoricalPlotArea = PlotAreaBase.extend({\n        initFields: function(series) {\n            var this$1$1 = this;\n\n            this.namedCategoryAxes = {};\n            this.namedValueAxes = {};\n            this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n            this._seriesPointsCache = {};\n            this._currentPointsCache = {};\n\n            if (series.length > 0) {\n                this.invertAxes = inArray(\n                    series[0].type, [ BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA,\n                        RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT ]\n                );\n\n                for (var i = 0; i < series.length; i++) {\n                    var stack = series[i].stack;\n                    if (stack && stack.type === \"100%\") {\n                        this$1$1.stack100 = true;\n                        break;\n                    }\n                }\n            }\n        },\n\n        render: function(panes) {\n            if (panes === void 0) { panes = this.panes; }\n\n            this.series = [].concat( this.originalSeries );\n            this.createCategoryAxes(panes);\n\n            this.aggregateCategories(panes);\n            this.createTrendlineSeries(panes);\n\n            this.createCategoryAxesLabels(panes);\n            this.createCharts(panes);\n            this.createValueAxes(panes);\n        },\n\n        removeAxis: function(axis) {\n            var axisName = axis.options.name;\n\n            PlotAreaBase.fn.removeAxis.call(this, axis);\n\n            if (axis instanceof CategoryAxis) {\n                delete this.namedCategoryAxes[axisName];\n            } else {\n                this.valueAxisRangeTracker.reset(axisName);\n                delete this.namedValueAxes[axisName];\n            }\n\n            if (axis === this.categoryAxis) {\n                delete this.categoryAxis;\n            }\n\n            if (axis === this.valueAxis) {\n                delete this.valueAxis;\n            }\n        },\n\n        trendlineFactory: function(options, series) {\n            var categoryAxis = this.seriesCategoryAxis(options);\n            var seriesValues = this.seriesValues.bind(this, series.index);\n\n            var trendline = trendlineFactory(registry, options.type, {\n                options: options,\n                categoryAxis: categoryAxis,\n                seriesValues: seriesValues\n            });\n\n            if (trendline) {\n                // Inherit settings\n                trendline.categoryAxis = series.categoryAxis;\n                trendline.valueAxis = series.valueAxis;\n\n                return this.filterSeries(trendline, categoryAxis);\n            }\n\n            return trendline;\n        },\n\n        trendlineAggregateForecast: function() {\n            return this.series\n                .map(function (series) { return (series.trendline || {}).forecast; })\n                .filter(function (forecast) { return forecast !== undefined; })\n                .reduce(function (result, forecast) { return ({\n                    before: Math.max(result.before, forecast.before || 0),\n                    after: Math.max(result.after, forecast.after || 0)\n                }); }, { before: 0, after: 0 });\n        },\n\n        seriesValues: function(seriesIx, range) {\n            var this$1$1 = this;\n\n            var result = [];\n\n            var series = this.srcSeries[seriesIx];\n            var categoryAxis = this.seriesCategoryAxis(series);\n            var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n            if (dateAxis) {\n                this._seriesPointsCache = {};\n                this._currentPointsCache = {};\n                categoryAxis.options.dataItems = [];\n                series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());\n            }\n\n            var min = range ? range.min : 0;\n            var max = range ? range.max : series.data.length;\n            for (var categoryIx = min; categoryIx < max; categoryIx++) {\n                var data = this$1$1.bindPoint(series, categoryIx);\n                result.push({ categoryIx: categoryIx, category: data.fields.category, valueFields: data.valueFields });\n            }\n\n            return result;\n        },\n\n        createCharts: function(panes) {\n            var this$1$1 = this;\n\n            var seriesByPane = this.groupSeriesByPane();\n\n            for (var i = 0; i < panes.length; i++) {\n                var pane = panes[i];\n                var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n                this$1$1.addToLegend(paneSeries);\n\n                var visibleSeries = this$1$1.filterVisibleSeries(paneSeries);\n                if (!visibleSeries) {\n                    continue;\n                }\n\n                var groups = this$1$1.groupSeriesByCategoryAxis(visibleSeries);\n                for (var groupIx = 0; groupIx < groups.length; groupIx++) {\n                    this$1$1.createChartGroup(groups[groupIx], pane);\n                }\n            }\n        },\n\n        createChartGroup: function(series, pane) {\n            this.createAreaChart(\n                filterSeriesByType(series, [ AREA, VERTICAL_AREA ]), pane\n            );\n\n            this.createRangeAreaChart(\n                filterSeriesByType(series, [ RANGE_AREA, VERTICAL_RANGE_AREA ]), pane\n            );\n\n            this.createBarChart(\n                filterSeriesByType(series, [ COLUMN, BAR ]), pane\n            );\n\n            this.createRangeBarChart(\n                filterSeriesByType(series, [ RANGE_COLUMN, RANGE_BAR ]), pane\n            );\n\n            this.createBulletChart(\n                filterSeriesByType(series, [ BULLET, VERTICAL_BULLET ]), pane\n            );\n\n            this.createCandlestickChart(\n                filterSeriesByType(series, CANDLESTICK), pane\n            );\n\n            this.createBoxPlotChart(\n                filterSeriesByType(series, [ BOX_PLOT, VERTICAL_BOX_PLOT ]), pane\n            );\n\n            this.createOHLCChart(\n                filterSeriesByType(series, OHLC), pane\n            );\n\n            this.createWaterfallChart(\n                filterSeriesByType(series, [ WATERFALL, HORIZONTAL_WATERFALL ]), pane\n            );\n\n            this.createLineChart(\n                filterSeriesByType(series, [ LINE, VERTICAL_LINE ]), pane\n            );\n        },\n\n        aggregateCategories: function(panes) {\n            var this$1$1 = this;\n\n            var series = [].concat( this.series );\n            var processedSeries = [];\n            this._currentPointsCache = {};\n            this._seriesPointsCache = this._seriesPointsCache || {};\n\n            for (var i = 0; i < series.length; i++) {\n                var currentSeries = series[i];\n\n                if (!this$1$1.isTrendline(currentSeries)) {\n                    var categoryAxis = this$1$1.seriesCategoryAxis(currentSeries);\n                    var axisPane = this$1$1.findPane(categoryAxis.options.pane);\n                    var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n                    if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n                        currentSeries = this$1$1.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());\n                    } else {\n                        currentSeries = this$1$1.filterSeries(currentSeries, categoryAxis);\n                    }\n                }\n\n                processedSeries.push(currentSeries);\n            }\n\n            this._seriesPointsCache = this._currentPointsCache;\n            this._currentPointsCache = null;\n\n            this.srcSeries = series;\n            this.series = processedSeries;\n        },\n\n        filterSeries: function(series, categoryAxis) {\n            var dataLength = (series.data || {}).length;\n            categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n            if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {\n                return series;\n            }\n\n            var range = categoryAxis.currentRangeIndices();\n            var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n            var currentSeries = deepExtend({}, series);\n\n            currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n            if (outOfRangePoints) {\n                createOutOfRangePoints(currentSeries, range, dataLength, function (idx) { return ({\n                    item: series.data[idx],\n                    category: categoryAxis.categoryAt(idx, true),\n                    categoryIx: idx - range.min\n                }); }, function (idx) { return defined(series.data[idx]); });\n            }\n\n            return currentSeries;\n        },\n\n        clearSeriesPointsCache: function() {\n            this._seriesPointsCache = {};\n        },\n\n        seriesSourcePoints: function(series, categoryAxis) {\n            var this$1$1 = this;\n\n            var key = (series.index) + \";\" + (categoryAxis.categoriesHash());\n            if (this._seriesPointsCache && this._seriesPointsCache[key]) {\n                this._currentPointsCache[key] = this._seriesPointsCache[key];\n                return this._seriesPointsCache[key];\n            }\n\n            var axisOptions = categoryAxis.options;\n            var srcCategories = axisOptions.srcCategories;\n            var dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n            var srcData = series.data;\n            var result = [];\n            if (!dateAxis) {\n                categoryAxis.indexCategories();\n            }\n\n            for (var idx = 0; idx < srcData.length; idx++) {\n                var category = SeriesBinder.current.bindPoint(series, idx).fields.category;\n                if (dateAxis) {\n                    category = parseDateCategory(category, srcData[idx], this$1$1.chartService.intl);\n                }\n\n                if (!defined(category)) {\n                    category = srcCategories[idx];\n                }\n\n                if (defined(category) && category !== null) {\n                    var categoryIx = categoryAxis.totalIndex(category);\n                    result[categoryIx] = result[categoryIx] || { items: [], category: category };\n                    result[categoryIx].items.push(idx);\n                }\n            }\n\n            this._currentPointsCache[key] = result;\n\n            return result;\n        },\n\n        aggregateSeries: function(series, categoryAxis, range) {\n            var srcData = series.data;\n            if (!srcData.length) {\n                return series;\n            }\n\n            var srcPoints = this.seriesSourcePoints(series, categoryAxis);\n            var result = deepExtend({}, series);\n            var aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n            var data = result.data = [];\n\n            var dataItems = categoryAxis.options.dataItems || [];\n\n            var categoryItem = function (idx) {\n                var categoryIdx = idx - range.min;\n                var point = srcPoints[idx];\n                if (!point) {\n                    point = srcPoints[idx] = {};\n                }\n\n                point.categoryIx = categoryIdx;\n\n                if (!point.item) {\n                    var category = categoryAxis.categoryAt(idx, true);\n                    point.category = category;\n                    point.item = aggregator.aggregatePoints(point.items, category);\n                }\n\n                return point;\n            };\n\n            for (var idx = range.min; idx <= range.max; idx++) {\n                var point = categoryItem(idx);\n                data[point.categoryIx] = point.item;\n\n                if (point.items && point.items.length) {\n                    dataItems[point.categoryIx] = point.item;\n                }\n            }\n\n            if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n                createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function (idx) { return srcPoints[idx]; });\n            }\n\n            categoryAxis.options.dataItems = dataItems;\n\n            return result;\n        },\n\n        appendChart: function(chart, pane) {\n            var series = chart.options.series;\n            var categoryAxis = this.seriesCategoryAxis(series[0]);\n            var categories = categoryAxis.options.categories;\n            var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n            if (categoriesToAdd > 0) {//consider setting an option to axis instead of adding fake categories\n                categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n                while (categoriesToAdd--) {\n                    categories.push(\"\");\n                }\n            }\n\n            this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n        },\n\n        seriesPaneName: function(series) {\n            var options = this.options;\n            var axisName = series.axis;\n            var axisOptions = [].concat(options.valueAxis);\n            var axis = grep(axisOptions, function(a) { return a.name === axisName; })[0];\n            var panes = options.panes || [ {} ];\n            var defaultPaneName = (panes[0] || {}).name || \"default\";\n            var paneName = (axis || {}).pane || defaultPaneName;\n\n            return paneName;\n        },\n\n        seriesCategoryAxis: function(series) {\n            var axisName = series.categoryAxis;\n            var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n            if (!axis) {\n                throw new Error(\"Unable to locate category axis with name \" + axisName);\n            }\n\n            return axis;\n        },\n\n        stackableChartOptions: function(series, pane) {\n            var anyStackedSeries = series.some(function (s) { return s.stack; });\n            var isStacked100 = series.some(function (s) { return s.stack && s.stack.type === \"100%\"; });\n            var clip = pane.options.clip;\n\n            return {\n                defaultStack: series[0].stack,\n                isStacked: anyStackedSeries,\n                isStacked100: isStacked100,\n                clip: clip\n            };\n        },\n\n        groupSeriesByCategoryAxis: function(series) {\n            var categoryAxes = [];\n            var unique = {};\n            for (var idx = 0; idx < series.length; idx++) {\n                var name = series[idx].categoryAxis || \"$$default$$\";\n                if (!dataviz.hasOwnProperty(unique, name)) {\n                    unique[name] = true;\n                    categoryAxes.push(name);\n                }\n            }\n\n            var groups = [];\n            for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n                var axis = categoryAxes[axisIx];\n                var axisSeries = groupSeries(series, axis, axisIx);\n                if (axisSeries.length === 0) {\n                    continue;\n                }\n\n                groups.push(axisSeries);\n            }\n\n            return groups;\n        },\n\n        createBarChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var barChart = new BarChart(this, $.extend({\n                series: series,\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                spacing: firstSeries.spacing\n            }, this.stackableChartOptions(series, pane)));\n\n            this.appendChart(barChart, pane);\n        },\n\n        createRangeBarChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var rangeColumnChart = new RangeBarChart(this, {\n                series: series,\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                spacing: firstSeries.spacing\n            });\n\n            this.appendChart(rangeColumnChart, pane);\n        },\n\n        createBulletChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var bulletChart = new BulletChart(this, {\n                series: series,\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                spacing: firstSeries.spacing,\n                clip: pane.options.clip\n            });\n\n            this.appendChart(bulletChart, pane);\n        },\n\n        createLineChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var lineChart = new LineChart(this, $.extend({\n                invertAxes: this.invertAxes,\n                series: series\n            }, this.stackableChartOptions(series, pane)));\n\n            this.appendChart(lineChart, pane);\n        },\n\n        createAreaChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var areaChart = new AreaChart(this, $.extend({\n                invertAxes: this.invertAxes,\n                series: series\n            }, this.stackableChartOptions(series, pane)));\n\n            this.appendChart(areaChart, pane);\n        },\n\n        createRangeAreaChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var rangeAreaChart = new RangeAreaChart(this, {\n                invertAxes: this.invertAxes,\n                series: series,\n                clip: pane.options.clip\n            });\n\n            this.appendChart(rangeAreaChart, pane);\n        },\n\n        createOHLCChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var chart = new OHLCChart(this, {\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                series: series,\n                spacing: firstSeries.spacing,\n                clip: pane.options.clip\n            });\n\n            this.appendChart(chart, pane);\n        },\n\n        createCandlestickChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var chart = new CandlestickChart(this, {\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                series: series,\n                spacing: firstSeries.spacing,\n                clip: pane.options.clip\n            });\n\n            this.appendChart(chart, pane);\n        },\n\n        createBoxPlotChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var chart = new BoxPlotChart(this, {\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                series: series,\n                spacing: firstSeries.spacing,\n                clip: pane.options.clip\n            });\n\n            this.appendChart(chart, pane);\n        },\n\n        createWaterfallChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var waterfallChart = new WaterfallChart(this, {\n                series: series,\n                invertAxes: this.invertAxes,\n                gap: firstSeries.gap,\n                spacing: firstSeries.spacing\n            });\n\n            this.appendChart(waterfallChart, pane);\n        },\n\n        axisRequiresRounding: function(categoryAxisName, categoryAxisIndex) {\n            var this$1$1 = this;\n\n            var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n            for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n                var currentSeries = this$1$1.series[seriesIx];\n                if (inArray(currentSeries.type, AREA_SERIES)) {\n                    var line = currentSeries.line;\n                    if (line && line.style === STEP) {\n                        centeredSeries.push(currentSeries);\n                    }\n                }\n            }\n\n            for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {\n                var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || \"\";\n                if (seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) {\n                    return true;\n                }\n            }\n        },\n\n        aggregatedAxis: function(categoryAxisName, categoryAxisIndex) {\n            var series = this.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var seriesAxis = series[seriesIx].categoryAxis || \"\";\n                if ((seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) && series[seriesIx].categoryField) {\n                    return true;\n                }\n            }\n        },\n\n        createCategoryAxesLabels: function() {\n            var axes = this.axes;\n            for (var i = 0; i < axes.length; i++) {\n                if (axes[i] instanceof CategoryAxis) {\n                    axes[i].createLabels();\n                }\n            }\n        },\n\n        createCategoryAxes: function(panes) {\n            var this$1$1 = this;\n\n            var invertAxes = this.invertAxes;\n            var definitions = [].concat(this.options.categoryAxis);\n            var axes = [];\n\n            for (var i = 0; i < definitions.length; i++) {\n                var axisOptions = definitions[i];\n                var axisPane = this$1$1.findPane(axisOptions.pane);\n\n                if (inArray(axisPane, panes)) {\n                    var name = axisOptions.name;\n                    var categories = axisOptions.categories; if (categories === void 0) { categories = []; }\n                    axisOptions = deepExtend({\n                        vertical: invertAxes,\n                        reverse: !invertAxes && this$1$1.chartService.rtl,\n                        axisCrossingValue: invertAxes ? MAX_VALUE : 0\n                    }, axisOptions);\n\n                    if (!defined(axisOptions.justified)) {\n                        axisOptions.justified = this$1$1.isJustified();\n                    }\n\n                    if (this$1$1.axisRequiresRounding(name, i)) {\n                        axisOptions.justified = false;\n                    }\n\n                    var categoryAxis = (void 0);\n\n                    if (isDateAxis(axisOptions, categories[0])) {\n                        axisOptions._forecast = this$1$1.trendlineAggregateForecast();\n                        categoryAxis = new dataviz.DateCategoryAxis(axisOptions, this$1$1.chartService);\n                    } else {\n                        categoryAxis = new CategoryAxis(axisOptions, this$1$1.chartService);\n                    }\n\n                    definitions[i].categories = categoryAxis.options.srcCategories;\n\n                    if (name) {\n                        if (this$1$1.namedCategoryAxes[name]) {\n                            throw new Error((\"Category axis with name \" + name + \" is already defined\"));\n                        }\n                        this$1$1.namedCategoryAxes[name] = categoryAxis;\n                    }\n\n                    categoryAxis.axisIndex = i;\n                    axes.push(categoryAxis);\n                    this$1$1.appendAxis(categoryAxis);\n                }\n            }\n\n            var primaryAxis = this.categoryAxis || axes[0];\n            this.categoryAxis = primaryAxis;\n\n            if (invertAxes) {\n                this.axisY = primaryAxis;\n            } else {\n                this.axisX = primaryAxis;\n            }\n        },\n\n        isJustified: function() {\n            var series = this.series;\n\n            for (var i = 0; i < series.length; i++) {\n                var currentSeries = series[i];\n                if (!inArray(currentSeries.type, AREA_SERIES)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        createValueAxes: function(panes) {\n            var this$1$1 = this;\n\n            var tracker = this.valueAxisRangeTracker;\n            var defaultRange = tracker.query();\n            var definitions = [].concat(this.options.valueAxis);\n            var invertAxes = this.invertAxes;\n            var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };\n            var axes = [];\n\n            if (this.stack100) {\n                baseOptions.roundToMajorUnit = false;\n                baseOptions.labels = { format: \"P0\" };\n            }\n\n            for (var i = 0; i < definitions.length; i++) {\n                var axisOptions = definitions[i];\n                var axisPane = this$1$1.findPane(axisOptions.pane);\n\n                if (inArray(axisPane, panes)) {\n                    var name = axisOptions.name;\n                    var defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n                    var range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n                    if (i === 0 && range && defaultRange) {\n                        range.min = Math.min(range.min, defaultRange.min);\n                        range.max = Math.max(range.max, defaultRange.max);\n                    }\n\n                    var axisType = (void 0);\n                    if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n                        axisType = dataviz.LogarithmicAxis;\n                    } else {\n                        axisType = dataviz.NumericAxis;\n                    }\n\n                    var valueAxis = new axisType(range.min, range.max,\n                        deepExtend({}, baseOptions, axisOptions),\n                        this$1$1.chartService\n                    );\n\n                    if (name) {\n                        if (this$1$1.namedValueAxes[name]) {\n                            throw new Error((\"Value axis with name \" + name + \" is already defined\"));\n                        }\n                        this$1$1.namedValueAxes[name] = valueAxis;\n                    }\n                    valueAxis.axisIndex = i;\n\n                    axes.push(valueAxis);\n                    this$1$1.appendAxis(valueAxis);\n                }\n            }\n\n            var primaryAxis = this.valueAxis || axes[0];\n            this.valueAxis = primaryAxis;\n\n            if (invertAxes) {\n                this.axisX = primaryAxis;\n            } else {\n                this.axisY = primaryAxis;\n            }\n        },\n\n        _dispatchEvent: function(chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n            var point = new Point(coords.x, coords.y);\n            var pane = this.pointPane(point);\n            var categories = [];\n            var values = [];\n\n            if (!pane) {\n                return;\n            }\n\n            var allAxes = pane.axes;\n            for (var i = 0; i < allAxes.length; i++) {\n                var axis = allAxes[i];\n                if (axis.getValue) {\n                    appendIfNotNull(values, axis.getValue(point));\n                } else {\n                    appendIfNotNull(categories, axis.getCategory(point));\n                }\n            }\n\n            if (categories.length === 0) {\n                appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n            }\n\n            if (categories.length > 0 && values.length > 0) {\n                chart.trigger(eventType, {\n                    element: eventElement(e),\n                    originalEvent: e,\n                    category: singleItemOrArray(categories),\n                    value: singleItemOrArray(values)\n                });\n            }\n        },\n\n        pointPane: function(point) {\n            var panes = this.panes;\n\n            for (var i = 0; i < panes.length; i++) {\n                var currentPane = panes[i];\n                if (currentPane.contentBox.containsPoint(point)) {\n                    return currentPane;\n                }\n            }\n        },\n\n        updateAxisOptions: function(axis, options) {\n            updateAxisOptions(this.options, axis, options);\n            updateAxisOptions(this.originalOptions, axis, options);\n        },\n\n        _pointsByVertical: function(basePoint, offset) {\n            if (offset === void 0) { offset = 0; }\n\n            if (this.invertAxes) {\n                return this._siblingsBySeriesIndex(basePoint.series.index, offset);\n            }\n\n            return this._siblingsByPointIndex(basePoint.getIndex());\n        },\n\n        _pointsByHorizontal: function(basePoint, offset) {\n            if (offset === void 0) { offset = 0; }\n\n            if (this.invertAxes) {\n                return this._siblingsByPointIndex(basePoint.getIndex());\n            }\n\n            var siblings = this._siblingsBySeriesIndex(basePoint.series.index, offset);\n\n            if (this.chartService.rtl) {\n                return siblings.reverse();\n            }\n\n            return siblings;\n        },\n\n        _siblingsByPointIndex: function(pointIndex) {\n            var this$1$1 = this;\n\n            var charts = this.charts;\n            var result = [];\n\n            for (var i = 0; i < charts.length; i++) {\n                var chart = charts[i];\n\n                if (chart.pane && chart.pane.options.name === \"_navigator\") {\n                    continue;\n                }\n\n                var chartPoints = chart.points\n                    .filter(function (point) { return point && point.visible !== false && point.getIndex() === pointIndex; }\n                    );\n\n                result.push.apply(result, chartPoints.sort(this$1$1._getSeriesCompareFn(chartPoints[0])));\n            }\n\n            return result;\n        },\n\n        _siblingsBySeriesIndex: function(seriesIndex, offset) {\n            var index = cycleIndex(seriesIndex + offset, this.series.length);\n\n            return this.pointsBySeriesIndex(index);\n        },\n\n        _getSeriesCompareFn: function(point) {\n            var isStacked = this._isInStackedSeries(point);\n\n            if (isStacked && this.invertAxes || !isStacked && !this.invertAxes) {\n                return function (a, b) { return a.box.center().x - b.box.center().x; };\n            }\n\n            return function (a, b) { return a.box.center().y - b.box.center().y; };\n        },\n\n        _isInStackedSeries: function(point) {\n            var sortableSeries = inArray(point.series.type,\n                [ AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, LINE, VERTICAL_LINE, RADAR_LINE, RADAR_AREA]);\n\n            var stackableSeries = inArray(point.series.type, [ COLUMN, BAR]);\n\n            return sortableSeries || stackableSeries && point.options.isStacked;\n        }\n    });\n\n    function updateAxisOptions(targetOptions, axis, options) {\n        var axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n        deepExtend(axesOptions[axis.axisIndex], options);\n    }\n\n    function groupSeries(series, axis, axisIx) {\n        return grep(series, function(s) {\n            return (axisIx === 0 && !s.categoryAxis) || (s.categoryAxis === axis);\n        });\n    }\n\n    setDefaultOptions(CategoricalPlotArea, {\n        categoryAxis: {},\n        valueAxis: {}\n    });\n\n    deepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\n\n    var Highlight = Class.extend({\n        init: function() {\n\n            this._points = [];\n        },\n\n        destroy: function() {\n            this._points = [];\n        },\n\n        show: function(points, opacity) {\n            var this$1$1 = this;\n\n            var arrayPoints = [].concat(points);\n            this.hide();\n\n            for (var i = 0; i < arrayPoints.length; i++) {\n                var point = arrayPoints[i];\n                if (point && point.toggleHighlight && point.hasHighlight()) {\n                    this$1$1.togglePointHighlight(point, true, opacity);\n                    this$1$1._points.push(point);\n                }\n            }\n        },\n\n        togglePointHighlight: function(point, show, opacity) {\n            var toggleHandler = (point.options.highlight || {}).toggle;\n            if (toggleHandler) {\n                var eventArgs = {\n                    category: point.category,\n                    series: point.series,\n                    dataItem: point.dataItem,\n                    value: point.value,\n                    stackValue: point.stackValue,\n                    preventDefault: preventDefault,\n                    visual: point.highlightVisual(),\n                    show: show\n                };\n                toggleHandler(eventArgs);\n                if (!eventArgs._defaultPrevented) {\n                    point.toggleHighlight(show, opacity);\n                }\n            } else {\n                point.toggleHighlight(show, opacity);\n            }\n        },\n\n        hide: function() {\n            var this$1$1 = this;\n\n            var points = this._points;\n            while (points.length) {\n                this$1$1.togglePointHighlight(points.pop(), false);\n            }\n        },\n\n        isHighlighted: function(element) {\n            var points = this._points;\n\n            for (var i = 0; i < points.length; i++) {\n                var point = points[i];\n                if (element === point) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    });\n\n    function preventDefault() {\n        this._defaultPrevented = true;\n    }\n\n    function acceptKey(e, mouseKey) {\n        var key = (mouseKey || \"\").toLowerCase();\n        var event = e.event;\n        var accept = (key === \"none\" && !(event.ctrlKey || event.shiftKey || event.altKey)) || event[key + \"Key\"];\n\n        return accept;\n    }\n\n    function toChartAxisRanges(axisRanges) {\n        var ranges = {};\n        for (var idx = 0; idx < axisRanges.length; idx++) {\n            var axisRange = axisRanges[idx];\n            if (axisRange.axis.options.name) {\n                ranges[axisRange.axis.options.name] = {\n                    min: axisRange.range.min,\n                    max: axisRange.range.max\n                };\n            }\n        }\n        return ranges;\n    }\n\n    var Pannable = Class.extend({\n        init: function(plotArea, options) {\n\n            this.plotArea = plotArea;\n            this.options = deepExtend({}, this.options, options);\n        },\n\n        start: function(e) {\n            this._active = acceptKey(e, this.options.key);\n            return this._active;\n        },\n\n        move: function(e) {\n            if (this._active) {\n                var axisRanges = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));\n                if (axisRanges.length) {\n                    this.axisRanges = axisRanges;\n                    return toChartAxisRanges(axisRanges);\n                }\n            }\n        },\n\n        end: function() {\n            var active = this._active;\n            this._active = false;\n\n            return active;\n        },\n\n        pan: function() {\n            var ref = this;\n            var plotArea = ref.plotArea;\n            var axisRanges = ref.axisRanges;\n            if (axisRanges.length) {\n                for (var idx = 0; idx < axisRanges.length; idx++) {\n                    var range = axisRanges[idx];\n                    plotArea.updateAxisOptions(range.axis, range.range);\n                }\n                plotArea.redraw(plotArea.panes);\n            }\n        },\n\n        destroy: function() {\n            delete this.plotArea;\n        },\n\n        _panAxes: function(e, position) {\n            var plotArea = this.plotArea;\n            var delta = -e[position].delta;\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var updatedAxes = [];\n\n            if (delta !== 0 && (lock || \"\").toLowerCase() !== position) {\n                var axes = plotArea.axes;\n                for (var idx = 0; idx < axes.length; idx++) {\n                    var axis = axes[idx];\n\n                    if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {\n                        var range = axis.pan(delta);\n\n                        if (range) {\n                            range.limitRange = true;\n                            updatedAxes.push({\n                                axis: axis,\n                                range: range\n                            });\n                        }\n                    }\n                }\n            }\n\n            return updatedAxes;\n        }\n    });\n\n    Pannable.prototype.options = {\n        key: \"none\",\n        lock: \"none\"\n    };\n\n    var ZoomSelection = Class.extend({\n        init: function(chart, options) {\n\n            this.chart = chart;\n            this.options = deepExtend({}, this.options, options);\n            this.createElement();\n        },\n\n        createElement: function() {\n            var marquee = this._marquee = document.createElement(\"div\");\n            marquee.className = \"k-marquee\";\n            var marqueeColor = document.createElement(\"div\");\n            marqueeColor.className = \"k-marquee-color\";\n            marquee.appendChild(marqueeColor);\n        },\n\n        removeElement: function() {\n            if (this._marquee.parentNode) {\n                this._marquee.parentNode.removeChild(this._marquee);\n            }\n        },\n\n        setStyles: function(styles) {\n            elementStyles(this._marquee, styles);\n        },\n\n        start: function(e) {\n            if (acceptKey(e, this.options.key)) {\n                var chart = this.chart;\n                var point = chart._eventCoordinates(e);\n                var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);\n                var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;\n\n                if (zoomPane && clipBox) {\n                    var offset = this._elementOffset();\n\n                    clipBox.translate(offset.left, offset.top);\n                    this._zoomPaneClipBox = clipBox;\n\n                    document.body.appendChild(this._marquee);\n                    this.setStyles({\n                        left: e.pageX + 1,\n                        top: e.pageY + 1,\n                        width: 0,\n                        height: 0\n                    });\n\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        _elementOffset: function() {\n            var chartElement = this.chart.element;\n            var ref = elementStyles(chartElement, [ \"paddingLeft\", \"paddingTop\" ]);\n            var paddingLeft = ref.paddingLeft;\n            var paddingTop = ref.paddingTop;\n            var offset = dataviz.elementOffset(chartElement);\n\n            return {\n                left: paddingLeft + offset.left,\n                top: paddingTop + offset.top\n            };\n        },\n\n        move: function(e) {\n            var zoomPane = this._zoomPane;\n            if (zoomPane) {\n                this.setStyles(this._selectionPosition(e));\n            }\n        },\n\n        end: function(e) {\n            var zoomPane = this._zoomPane;\n            if (zoomPane) {\n                var elementOffset$$1 = this._elementOffset();\n                var selectionPosition = this._selectionPosition(e);\n                selectionPosition.left -= elementOffset$$1.left;\n                selectionPosition.top -= elementOffset$$1.top;\n\n                var start = { x: selectionPosition.left, y: selectionPosition.top };\n                var end = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };\n                this._updateAxisRanges(start, end);\n\n                this.removeElement();\n                delete this._zoomPane;\n\n                return toChartAxisRanges(this.axisRanges);\n            }\n        },\n\n        zoom: function() {\n            var axisRanges = this.axisRanges;\n            if (axisRanges && axisRanges.length) {\n                var plotArea = this.chart._plotArea;\n                for (var idx = 0; idx < axisRanges.length; idx++) {\n                    var axisRange = axisRanges[idx];\n                    plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n                }\n                plotArea.redraw(plotArea.panes);\n            }\n        },\n\n        destroy: function() {\n            this.removeElement();\n            delete this._marquee;\n            delete this.chart;\n        },\n\n        _updateAxisRanges: function(start, end) {\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var axisRanges = [];\n\n            var axes = this._zoomPane.axes;\n            for (var idx = 0; idx < axes.length; idx++) {\n                var axis = axes[idx];\n                var vertical = axis.options.vertical;\n                if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {\n                    var range = axis.pointsRange(start, end);\n                    if (range) {\n                        axisRanges.push({\n                            axis: axis,\n                            range: range\n                        });\n                    }\n                }\n            }\n\n            this.axisRanges = axisRanges;\n        },\n\n        _selectionPosition: function(e) {\n            var clipBox = this._zoomPaneClipBox;\n            var startLocation = {\n                x: e.x.startLocation,\n                y: e.y.startLocation\n            };\n            var pageX = e.x.location;\n            var pageY = e.y.location;\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var left = Math.min(startLocation.x, pageX);\n            var top = Math.min(startLocation.y, pageY);\n            var width = Math.abs(startLocation.x - pageX);\n            var height = Math.abs(startLocation.y - pageY);\n\n            if (lock === X) {\n                left = clipBox.x1;\n                width = clipBox.width();\n            }\n            if (lock === Y) {\n                top = clipBox.y1;\n                height = clipBox.height();\n            }\n\n            if (pageX > clipBox.x2) {\n                width = clipBox.x2 - startLocation.x;\n            }\n\n            if (pageX < clipBox.x1) {\n                width = startLocation.x - clipBox.x1;\n            }\n\n            if (pageY > clipBox.y2) {\n                height = clipBox.y2 - startLocation.y;\n            }\n\n            if (pageY < clipBox.y1) {\n                height = startLocation.y - clipBox.y1;\n            }\n\n            return {\n                left: Math.max(left, clipBox.x1),\n                top: Math.max(top, clipBox.y1),\n                width: width,\n                height: height\n            };\n        }\n    });\n\n    ZoomSelection.prototype.options = {\n        key: \"shift\",\n        lock: \"none\"\n    };\n\n    var ref = drawing.util;\n    var limitValue$1 = ref.limitValue;\n    var valueOrDefault$1 = ref.valueOrDefault;\n\n    // Limit the zoom rate between 1% and 90% per mousewheel event.\n    // At zoom rates close to 100% the axis range quickly becomes 0.\n    var MIN_RATE = 0.01;\n    var MAX_RATE = 0.9;\n    var DEFAULT_RATE = 0.3;\n\n    var MousewheelZoom = Class.extend({\n        init: function(chart, options) {\n\n            this.chart = chart;\n            this.options = deepExtend({\n                rate: DEFAULT_RATE\n            }, this.options, options);\n        },\n\n        updateRanges: function(delta, coords) {\n            var this$1$1 = this;\n\n            var lock = (this.options.lock || \"\").toLowerCase();\n            var axisRanges = [];\n            var axes = this.chart._plotArea.axes;\n\n            for (var idx = 0; idx < axes.length; idx++) {\n                var axis = axes[idx];\n                var vertical = axis.options.vertical;\n\n                if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {\n                    var rate = limitValue$1(this$1$1.options.rate, MIN_RATE, MAX_RATE);\n                    var range = axis.zoomRange(-delta * rate, coords);\n\n                    if (range) {\n                        axisRanges.push({\n                            axis: axis,\n                            range: range\n                        });\n                    }\n                }\n            }\n\n            this.axisRanges = axisRanges;\n            return toChartAxisRanges(axisRanges);\n        },\n\n        zoom: function() {\n            var axisRanges = this.axisRanges;\n            var plotArea = this.chart._plotArea;\n\n            if (axisRanges && axisRanges.length && plotArea.updateAxisOptions) {\n                for (var idx = 0; idx < axisRanges.length; idx++) {\n                    var axisRange = axisRanges[idx];\n                    plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\n                }\n                plotArea.redraw(plotArea.panes);\n            }\n        },\n\n        destroy: function() {\n            delete this.chart;\n        }\n    });\n\n    var LegendLayout = ChartElement.extend({\n        init: function(options, chartService) {\n            ChartElement.fn.init.call(this, options);\n\n            this.chartService = chartService;\n        },\n\n        render: function() {\n            var ref = this;\n            var children = ref.children;\n            var options = ref.options;\n            var vertical = options.vertical;\n\n            this.visual = new drawing.Layout(null, {\n                spacing: vertical ? 0 : options.spacing,\n                lineSpacing: vertical ? options.spacing : 0,\n                orientation: vertical ? datavizConstants.VERTICAL : datavizConstants.HORIZONTAL,\n                reverse: options.rtl,\n                alignItems: vertical ? START : CENTER\n            });\n\n            for (var idx = 0; idx < children.length; idx++) {\n                var legendItem = children[idx];\n                legendItem.reflow(new Box());\n                legendItem.renderVisual();\n            }\n        },\n\n        reflow: function(box) {\n            this.visual.rect(box.toRect());\n            this.visual.reflow();\n            var bbox = this.visual.clippedBBox();\n\n            if (bbox) {\n                this.box = dataviz.rectToBox(bbox);\n            } else {\n                this.box = new Box();\n            }\n        },\n\n        renderVisual: function() {\n            this.addVisual();\n        },\n\n        createVisual: function() {}\n    });\n\n    var DEFAULT_MARKER_SIZE = 10;\n    var DEFAULT_MARKER_BORDER_WIDTH = 2;\n\n    var LegendItemMarker = ShapeElement.extend({\n        visualStyle: function() {\n            var options = this.markerOptions();\n            var border = options.border;\n\n            return {\n                stroke: {\n                    width: border.width,\n                    color: border.color,\n                    opacity: valueOrDefault$1(border.opacity, options.opacity),\n                    dashType: border.dashType\n                },\n                fill: {\n                    color: options.background,\n                    opacity: options.opacity\n                },\n                cursor: options.cursor\n            };\n        },\n\n        markerOptions: function() {\n            return this.options;\n        },\n\n        markerHighlightOptions: function() {\n            var options = this.markerOptions();\n            var borderWidth = options.highlight.border.width;\n\n            return deepExtend(\n                {},\n                options,\n                { background: options.border.color },\n                options.highlight,\n                options.type === datavizConstants.CROSS ? {\n                    background: options.highlight.border.color,\n                    border: { color: options.highlight.background, width: borderWidth / 2 },\n                    width: options.width,\n                    height: options.height,\n                    margin: { top: 0, left: 0 }\n                } : {}\n            );\n        },\n\n        createHighlight: function() {\n            var highlight = new ShapeElement(this.markerHighlightOptions());\n            var box = this.paddingBox.clone();\n            highlight.reflow(box.pad(highlight.options.border.width));\n            this.highlight = [ highlight.getElement() ];\n\n            return this.highlight;\n        }\n    });\n\n    setDefaultOptions(LegendItemMarker, {\n        border: {\n            width: DEFAULT_MARKER_BORDER_WIDTH\n        },\n        width: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,\n        height: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,\n        background: WHITE,\n        margin: {\n            top: -1,\n            left: -1\n        },\n        vAlign: TOP,\n        align: LEFT,\n        highlight: {\n            width: DEFAULT_MARKER_SIZE,\n            height: DEFAULT_MARKER_SIZE,\n            border: {\n                color: WHITE,\n                width: DEFAULT_MARKER_BORDER_WIDTH\n            }\n        }\n    });\n\n    var ChartElement$1 = Class.extend({\n        init: function(options) {\n\n            this.children = [];\n\n            this.options = deepExtend({}, this.options, this.initUserOptions(options));\n        },\n\n        initUserOptions: function(options) {\n            return options;\n        },\n\n        reflow: function(targetBox) {\n            var children = this.children;\n            var box;\n\n            for (var i = 0; i < children.length; i++) {\n                var currentChild = children[i];\n                currentChild.reflow(targetBox);\n\n                box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n            }\n\n            this.box = box || targetBox;\n        },\n\n        destroy: function() {\n            var children = this.children;\n\n            if (this.animation) {\n                this.animation.destroy();\n            }\n\n            for (var i = 0; i < children.length; i++) {\n                children[i].destroy();\n            }\n        },\n\n        getRoot: function() {\n            var parent = this.parent;\n\n            return parent ? parent.getRoot() : null;\n        },\n\n        getSender: function() {\n            var service = this.getService();\n            if (service) {\n                return service.sender;\n            }\n        },\n\n        getService: function() {\n            var element = this;\n            while (element) {\n                if (element.chartService) {\n                    return element.chartService;\n                }\n                element = element.parent;\n            }\n        },\n\n        translateChildren: function(dx, dy) {\n            var children = this.children;\n            var childrenCount = children.length;\n\n            for (var i = 0; i < childrenCount; i++) {\n                children[i].box.translate(dx, dy);\n            }\n        },\n\n        append: function() {\n            var arguments$1 = arguments;\n            var this$1$1 = this;\n\n            for (var i = 0; i < arguments.length; i++) {\n                var item = arguments$1[i];\n                this$1$1.children.push(item);\n                item.parent = this$1$1;\n            }\n        },\n\n        renderVisual: function() {\n            if (this.options.visible === false) {\n                return;\n            }\n\n            this.createVisual();\n\n            this.addVisual();\n\n            this.renderChildren();\n\n            this.createAnimation();\n            this.renderComplete();\n        },\n\n        addVisual: function() {\n            if (this.visual) {\n                this.visual.chartElement = this;\n\n                if (this.parent) {\n                    this.parent.appendVisual(this.visual);\n                }\n            }\n        },\n\n        renderChildren: function() {\n            var children = this.children;\n            var length = children.length;\n            for (var i = 0; i < length; i++) {\n                children[i].renderVisual();\n            }\n        },\n\n        createVisual: function() {\n            this.visual = new Group({\n                zIndex: this.options.zIndex,\n                visible: valueOrDefault(this.options.visible, true)\n            });\n        },\n\n        createAnimation: function() {\n            if (this.visual && this.options.animation) {\n                this.animation = Animation.create(\n                    this.visual, this.options.animation\n                );\n            }\n        },\n\n        appendVisual: function(childVisual) {\n            if (!childVisual.chartElement) {\n                childVisual.chartElement = this;\n            }\n\n            if (childVisual.options.noclip) {\n                this.clipRoot().visual.append(childVisual);\n            } else if (defined(childVisual.options.zIndex)) {\n                this.stackRoot().stackVisual(childVisual);\n            } else if (this.isStackRoot) {\n                this.stackVisual(childVisual);\n            } else if (this.visual) {\n                this.visual.append(childVisual);\n            } else {\n                // Allow chart elements without visuals to\n                // pass through child visuals\n                this.parent.appendVisual(childVisual);\n            }\n        },\n\n        clipRoot: function() {\n            if (this.parent) {\n                return this.parent.clipRoot();\n            }\n\n            return this;\n        },\n\n        stackRoot: function() {\n            if (this.parent) {\n                return this.parent.stackRoot();\n            }\n\n            return this;\n        },\n\n        stackVisual: function(childVisual) {\n            var zIndex = childVisual.options.zIndex || 0;\n            var visuals = this.visual.children;\n            var length = visuals.length;\n            var pos;\n\n            for (pos = 0; pos < length; pos++) {\n                var sibling = visuals[pos];\n                var here = valueOrDefault(sibling.options.zIndex, 0);\n                if (here > zIndex) {\n                    break;\n                }\n            }\n\n            this.visual.insert(pos, childVisual);\n        },\n\n        traverse: function(callback) {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n                var child = children[i];\n\n                callback(child);\n                if (child.traverse) {\n                    child.traverse(callback);\n                }\n            }\n        },\n\n        closest: function(match) {\n            var element = this;\n            var matched = false;\n\n            while (element && !matched) {\n                matched = match(element);\n\n                if (!matched) {\n                    element = element.parent;\n                }\n            }\n\n            if (matched) {\n                return element;\n            }\n        },\n\n        renderComplete: function() {},\n\n        hasHighlight: function() {\n            var options = (this.options || {}).highlight;\n            return !(!this.createHighlight || (options && options.visible === false) || this.visible === false);\n        },\n\n        toggleHighlight: function(show, opacity) {\n            var this$1$1 = this;\n\n            var options = (this.options || {}).highlight || {};\n            var customVisual = options.visual;\n            var highlight = this._highlight;\n\n            if (!highlight) {\n                var highlightOptions = {\n                    fill: {\n                        color: WHITE,\n                        opacity: opacity || 0.2\n                    },\n                    stroke: {\n                        color: WHITE,\n                        width: 1,\n                        opacity: opacity || 0.2\n                    }\n                };\n\n                if (customVisual) {\n                    highlight = this._highlight = customVisual(\n                        $.extend(this.highlightVisualArgs(), {\n                            createVisual: function () { return this$1$1.createHighlight(highlightOptions); },\n                            sender: this.getSender(),\n                            series: this.series,\n                            dataItem: this.dataItem,\n                            category: this.category,\n                            value: this.value,\n                            percentage: this.percentage,\n                            runningTotal: this.runningTotal,\n                            total: this.total\n                        })\n                    );\n\n                    if (!highlight) {\n                        return;\n                    }\n                } else {\n                    highlight = this._highlight = this.createHighlight(highlightOptions);\n                }\n\n                if (!defined(highlight.options.zIndex)) {\n                    highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n                }\n\n                this.appendVisual(highlight);\n            }\n\n            highlight.visible(show);\n        },\n\n        toggleFocusHighlight: function(show) {\n            var options = ((this.options || {}).accessibility || {}).highlight || {};\n            var focusHighlight = this._focusHighlight;\n\n            if (!show && !focusHighlight) {\n                return;\n            }\n\n            if (!focusHighlight) {\n                var rootBackground = this.getRoot().options.background;\n                var highlightColor = autoTextColor(rootBackground);\n                var focusHighlightOptions = {\n                    fill: {\n                        opacity: options.opacity,\n                        color: options.color\n                    },\n                    stroke: $.extend({}, {color: highlightColor}, options.border),\n                    zIndex: options.zIndex\n                };\n\n                focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);\n\n                this.appendVisual(focusHighlight);\n            }\n\n            focusHighlight.visible(show);\n        },\n\n        createGradientOverlay: function(element, options, gradientOptions) {\n            var overlay = new Path($.extend({\n                stroke: {\n                    color: \"none\"\n                },\n                fill: this.createGradient(gradientOptions),\n                closed: element.options.closed\n            }, options));\n\n            overlay.segments.elements(element.segments.elements());\n\n            return overlay;\n        },\n\n        createGradient: function(options) {\n            if (this.parent) {\n                return this.parent.createGradient(options);\n            }\n        },\n\n        supportsPointInactiveOpacity: function() {\n            return true;\n        }\n    });\n\n    ChartElement$1.prototype.options = { };\n\n    var Point$1 = Class.extend({\n        init: function(x, y) {\n\n            this.x = x || 0;\n            this.y = y || 0;\n        },\n\n        clone: function() {\n            return new Point$1(this.x, this.y);\n        },\n\n        equals: function(point) {\n            return point && this.x === point.x && this.y === point.y;\n        },\n\n        rotate: function(center, degrees) {\n            var theta = rad(degrees);\n            var cosT = Math.cos(theta);\n            var sinT = Math.sin(theta);\n            var cx = center.x;\n            var cy = center.y;\n            var ref = this;\n            var x = ref.x;\n            var y = ref.y;\n\n            this.x = round(\n                cx + (x - cx) * cosT + (y - cy) * sinT,\n                COORD_PRECISION\n            );\n\n            this.y = round(\n                cy + (y - cy) * cosT - (x - cx) * sinT,\n                COORD_PRECISION\n            );\n\n            return this;\n        },\n\n        multiply: function(a) {\n\n            this.x *= a;\n            this.y *= a;\n\n            return this;\n        },\n\n        distanceTo: function(point) {\n            var dx = this.x - point.x;\n            var dy = this.y - point.y;\n\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    });\n\n    Point$1.onCircle = function(center, angle, radius) {\n        var radians = rad(angle);\n\n        return new Point$1(\n            center.x - radius * Math.cos(radians),\n            center.y - radius * Math.sin(radians)\n        );\n    };\n\n    var Box$1 = Class.extend({\n        init: function(x1, y1, x2, y2) {\n\n            this.x1 = x1 || 0;\n            this.y1 = y1 || 0;\n            this.x2 = x2 || 0;\n            this.y2 = y2 || 0;\n        },\n\n        equals: function(box) {\n            return this.x1 === box.x1 && this.x2 === box.x2 &&\n                this.y1 === box.y1 && this.y2 === box.y2;\n        },\n\n        width: function() {\n            return this.x2 - this.x1;\n        },\n\n        height: function() {\n            return this.y2 - this.y1;\n        },\n\n        translate: function(dx, dy) {\n            this.x1 += dx;\n            this.x2 += dx;\n            this.y1 += dy;\n            this.y2 += dy;\n\n            return this;\n        },\n\n        move: function(x, y) {\n            var height = this.height();\n            var width = this.width();\n\n            if (defined(x)) {\n                this.x1 = x;\n                this.x2 = this.x1 + width;\n            }\n\n            if (defined(y)) {\n                this.y1 = y;\n                this.y2 = this.y1 + height;\n            }\n\n            return this;\n        },\n\n        wrap: function(targetBox) {\n            this.x1 = Math.min(this.x1, targetBox.x1);\n            this.y1 = Math.min(this.y1, targetBox.y1);\n            this.x2 = Math.max(this.x2, targetBox.x2);\n            this.y2 = Math.max(this.y2, targetBox.y2);\n\n            return this;\n        },\n\n        wrapPoint: function(point) {\n            var arrayPoint = isArray(point);\n            var x = arrayPoint ? point[0] : point.x;\n            var y = arrayPoint ? point[1] : point.y;\n            this.wrap(new Box$1(x, y, x, y));\n\n            return this;\n        },\n\n        snapTo: function(targetBox, axis) {\n\n            if (axis === X || !axis) {\n                this.x1 = targetBox.x1;\n                this.x2 = targetBox.x2;\n            }\n\n            if (axis === Y || !axis) {\n                this.y1 = targetBox.y1;\n                this.y2 = targetBox.y2;\n            }\n\n            return this;\n        },\n\n        alignTo: function(targetBox, anchor) {\n            var height = this.height();\n            var width = this.width();\n            var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n            var offset = axis === Y ? height : width;\n\n            if (anchor === CENTER) {\n                var targetCenter = targetBox.center();\n                var center = this.center();\n\n                this.x1 += targetCenter.x - center.x;\n                this.y1 += targetCenter.y - center.y;\n            } else if (anchor === TOP || anchor === LEFT) {\n                this[axis + 1] = targetBox[axis + 1] - offset;\n            } else {\n                this[axis + 1] = targetBox[axis + 2];\n            }\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n\n            return this;\n        },\n\n        shrink: function(dw, dh) {\n\n            this.x2 -= dw;\n            this.y2 -= dh;\n\n            return this;\n        },\n\n        expand: function(dw, dh) {\n            this.shrink(-dw, -dh);\n            return this;\n        },\n\n        pad: function(padding) {\n            var spacing = getSpacing(padding);\n\n            this.x1 -= spacing.left;\n            this.x2 += spacing.right;\n            this.y1 -= spacing.top;\n            this.y2 += spacing.bottom;\n\n            return this;\n        },\n\n        unpad: function(padding) {\n            var spacing = getSpacing(padding);\n\n            spacing.left = -spacing.left;\n            spacing.top = -spacing.top;\n            spacing.right = -spacing.right;\n            spacing.bottom = -spacing.bottom;\n\n            return this.pad(spacing);\n        },\n\n        clone: function() {\n            return new Box$1(this.x1, this.y1, this.x2, this.y2);\n        },\n\n        center: function() {\n            return new Point$1(\n                this.x1 + this.width() / 2,\n                this.y1 + this.height() / 2\n            );\n        },\n\n        containsPoint: function(point) {\n\n            return point.x >= this.x1 && point.x <= this.x2 &&\n                   point.y >= this.y1 && point.y <= this.y2;\n        },\n\n        points: function() {\n            return [\n                new Point$1(this.x1, this.y1),\n                new Point$1(this.x2, this.y1),\n                new Point$1(this.x2, this.y2),\n                new Point$1(this.x1, this.y2)\n            ];\n        },\n\n        getHash: function() {\n            return [ this.x1, this.y1, this.x2, this.y2 ].join(\",\");\n        },\n\n        overlaps: function(box) {\n            return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n        },\n\n        rotate: function(rotation) {\n            var width = this.width();\n            var height = this.height();\n            var ref = this.center();\n            var cx = ref.x;\n            var cy = ref.y;\n\n            var r1 = rotatePoint(0, 0, cx, cy, rotation);\n            var r2 = rotatePoint(width, 0, cx, cy, rotation);\n            var r3 = rotatePoint(width, height, cx, cy, rotation);\n            var r4 = rotatePoint(0, height, cx, cy, rotation);\n\n            width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n            height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n\n            return this;\n        },\n\n        toRect: function() {\n            return new geometry.Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\n        },\n\n        hasSize: function() {\n            return this.width() !== 0 && this.height() !== 0;\n        },\n\n        align: function(targetBox, axis, alignment) {\n            var c1 = axis + 1;\n            var c2 = axis + 2;\n            var sizeFunc = axis === X ? datavizConstants.WIDTH : datavizConstants.HEIGHT;\n            var size = this[sizeFunc]();\n\n            if (inArray(alignment, [ LEFT, TOP ])) {\n                this[c1] = targetBox[c1];\n                this[c2] = this[c1] + size;\n            } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\n                this[c2] = targetBox[c2];\n                this[c1] = this[c2] - size;\n            } else if (alignment === CENTER) {\n                this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n                this[c2] = this[c1] + size;\n            }\n        }\n    });\n\n    function rotatePoint(x, y, cx, cy, angle) {\n        var theta = rad(angle);\n\n        return new Point$1(\n            cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\n            cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\n        );\n    }\n\n    var BoxElement$1 = ChartElement$1.extend({\n        init: function(options) {\n            ChartElement$1.fn.init.call(this, options);\n\n            this.options.margin = getSpacing(this.options.margin);\n            this.options.padding = getSpacing(this.options.padding);\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var shrinkToFit = options.shrinkToFit;\n            var hasSetSize = width && height;\n            var margin = options.margin;\n            var padding = options.padding;\n            var borderWidth = options.border.width;\n            var box;\n\n            var reflowPaddingBox = function () {\n                this$1$1.align(targetBox, X, options.align);\n                this$1$1.align(targetBox, Y, options.vAlign);\n                this$1$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n            };\n\n            var contentBox = targetBox.clone();\n            if (hasSetSize) {\n                contentBox.x2 = contentBox.x1 + width;\n                contentBox.y2 = contentBox.y1 + height;\n            }\n\n            if (shrinkToFit) {\n                contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n            }\n\n            ChartElement$1.fn.reflow.call(this, contentBox);\n\n            if (hasSetSize) {\n                box = this.box = new Box$1(0, 0, width, height);\n            } else {\n                box = this.box;\n            }\n\n            if (shrinkToFit && hasSetSize) {\n                reflowPaddingBox();\n                contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n            } else {\n                contentBox = this.contentBox = box.clone();\n                box.pad(padding).pad(borderWidth).pad(margin);\n                reflowPaddingBox();\n            }\n\n            this.translateChildren(\n                box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\n                box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\n            );\n\n            var children = this.children;\n            for (var i = 0; i < children.length; i++) {\n                var item = children[i];\n                item.reflow(item.box);\n            }\n        },\n\n        align: function(targetBox, axis, alignment) {\n            this.box.align(targetBox, axis, alignment);\n        },\n\n        hasBox: function() {\n            var options = this.options;\n            return options.border.width || options.background;\n        },\n\n        createVisual: function() {\n            ChartElement$1.fn.createVisual.call(this);\n\n            var options = this.options;\n            if (options.visible && this.hasBox()) {\n                this.visual.append(Path.fromRect(\n                    this.paddingBox.toRect(),\n                    this.visualStyle()\n                ));\n            }\n        },\n\n        visualStyle: function() {\n            var options = this.options;\n            var border = options.border || {};\n\n            return {\n                stroke: {\n                    width: border.width,\n                    color: border.color,\n                    opacity: valueOrDefault(border.opacity, options.opacity),\n                    dashType: border.dashType\n                },\n                fill: {\n                    color: options.background,\n                    opacity: options.opacity\n                },\n                cursor: options.cursor\n            };\n        }\n    });\n\n    setDefaultOptions(BoxElement$1, {\n        align: LEFT,\n        vAlign: TOP,\n        margin: {},\n        padding: {},\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        background: \"\",\n        shrinkToFit: false,\n        width: 0,\n        height: 0,\n        visible: true\n    });\n\n    var ShapeElement$1 = BoxElement$1.extend({\n        init: function(options, pointData) {\n            BoxElement$1.fn.init.call(this, options);\n\n            this.pointData = pointData;\n        },\n\n        getElement: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.paddingBox;\n            var type = options.type;\n            var rotation = options.rotation;\n            var center = box.center();\n            var halfWidth = box.width() / 2;\n            var halfHeight = box.height() / 2;\n\n            if (!options.visible || !this.hasBox()) {\n                return null;\n            }\n\n            var style = this.visualStyle();\n            var element;\n\n            if (type === CIRCLE) {\n                element = new Circle(\n                    new GeometryCircle([\n                        round(box.x1 + halfWidth, COORD_PRECISION),\n                        round(box.y1 + halfHeight, COORD_PRECISION)\n                    ], Math.min(halfWidth, halfHeight)),\n                    style\n                );\n            } else if (type === datavizConstants.TRIANGLE) {\n                element = Path.fromPoints([\n                    [ box.x1 + halfWidth, box.y1 ],\n                    [ box.x1, box.y2 ],\n                    [ box.x2, box.y2 ]\n                ], style).close();\n            } else if (type === datavizConstants.CROSS) {\n                element = new MultiPath(style);\n\n                element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n                element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n            } else {\n                var rect = box.toRect();\n                if (type === datavizConstants.ROUNDED_RECT) {\n                    var borderRadius = valueOrDefault$1(options.borderRadius, rect.width() / 5);\n                    rect.setCornerRadius(borderRadius);\n                }\n\n                element = Path.fromRect(rect, style);\n            }\n\n            if (rotation) {\n                element.transform(transform()\n                    .rotate(-rotation, [ center.x, center.y ])\n                );\n            }\n\n            element.options.zIndex = options.zIndex;\n\n            return element;\n        },\n\n        createElement: function() {\n            var this$1$1 = this;\n\n            var customVisual = this.options.visual;\n            var pointData = this.pointData || {};\n            var visual;\n\n            if (customVisual) {\n                visual = customVisual({\n                    value: pointData.value,\n                    dataItem: pointData.dataItem,\n                    sender: this.getSender(),\n                    series: pointData.series,\n                    category: pointData.category,\n                    rect: this.paddingBox.toRect(),\n                    options: this.visualOptions(),\n                    createVisual: function () { return this$1$1.getElement(); }\n                });\n            } else {\n                visual = this.getElement();\n            }\n\n            return visual;\n        },\n\n        visualOptions: function() {\n            var options = this.options;\n            return {\n                background: options.background,\n                border: options.border,\n                margin: options.margin,\n                padding: options.padding,\n                type: options.type,\n                size: options.width,\n                visible: options.visible\n            };\n        },\n\n        createVisual: function() {\n            this.visual = this.createElement();\n\n            addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);\n        }\n    });\n\n    setDefaultOptions(ShapeElement$1, {\n        type: CIRCLE,\n        align: CENTER,\n        vAlign: CENTER\n    });\n\n    var MarkerLineArea = ShapeElement$1.extend({\n        getElement: function() {\n            var group = new Group();\n            var element = new MultiPath(this.visualStyle());\n            var ref = this;\n            var box = ref.paddingBox;\n            var halfHeight = box.height() / 2;\n\n            element\n                .moveTo(box.x1, box.y1 + halfHeight)\n                .lineTo(box.x1, box.y2)\n                .lineTo(box.x2, box.y2);\n\n            group.append(element);\n\n            return group;\n        }\n    });\n\n    setDefaultOptions(MarkerLineArea, {\n        width: 15,\n        height: 15,\n        align: RIGHT,\n        vAlign: BOTTOM,\n        margin: {\n            right: -2,\n            bottom: 2\n        }\n    });\n\n    var LegendItemLine = ShapeElement$1.extend({\n        getElement: function() {\n            var group = new Group();\n            var element = new MultiPath({\n                stroke: {\n                    color: this.options.border.color,\n                    opacity: this.options.opacity,\n                    width: this.options.height,\n                    dashType: this.options.dashType\n                }\n            });\n            var box = this.paddingBox;\n            var centerY = box.center().y;\n\n            element\n                .moveTo(box.x1, centerY)\n                .lineTo(box.x2, centerY);\n\n            group.append(element);\n\n            return group;\n        },\n\n        createHighlight: function() {\n            this.highlight = [ this.createHighlightLine(), this.createHighlightMarker() ];\n            return this.highlight;\n        },\n\n        createHighlightLine: function() {\n            var options = deepExtend({}, {\n                border: {\n                    color: this.options.border.color,\n                    opacity: this.options.border.opacity,\n                    dashType: this.options.border.dashType\n                }\n            }, this.options.highlight);\n            var highlightLine = new MarkerLineArea(options);\n            highlightLine.reflow(this.parent.paddingBox.clone());\n\n            this.highlightLine = highlightLine.getElement();\n\n            return this.highlightLine;\n        },\n\n        createHighlightMarker: function() {\n            var options = deepExtend({}, {\n                background: this.options.background,\n            }, this.options.highlight.markers);\n            var highlightMarker = new ShapeElement$1(options);\n            var paddingBox = this.parent.paddingBox;\n            var borderWidth = options.border.width;\n            var box = this.parent.box.clone();\n\n            box.pad({\n                left: borderWidth - paddingBox.x1,\n                top: borderWidth - paddingBox.y1\n            });\n\n            highlightMarker.reflow(box);\n            this.highlightMarker = highlightMarker.getElement();\n\n            return this.highlightMarker;\n        }\n    });\n\n    setDefaultOptions(LegendItemLine, {\n        border: {\n            width: 0\n        },\n        type: datavizConstants.RECT,\n        align: LEFT,\n        vAlign: CENTER,\n        highlight: {\n            border: {\n                width: DEFAULT_MARKER_BORDER_WIDTH\n            },\n            markers: {\n                type: CIRCLE,\n                width: DEFAULT_MARKER_SIZE,\n                height: DEFAULT_MARKER_SIZE,\n                border: {\n                    width: DEFAULT_MARKER_BORDER_WIDTH,\n                    color: WHITE\n                },\n                align: LEFT,\n                vAlign: TOP\n            }\n        }\n    });\n\n    var LegendItemSquare = ShapeElement$1.extend({\n        createHighlight: function() {\n            var options = deepExtend({}, {\n                background: this.options.background,\n            }, this.options.highlight.markers);\n            var highlight = new ShapeElement$1(options);\n\n            var box = this.paddingBox.clone();\n            var targetBox = this.parent.box.clone();\n            box.align(targetBox, X, LEFT);\n            box.align(targetBox, Y, TOP);\n            highlight.reflow(box);\n\n            this.highlight = [ highlight.getElement() ];\n\n            return this.highlight;\n        }\n    });\n\n    setDefaultOptions(LegendItemSquare, {\n        highlight: {\n            markers: {\n                type: CIRCLE,\n                width: DEFAULT_MARKER_SIZE,\n                height: DEFAULT_MARKER_SIZE,\n                border: {\n                    width: DEFAULT_MARKER_BORDER_WIDTH,\n                    color: WHITE\n                },\n                margin: {\n                    top: -3,\n                    left: -3\n                }\n            }\n        }\n    });\n\n    var LegendItem = BoxElement.extend({\n        init: function(options) {\n            BoxElement.fn.init.call(this, options);\n\n            this.createContainer();\n            if (!options.rtl) {\n                this.createMarker();\n                this.createLabel();\n            } else {\n                this.createLabel();\n                this.createMarker();\n            }\n\n            this._id = guid();\n            this.options.accessibility.ariaChecked = options.active;\n        },\n\n        createContainer: function() {\n            this.container = new dataviz.FloatElement({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });\n            this.append(this.container);\n        },\n\n        createMarker: function() {\n            this.markerWrap = new BoxElement({ vertical: false, shrinkToFit: true, wrap: false, margin: 1, width: 22, height: 22 });\n            this.container.append(this.markerWrap);\n\n            this.createMarkerArea();\n\n            if (this.options.markers.visible) {\n                this._marker = this._createMarker();\n                this.markerWrap.append(this._marker);\n            }\n        },\n\n        createMarkerArea: function() {\n            var options = this.options;\n            var markerColor = options.markerColor;\n            var line = options.line; if (line === void 0) { line = {}; }\n            var lineOptions = {\n                border: {\n                    color: line.color || markerColor,\n                    opacity: line.opacity,\n                    dashType: line.dashType\n                }\n            };\n            return this._createLine(lineOptions) ||\n                this._createMarkerLine(lineOptions, line) ||\n                this._createSquare();\n        },\n\n        markerOptions: function() {\n            var options = this.options;\n            var markers = options.markers; if (markers === void 0) { markers = {}; }\n            var markerColor = options.markerColor;\n            var border = markers.border; if (border === void 0) { border = {}; }\n            markers.zIndex = undefined;\n\n            return deepExtend({}, markers, {\n                border: { color: border.color || markerColor },\n                highlight: options.highlight.markers\n            });\n        },\n\n        _highlightOptions: function() {\n            var options = this.options;\n            return deepExtend(\n                { markers: { type: options.markers.type } },\n                options.highlight\n            );\n        },\n\n        _createLine: function(lineOptions) {\n            var options = this.options;\n            if (options.type === LINE && !options.markers.visible) {\n                this._line = new LegendItemLine(deepExtend({}, {\n                    background: options.markerColor,\n                    highlight: this._highlightOptions(),\n                }, lineOptions, options.line));\n\n                this.markerWrap.append(this._line);\n            }\n            return this._line;\n        },\n\n        _createMarkerLine: function(lineOptions, line) {\n            var options = this.options;\n            if (options.type === LINE) {\n                this._markerLineArea = new MarkerLineArea(deepExtend({}, {\n                    border: {\n                        width: line.height\n                    }\n                }, lineOptions));\n\n                this.markerWrap.append(this._markerLineArea);\n            }\n\n            return this._markerLineArea;\n        },\n\n        _createSquare: function() {\n            var options = this.options;\n            if (options.type === AREA) {\n                this._square = new LegendItemSquare($.extend({}, {border: options.border,\n                    vAlign: options.markers.visible ? BOTTOM : CENTER,\n                    highlight: this._highlightOptions(),\n                    visual: options.visual},\n                    options.area,\n                    {background: options.area.background || options.markerColor}));\n                this.markerWrap.append(this._square);\n            }\n            return this._square;\n        },\n\n        _createMarker: function() {\n            return new LegendItemMarker(this.markerOptions());\n        },\n\n        _highlightMarkers: function() {\n            if (this.options.active) {\n                this._toggleHighlight(true);\n            }\n        },\n\n        _restoreMarkers: function() {\n            this._toggleHighlight(false);\n        },\n\n        _toggleHighlight: function(show) {\n            var this$1$1 = this;\n\n            if (!this.options.highlight.visible) {\n                return;\n            }\n\n            var element = this._marker || this._square || this._line;\n\n            if (element && element === this._line) {\n                this._line.visual.visible(!show);\n            }\n\n            if (element) {\n                var highlight = element.highlight;\n\n                if (!highlight) {\n                    highlight = element.createHighlight();\n                    highlight.forEach(function (h) { return h && this$1$1.markerWrap.appendVisual(h); });\n                }\n\n                highlight.forEach(function (h) { return h && h.visible(show); });\n            }\n        },\n\n        createLabel: function() {\n            var options = this.options;\n            var labelOptions = deepExtend({}, options.labels);\n\n            this.container.append(new TextBox(options.text, labelOptions));\n        },\n\n        getAriaLabelText: function() {\n            return this.options.text;\n        },\n\n        focusVisual: function() {\n            this.visual.options.set(\"id\", this._id);\n            this.toggleFocusHighlight(true);\n            this._highlightMarkers();\n        },\n\n        clearFocusFromVisual: function() {\n            this.visual.options.set(\"id\", \"\");\n            this.toggleFocusHighlight(false);\n            this._restoreMarkers();\n        },\n\n        renderComplete: function() {\n            BoxElement.fn.renderComplete.call(this);\n\n            var cursor = this.options.cursor || {};\n            var eventSink = this._itemOverlay = Path.fromRect(this.container.box.toRect(), {\n                fill: {\n                    color: WHITE,\n                    opacity: 0\n                },\n                stroke: null,\n                cursor: cursor.style || cursor\n            });\n\n            this.appendVisual(eventSink);\n        },\n\n        click: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === 'contextmenu') {\n                e.preventDefault();\n            }\n        },\n\n        over: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {\n                widget._legendItemHover(args.seriesIndex, args.pointIndex);\n                this._highlightMarkers();\n            }\n\n            // Don't trigger point hover for legend items\n            return true;\n        },\n\n        out: function(widget, e) {\n            widget._unsetActivePoint();\n            this._restoreMarkers();\n\n            widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));\n        },\n\n        eventArgs: function(e) {\n            var options = this.options;\n\n            return {\n                element: eventElement(e),\n                text: options.text,\n                series: options.series,\n                seriesIndex: options.series.index,\n                pointIndex: options.pointIndex\n            };\n        },\n\n        createVisual: function() {\n            BoxElement.fn.createVisual.call(this);\n            var options = this.options;\n\n            if (this.options.visible) {\n                var accessibilityOptions = deepExtend({\n                    ariaLabel: options.text\n                }, options.accessibility);\n\n                addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);\n            }\n        },\n\n        renderVisual: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var customVisual = options.visual;\n\n            if (customVisual) {\n                this.visual = customVisual({\n                    active: options.active,\n                    series: options.series,\n                    sender: this.getSender(),\n                    pointIndex: options.pointIndex,\n                    options: {\n                        type: options.type,\n                        // Passing the markerColor as a background option for backwards compatibility.\n                        // Example in jq docs - https://docs.telerik.com/kendo-ui/api/javascript/dataviz/ui/chart/configuration/legend.item#legenditemvisual\n                        markers: deepExtend({ background: this.options.markerColor }, this.markerOptions()),\n                        labels: options.labels\n                    },\n                    createVisual: function () {\n                        this$1$1.createVisual();\n                        this$1$1.renderChildren();\n                        this$1$1.renderComplete();\n\n                        var defaultVisual = this$1$1.visual;\n\n                        delete this$1$1.visual;\n\n                        return defaultVisual;\n                    }\n                });\n                this._marker = this._markerLineArea = this._square = this._line = null;\n                this.addVisual();\n            } else {\n                BoxElement.fn.renderVisual.call(this);\n            }\n        },\n\n        createFocusHighlight: function(style) {\n            var borderWidth = style.stroke.width;\n            return Path.fromRect(this.container.box.pad(borderWidth / 2).toRect(), style);\n        }\n    });\n\n    setDefaultOptions(LegendItem, {\n        accessibility: {\n            role: LEGEND_ITEM_ROLE,\n            className: LEGEND_ITEM_CLASSNAME,\n            ariaRoleDescription: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION\n        },\n        markers: {},\n        highlight: {\n            visible: true,\n            markers: {}\n        }\n    });\n\n    var CUSTOM = \"custom\";\n\n    var Legend = ChartElement.extend({\n        init: function(options, chartService) {\n            if (chartService === void 0) { chartService = {}; }\n\n            ChartElement.fn.init.call(this, options);\n\n            this.chartService = chartService;\n\n            if (!inArray(this.options.position, [ TOP, RIGHT, BOTTOM, LEFT, CUSTOM ])) {\n                this.options.position = RIGHT;\n            }\n\n            this.createContainers();\n\n            this.createLegendTitle(options.title);\n\n            this.createItems();\n        },\n\n        createContainers: function() {\n            var options = this.options;\n            var position = options.position;\n            var userAlign = options.align;\n            var align = position;\n            var vAlign = CENTER;\n\n            if (position === CUSTOM) {\n                align = LEFT;\n            } else if (inArray(position, [ TOP, BOTTOM ])) {\n                if (userAlign === START) {\n                    align = LEFT;\n                } else if (userAlign === END) {\n                    align = RIGHT;\n                } else {\n                    align = CENTER;\n                }\n                vAlign = position;\n            } else if (userAlign) {\n                if (userAlign === START) {\n                    vAlign = TOP;\n                } else if (userAlign === END) {\n                    vAlign = BOTTOM;\n                }\n            }\n\n            this.container = new BoxElement({\n                margin: options.margin,\n                padding: options.padding,\n                background: options.background,\n                border: options.border,\n                vAlign: vAlign,\n                align: align,\n                zIndex: options.zIndex,\n                shrinkToFit: true\n            });\n\n            if (this.hasTitle()) {\n                this.itemsContainer = new BoxElement({\n                    vAlign: vAlign,\n                    align: align,\n                    zIndex: options.zIndex,\n                    shrinkToFit: true\n                });\n            } else {\n                this.itemsContainer = this.container;\n            }\n\n            this.append(this.container);\n        },\n\n        createItems: function() {\n            var chartService = this.getService();\n            var options = this.options;\n            var vertical = this.isVertical();\n            var innerElement = new LegendLayout({\n                vertical: vertical,\n                spacing: options.spacing,\n                rtl: chartService.rtl\n            }, chartService);\n            var data = options.data;\n\n            if (options.reverse) {\n                data = data.slice(0).reverse();\n            }\n\n            var count = data.length;\n\n            for (var i = 0; i < count; i++) {\n                var dataItem = data[i];\n                var ref = dataItem.series || {};\n                var markers = ref.markers; if (markers === void 0) { markers = {}; }\n                var dashType = ref.dashType;\n                var legendItem = ref.legendItem;\n                var opacity = ref.opacity;\n                var markersOptions = deepExtend({ visible: markers.visible !== false, type: CIRCLE }, markers);\n                delete markersOptions.size;\n\n                var itemOptions = deepExtend({},\n                    {\n                        markers: markersOptions,\n                        labels: options.labels,\n                        rtl: chartService.rtl,\n                        line: $.extend({}, {dashType: dashType},\n                            options.line),\n                        area: $.extend({}, {opacity: opacity},\n                            options.area),\n                        opacity: opacity,\n                        accessibility: options.accessibility\n                    },\n                    options.item,\n                    legendItem,\n                    dataItem,\n                    { markers: options.markers }\n                );\n\n                innerElement.append(new LegendItem(itemOptions));\n            }\n\n            innerElement.render();\n            this.itemsContainer.append(innerElement);\n        },\n\n        isVertical: function() {\n            var ref = this.options;\n            var orientation = ref.orientation;\n            var position = ref.position;\n            var vertical = (position === CUSTOM && orientation !== datavizConstants.HORIZONTAL) ||\n                   (defined(orientation) ? orientation !== datavizConstants.HORIZONTAL : inArray(position, [ LEFT, RIGHT ]));\n\n            return vertical;\n        },\n\n        hasItems: function() {\n            return this.container.children[0].children.length > 0;\n        },\n\n        getItems: function() {\n            return this.itemsContainer.children[0].children;\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options;\n            var legendBox = targetBox.clone();\n\n            if (!this.hasItems()) {\n                this.box = legendBox;\n                return;\n            }\n\n            if (options.position === CUSTOM) {\n                this.containerCustomReflow(legendBox);\n                this.box = legendBox;\n            } else {\n                this.containerReflow(legendBox);\n            }\n\n            if (this.hasTitle()) {\n                this.title.reflow(new Box(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));\n            }\n        },\n\n        containerReflow: function(targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var container = ref.container;\n            var position = options.position;\n            var width = options.width;\n            var height = options.height;\n            var pos = position === TOP || position === BOTTOM ? X : Y;\n            var vertical = this.isVertical();\n            var alignTarget = targetBox.clone();\n            var containerBox = targetBox.clone();\n\n            if (position === LEFT || position === RIGHT) {\n                containerBox.y1 = alignTarget.y1 = 0;\n            }\n\n            if (vertical && height) {\n                containerBox.y2 = containerBox.y1 + height;\n                containerBox.align(alignTarget, Y, container.options.vAlign);\n            } else if (!vertical && width) {\n                containerBox.x2 = containerBox.x1 + width;\n                containerBox.align(alignTarget, X, container.options.align);\n            }\n\n            container.reflow(containerBox);\n            containerBox = container.box;\n\n            var box = containerBox.clone();\n\n            if (options.offsetX || options.offsetY) {\n                containerBox.translate(options.offsetX, options.offsetY);\n                container.reflow(containerBox);\n            }\n\n            box[pos + 1] = targetBox[pos + 1];\n            box[pos + 2] = targetBox[pos + 2];\n\n            this.box = box;\n        },\n\n        containerCustomReflow: function(targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var container = ref.container;\n            var offsetX = options.offsetX;\n            var offsetY = options.offsetY;\n            var width = options.width;\n            var height = options.height;\n            var vertical = this.isVertical();\n            var containerBox = targetBox.clone();\n\n            if (vertical && height) {\n                containerBox.y2 = containerBox.y1 + height;\n            } else if (!vertical && width) {\n                containerBox.x2 = containerBox.x1 + width;\n            }\n            container.reflow(containerBox);\n            containerBox = container.box;\n\n            container.reflow(new Box(\n                offsetX, offsetY,\n                offsetX + containerBox.width(), offsetY + containerBox.height()\n            ));\n        },\n\n        renderVisual: function() {\n            if (this.hasItems()) {\n                ChartElement.fn.renderVisual.call(this);\n            }\n        },\n\n        createLegendTitle: function(title) {\n            var titleOptions = deepExtend({}, {\n                color: BLACK,\n                position: TOP,\n                align: CENTER\n            }, title);\n            var text = titleOptions.text;\n\n            if (!title || title.visible === false || !title.text) {\n                return;\n            }\n\n            if (defined(titleOptions) && titleOptions.visible) {\n                var labelTemplate = getTemplate(titleOptions);\n                if (labelTemplate) {\n                    text = labelTemplate({ text: text });\n                } else if (titleOptions.format) {\n                    text = this.chartService.format.auto(titleOptions.format, text);\n                }\n            }\n\n            this.title = new TextBox(text, titleOptions);\n\n            this.createTitleLayout();\n\n            this.appendTitleLayoutContent();\n        },\n\n        createTitleLayout: function() {\n            this.layout = new dataviz.FloatElement({\n                vertical: true,\n                wrap: false\n            });\n\n            this.container.append(this.layout);\n        },\n\n        hasTitle: function() {\n            return Boolean(this.options.title && this.options.title.visible !== false && this.options.title.text);\n        },\n\n        appendTitleLayoutContent: function() {\n            var options = this.options;\n\n            if (options.title.position === BOTTOM) {\n                this.layout.append(this.itemsContainer);\n                this.layout.append(this.title);\n            } else {\n                this.layout.append(this.title);\n                this.layout.append(this.itemsContainer);\n            }\n        }\n    });\n\n    setDefaultOptions(Legend, {\n        position: RIGHT,\n        data: [],\n        offsetX: 0,\n        offsetY: 0,\n        margin: getSpacing(2),\n        padding: getSpacing(5),\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        item: {\n            cursor: datavizConstants.POINTER,\n            spacing: 6\n        },\n        spacing: 6,\n        background: \"\",\n        zIndex: 1,\n        markers: {},\n        line: {\n            width: 20,\n            height: 2,\n            cursor: datavizConstants.POINTER,\n            opacity: 1\n        },\n        area: {\n            type: datavizConstants.SQUARE,\n            align: RIGHT,\n            width: 15,\n            height: 15,\n        }\n    });\n\n    var PlotAreaFactory = Class.extend({\n        init: function() {\n\n            this._registry = [];\n        },\n\n        register: function(type, seriesTypes) {\n            this._registry.push({\n                type: type,\n                seriesTypes: seriesTypes\n            });\n        },\n\n        create: function(srcSeries, options, chartService) {\n            var registry = this._registry;\n            var match = registry[0];\n            var series;\n\n            for (var idx = 0; idx < registry.length; idx++) {\n                var entry = registry[idx];\n                series = filterSeriesByType(srcSeries, entry.seriesTypes);\n                var trendlines = filterSeriesByType(srcSeries, TRENDLINE_SERIES);\n\n                if ((series.length - trendlines.length) > 0) {\n                    match = entry;\n                    break;\n                }\n            }\n\n            return new match.type(series, options, chartService);\n        }\n    });\n\n    PlotAreaFactory.current = new PlotAreaFactory();\n\n    var ZOOM_ACCELERATION = 3;\n    var SELECTOR_HEIGHT_ADJUST = 0.1;\n\n    function createDiv(classNames) {\n        var element = document.createElement(\"div\");\n        if (classNames) {\n            element.className = classNames;\n        }\n\n        return element;\n    }\n\n    function closestHandle(element) {\n        var current = element;\n        while (current && !dataviz.hasClasses(current, \"k-handle\")) {\n            current = current.parentNode;\n        }\n\n        return current;\n    }\n\n    var Selection = Class.extend({\n        init: function(chart, categoryAxis, options, observer) {\n\n            var chartElement = chart.element;\n\n            this.options = deepExtend({}, this.options, options);\n            this.chart = chart;\n            this.observer = observer;\n            this.chartElement = chartElement;\n            this.categoryAxis = categoryAxis;\n            this._dateAxis = this.categoryAxis instanceof dataviz.DateCategoryAxis;\n\n            this.initOptions();\n\n            this.visible = this.options.visible && chartElement.offsetHeight;\n\n            if (this.visible) {\n                this.createElements();\n\n                this.set(this._index(this.options.from), this._index(this.options.to));\n\n                this.bindEvents();\n            }\n        },\n\n        onPane: function(pane) {\n            return this.categoryAxis.pane === pane;\n        },\n\n        createElements: function() {\n            var options = this.options;\n            var wrapper = this.wrapper = createDiv(\"k-selector k-pointer-events-none\");\n            elementStyles(wrapper, {\n                top: options.offset.top,\n                left: options.offset.left,\n                width: options.width,\n                height: options.height,\n                direction: 'ltr'\n            });\n\n            var selection = this.selection = createDiv(\"k-selection k-pointer-events-none\");\n\n            this.leftMask = createDiv(\"k-mask k-pointer-events-none\");\n            this.rightMask = createDiv(\"k-mask k-pointer-events-none\");\n\n            wrapper.appendChild(this.leftMask);\n            wrapper.appendChild(this.rightMask);\n            wrapper.appendChild(selection);\n\n            var body = this.body = createDiv(\"k-selection-bg k-pointer-events-none\");\n            selection.appendChild(body);\n\n            var leftHandle = this.leftHandle = createDiv(\"k-handle k-left-handle k-pointer-events-auto\");\n            var rightHandle = this.rightHandle = createDiv(\"k-handle k-right-handle k-pointer-events-auto\");\n            leftHandle.appendChild(createDiv());\n            rightHandle.appendChild(createDiv());\n\n            selection.appendChild(leftHandle);\n            selection.appendChild(rightHandle);\n\n            this.chartElement.appendChild(wrapper);\n            var selectionStyles = elementStyles(selection, [ \"borderLeftWidth\", \"borderRightWidth\", \"height\" ]);\n            var leftHandleHeight = elementStyles(leftHandle, \"height\").height;\n            var rightHandleHeight = elementStyles(rightHandle, \"height\").height;\n\n            options.selection = {\n                border: {\n                    left: selectionStyles.borderLeftWidth,\n                    right: selectionStyles.borderRightWidth\n                }\n            };\n\n            elementStyles(leftHandle, {\n                top: (selectionStyles.height - leftHandleHeight) / 2\n            });\n\n            elementStyles(rightHandle, {\n                top: (selectionStyles.height - rightHandleHeight) / 2\n            });\n\n            /* eslint no-self-assign: \"off\" */\n            wrapper.style.cssText = wrapper.style.cssText;\n        },\n\n        bindEvents: function() {\n            if (this.options.mousewheel !== false) {\n                this._mousewheelHandler = this._mousewheel.bind(this);\n                var obj;\n                bindEvents(this.chartElement, ( obj = {}, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\n            }\n\n            this._domEvents = services.DomEventsBuilder.create(this.chartElement, {\n                stopPropagation: true, // applicable for the jQuery UserEvents\n                start: this._start.bind(this),\n                move: this._move.bind(this),\n                end: this._end.bind(this),\n                tap: this._tap.bind(this),\n                press: this._press.bind(this),\n                gesturestart: this._gesturestart.bind(this),\n                gesturechange: this._gesturechange.bind(this),\n                gestureend: this._gestureend.bind(this)\n            });\n        },\n\n        initOptions: function() {\n            var ref = this;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var box = categoryAxis.pane.chartsBox();\n            var intlService = this.chart.chartService.intl;\n\n            if (this._dateAxis) {\n                deepExtend(options, {\n                    min: parseDate(intlService, options.min),\n                    max: parseDate(intlService, options.max),\n                    from: parseDate(intlService, options.from),\n                    to: parseDate(intlService, options.to)\n                });\n            }\n\n            var ref$1 = elementStyles(this.chartElement, [ \"paddingLeft\", \"paddingTop\" ]);\n            var paddingLeft = ref$1.paddingLeft;\n            var paddingTop = ref$1.paddingTop;\n\n            this.options = deepExtend({}, {\n                width: box.width(),\n                height: box.height() + SELECTOR_HEIGHT_ADJUST, //workaround for sub-pixel hover on the paths in chrome\n                padding: {\n                    left: paddingLeft,\n                    top: paddingTop\n                },\n                offset: {\n                    left: box.x1 + paddingLeft,\n                    top: box.y1 + paddingTop\n                },\n                from: options.min,\n                to: options.max\n            }, options);\n        },\n\n        destroy: function() {\n            if (this._domEvents) {\n                this._domEvents.destroy();\n                delete this._domEvents;\n            }\n\n            clearTimeout(this._mwTimeout);\n            this._state = null;\n\n            if (this.wrapper) {\n                if (this._mousewheelHandler) {\n                    var obj;\n                    unbindEvents(this.chartElement, ( obj = {}, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\n                    this._mousewheelHandler = null;\n                }\n\n                this.chartElement.removeChild(this.wrapper);\n                this.wrapper = null;\n            }\n        },\n\n        _rangeEventArgs: function(range) {\n\n            return {\n                axis: this.categoryAxis.options,\n                from: this._value(range.from),\n                to: this._value(range.to)\n            };\n        },\n\n        _pointInPane: function(x, y) {\n            var paneBox = this.categoryAxis.pane.box;\n            var modelCoords = this.chart._toModelCoordinates(x, y);\n            return paneBox.containsPoint(modelCoords);\n        },\n\n        _start: function(e) {\n            var options = this.options;\n            var target = eventElement(e);\n            if (this._state || !target) {\n                return;\n            }\n\n            var coords = dataviz.eventCoordinates(e);\n            var inPane = this._pointInPane(coords.x, coords.y);\n            if (!inPane) {\n                return;\n            }\n\n            var handle = closestHandle(target);\n            var bodyRect = this.body.getBoundingClientRect();\n            var inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width &&\n                           coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;\n\n            this.chart._unsetActivePoint();\n            this._state = {\n                moveTarget: handle,\n                startLocation: e.x ? e.x.location : 0,\n                inBody: inBody,\n                range: {\n                    from: this._index(options.from),\n                    to: this._index(options.to)\n                }\n            };\n\n            var args = this._rangeEventArgs({\n                from: this._index(options.from),\n                to: this._index(options.to)\n            });\n\n            if (this.trigger(SELECT_START, args)) {\n                this._state = null;\n            }\n        },\n\n        _press: function(e) {\n            var handle;\n            if (this._state) {\n                handle = this._state.moveTarget;\n            } else {\n                handle = closestHandle(eventElement(e));\n            }\n            if (handle) {\n                dataviz.addClass(handle, \"k-handle-active\");\n            }\n        },\n\n        _move: function(e) {\n            if (!this._state) {\n                return;\n            }\n\n            var ref = this;\n            var state = ref._state;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var range = state.range;\n            var target = state.moveTarget;\n            var reverse = categoryAxis.options.reverse;\n            var from = this._index(options.from);\n            var to = this._index(options.to);\n            var min = this._index(options.min);\n            var max = this._index(options.max);\n            var delta = state.startLocation - e.x.location;\n            var oldRange = { from: range.from, to: range.to };\n            var span = range.to - range.from;\n            var scale = elementStyles(this.wrapper, \"width\").width / (categoryAxis.categoriesCount() - 1);\n            var offset = Math.round(delta / scale) * (reverse ? -1 : 1);\n\n            if (!target && !state.inBody) {\n                return;\n            }\n\n            var leftHandle = target && dataviz.hasClasses(target, \"k-left-handle\");\n            var rightHandle = target && dataviz.hasClasses(target, \"k-right-handle\");\n\n            if (state.inBody) {\n                range.from = Math.min(\n                    Math.max(min, from - offset),\n                    max - span\n                );\n                range.to = Math.min(\n                    range.from + span,\n                    max\n                );\n            } else if ((leftHandle && !reverse) || (rightHandle && reverse)) {\n                range.from = Math.min(\n                    Math.max(min, from - offset),\n                    max - 1\n                );\n                range.to = Math.max(range.from + 1, range.to);\n            } else if ((leftHandle && reverse) || (rightHandle && !reverse)) {\n                range.to = Math.min(\n                    Math.max(min + 1, to - offset),\n                    max\n                );\n                range.from = Math.min(range.to - 1, range.from);\n            }\n\n            if (range.from !== oldRange.from || range.to !== oldRange.to) {\n                this.move(range.from, range.to);\n                this.trigger(SELECT, this._rangeEventArgs(range));\n            }\n        },\n\n        _end: function() {\n            if (this._state) {\n                var moveTarget = this._state.moveTarget;\n                if (moveTarget) {\n                    dataviz.removeClass(moveTarget, \"k-handle-active\");\n                }\n\n                var range = this._state.range;\n                this.set(range.from, range.to);\n                this.trigger(SELECT_END, this._rangeEventArgs(range));\n\n                delete this._state;\n            }\n        },\n\n        _tap: function(e) {\n            var ref = this;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var coords = this.chart._eventCoordinates(e);\n            var categoryIx = categoryAxis.pointCategoryIndex(new Point(coords.x, categoryAxis.box.y1));\n            var from = this._index(options.from);\n            var to = this._index(options.to);\n            var min = this._index(options.min);\n            var max = this._index(options.max);\n            var span = to - from;\n            var mid = from + span / 2;\n            var range = {};\n            var rightClick = e.event.which === 3;\n            var offset = Math.round(mid - categoryIx);\n\n            if (this._state || rightClick) {\n                return;\n            }\n\n            this.chart._unsetActivePoint();\n\n            if (!categoryAxis.options.justified) {\n                offset--;\n            }\n\n            range.from = Math.min(\n                Math.max(min, from - offset),\n                max - span\n            );\n\n            range.to = Math.min(range.from + span, max);\n\n            this._start(e);\n\n            if (this._state) {\n                this._state.range = range;\n                this.trigger(SELECT, this._rangeEventArgs(range));\n                this._end();\n            }\n        },\n\n        _mousewheel: function(e) {\n            var this$1$1 = this;\n\n            var delta = dataviz.mousewheelDelta(e);\n\n            this._start(e);\n\n            if (this._state) {\n                var range = this._state.range;\n\n                e.preventDefault();\n                e.stopPropagation();\n\n                if (Math.abs(delta) > 1) {\n                    delta *= ZOOM_ACCELERATION;\n                }\n\n                if (this.options.mousewheel.reverse) {\n                    delta *= -1;\n                }\n\n                if (this.expand(delta)) {\n                    this.trigger(SELECT, {\n                        axis: this.categoryAxis.options,\n                        delta: delta,\n                        originalEvent: e,\n                        from: this._value(range.from),\n                        to: this._value(range.to)\n                    });\n                }\n\n                if (this._mwTimeout) {\n                    clearTimeout(this._mwTimeout);\n                }\n\n                this._mwTimeout = setTimeout(function () {\n                    this$1$1._end();\n                }, MOUSEWHEEL_DELAY);\n            }\n        },\n\n        _gesturestart: function(e) {\n            var options = this.options;\n            var touch = e.touches[0];\n            var inPane = this._pointInPane(touch.pageX, touch.pageY);\n\n            if (!inPane) {\n                return;\n            }\n\n            this._state = {\n                range: {\n                    from: this._index(options.from),\n                    to: this._index(options.to)\n                }\n            };\n            var args = this._rangeEventArgs(this._state.range);\n\n            if (this.trigger(SELECT_START, args)) {\n                this._state = null;\n            } else {\n                e.preventDefault();\n            }\n        },\n\n        _gestureend: function() {\n            if (this._state) {\n                this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\n                delete this._state;\n            }\n        },\n\n        _gesturechange: function(e) {\n            if (!this._state) {\n                return;\n            }\n\n            var ref = this;\n            var chart = ref.chart;\n            var state = ref._state;\n            var options = ref.options;\n            var categoryAxis = ref.categoryAxis;\n            var range = state.range;\n            var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\n            var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\n            var left = Math.min(p0, p1);\n            var right = Math.max(p0, p1);\n\n            e.preventDefault();\n\n            range.from = categoryAxis.pointCategoryIndex(new Point(left)) || options.min;\n\n            range.to = categoryAxis.pointCategoryIndex(new Point(right)) || options.max;\n\n            this.move(range.from, range.to);\n\n            this.trigger(SELECT, this._rangeEventArgs(range));\n        },\n\n        _index: function(value) {\n            var index = value;\n\n            if (value instanceof Date) {\n                index = this.categoryAxis.categoryIndex(value);\n            }\n\n            return index;\n        },\n\n        _value: function(index) {\n            var value = index;\n            if (this._dateAxis) {\n                value = this.categoryAxis.categoryAt(index);\n                if (value > this.options.max) {\n                    value = this.options.max;\n                }\n            }\n\n            return value;\n        },\n\n        _slot: function(value) {\n            var categoryAxis = this.categoryAxis;\n            var index = this._index(value);\n\n            return categoryAxis.getSlot(index, index, true);\n        },\n\n        move: function(from, to) {\n            var options = this.options;\n            var reverse = this.categoryAxis.options.reverse;\n            var offset = options.offset;\n            var padding = options.padding;\n            var border = options.selection.border;\n            var left = reverse ? to : from;\n            var right = reverse ? from : to;\n            var edge = 'x' + (reverse ? 2 : 1);\n\n            var box = this._slot(left);\n            var leftMaskWidth = round(box[edge] - offset.left + padding.left);\n\n            elementStyles(this.leftMask, {\n                width: leftMaskWidth\n            });\n            elementStyles(this.selection, {\n                left: leftMaskWidth\n            });\n\n            box = this._slot(right);\n\n            var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\n            elementStyles(this.rightMask, {\n                width: rightMaskWidth\n            });\n\n            var distance = options.width - rightMaskWidth;\n            if (distance !== options.width) {\n                distance += border.right;\n            }\n\n            elementStyles(this.rightMask, {\n                left: distance\n            });\n            elementStyles(this.selection, {\n                width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\n            });\n        },\n\n        set: function(from, to) {\n            var options = this.options;\n            var min = this._index(options.min);\n            var max = this._index(options.max);\n            var fromValue = limitValue(this._index(from), min, max);\n            var toValue = limitValue(this._index(to), fromValue + 1, max);\n\n            if (options.visible) {\n                this.move(fromValue, toValue);\n            }\n\n            options.from = this._value(fromValue);\n            options.to = this._value(toValue);\n        },\n\n        expand: function(delta) {\n            var options = this.options;\n            var min = this._index(options.min);\n            var max = this._index(options.max);\n            var zDir = options.mousewheel.zoom;\n            var from = this._index(options.from);\n            var to = this._index(options.to);\n            var range = { from: from, to: to };\n            var oldRange = deepExtend({}, range);\n\n            if (this._state) {\n                range = this._state.range;\n            }\n\n            if (zDir !== RIGHT) {\n                range.from = limitValue(\n                    limitValue(from - delta, 0, to - 1),\n                    min, max\n                );\n            }\n\n            if (zDir !== LEFT) {\n                range.to = limitValue(\n                    limitValue(to + delta, range.from + 1, max),\n                    min,\n                    max\n                );\n            }\n\n            if (range.from !== oldRange.from || range.to !== oldRange.to) {\n                this.set(range.from, range.to);\n                return true;\n            }\n        },\n\n        zoom: function(delta, coords) {\n            var options = this.options;\n            var min = this._index(options.min);\n            var max = this._index(options.max);\n            var from = this._index(options.from);\n            var to = this._index(options.to);\n            var range = { from: from, to: to };\n            var oldRange = deepExtend({}, range);\n\n            var ref = this.categoryAxis.options;\n            var reverse = ref.reverse;\n            var origin = X + (reverse ? '2' : '1');\n            var lineBox = this.categoryAxis.lineBox();\n            var relative = Math.abs(lineBox[origin] - coords[X]);\n            var size = lineBox.width();\n            var position = round(relative / size, 2);\n            var minDelta = round(position * delta);\n            var maxDelta = round((1 - position) * delta);\n\n            if (this._state) {\n                range = this._state.range;\n            }\n\n            range.from = limitValue(\n                limitValue(from - minDelta, 0, to - 1),\n                min, max\n            );\n\n            range.to = limitValue(\n                limitValue(to + maxDelta, range.from + 1, max),\n                min,\n                max\n            );\n\n            if (range.from !== oldRange.from || range.to !== oldRange.to) {\n                this.set(range.from, range.to);\n                return true;\n            }\n        },\n\n        trigger: function(name, args) {\n            return (this.observer || this.chart).trigger(name, args);\n        }\n    });\n\n    setDefaultOptions(Selection, {\n        visible: true,\n        mousewheel: {\n            zoom: \"both\"\n        },\n        min: MIN_VALUE,\n        max: MAX_VALUE\n    });\n\n    var Tooltip = BaseTooltip.extend({\n        show: function(point) {\n            if (!point || !point.tooltipAnchor || (this._current && this._current === point)) {\n                return;\n            }\n\n            var options = deepExtend({}, this.options, point.options.tooltip);\n            var anchor = point.tooltipAnchor();\n\n            if (anchor) {\n                this._current = point;\n                BaseTooltip.fn.show.call(this, {\n                    point: point,\n                    anchor: anchor\n                }, options, point);\n            } else {\n                this.hide();\n            }\n        },\n\n        hide: function() {\n            delete this._current;\n            BaseTooltip.fn.hide.call(this);\n        }\n    });\n\n    var SharedTooltip = BaseTooltip.extend({\n        init: function(plotArea, options) {\n            BaseTooltip.fn.init.call(this, plotArea.chartService, options);\n\n            this.plotArea = plotArea;\n            this.formatService = plotArea.chartService.format;\n        },\n\n        showAt: function(points, coords) {\n            var tooltipPoints = grep(points, function(point) {\n                var tooltip = point.series.tooltip;\n                var excluded = tooltip && tooltip.visible === false;\n\n                return !excluded;\n            });\n\n            if (tooltipPoints.length > 0) {\n                var point = tooltipPoints[0];\n                var slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);\n\n                var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);\n\n                this.show({\n                    anchor: anchor,\n                    shared: true,\n                    points: points,\n                    category: point.category,\n                    categoryText: this.formatService.auto(this.options.categoryFormat, point.category),\n                    series: this.plotArea.series\n                }, this.options);\n            }\n        },\n\n        _slotAnchor: function(point, slot) {\n            var axis = this.plotArea.categoryAxis;\n            var align = {\n                horizontal: \"left\",\n                vertical: \"center\"\n            };\n\n            if (!axis.options.vertical) {\n                point.x = slot.center().x;\n            }\n\n            return {\n                point: point,\n                align: align\n            };\n        },\n\n        _defaultAnchor: function(point, slot) {\n            var box = point.owner.pane.chartsBox();\n            var vertical = this.plotArea.categoryAxis.options.vertical;\n            var center = box.center();\n            var slotCenter = slot.center();\n            var align = {\n                horizontal: \"center\",\n                vertical: \"center\"\n            };\n\n            var centerPoint;\n            if (vertical) {\n                centerPoint = new Point(center.x, slotCenter.y);\n            } else {\n                centerPoint = new Point(slotCenter.x, center.y);\n            }\n\n            return {\n                point: centerPoint,\n                align: align\n            };\n        }\n    });\n\n    setDefaultOptions(SharedTooltip, {\n        categoryFormat: '{0:d}'\n    });\n\n    var BarChartAnimation = Animation.extend({\n        setup: function() {\n            var ref = this;\n            var element = ref.element;\n            var options = ref.options;\n            var bbox = element.bbox();\n\n            if (bbox) {\n                this.origin = options.origin;\n                var axis = options.vertical ? Y : X;\n\n                var fromScale = this.fromScale = new GeometryPoint(1, 1);\n                fromScale[axis] = START_SCALE;\n\n                element.transform(transform()\n                    .scale(fromScale.x, fromScale.y)\n                );\n            } else {\n                this.abort();\n            }\n        },\n\n        step: function(pos) {\n            var scaleX = dataviz.interpolateValue(this.fromScale.x, 1, pos);\n            var scaleY = dataviz.interpolateValue(this.fromScale.y, 1, pos);\n\n            this.element.transform(transform()\n                .scale(scaleX, scaleY, this.origin)\n            );\n        },\n\n        abort: function() {\n            Animation.fn.abort.call(this);\n            this.element.transform(null);\n        }\n    });\n\n    setDefaultOptions(BarChartAnimation, {\n        duration: INITIAL_ANIMATION_DURATION\n    });\n\n    AnimationFactory.current.register(BAR, BarChartAnimation);\n\n    var BubbleAnimation = Animation.extend({\n        setup: function() {\n            var center = this.center = this.element.bbox().center();\n            this.element.transform(transform()\n                .scale(START_SCALE, START_SCALE, center)\n            );\n        },\n\n        step: function(pos) {\n            this.element.transform(transform()\n                .scale(pos, pos, this.center)\n            );\n        }\n    });\n\n    setDefaultOptions(BubbleAnimation, {\n        easing: \"easeOutElastic\"\n    });\n\n    AnimationFactory.current.register(BUBBLE, BubbleAnimation);\n\n    var FadeInAnimation = Animation.extend({\n        setup: function() {\n            this.fadeTo = this.element.opacity();\n            this.element.opacity(0);\n        },\n\n        step: function(pos) {\n            this.element.opacity(pos * this.fadeTo);\n        }\n    });\n\n    setDefaultOptions(FadeInAnimation, {\n        duration: 200,\n        easing: \"linear\"\n    });\n\n    AnimationFactory.current.register(FADEIN, FadeInAnimation);\n\n    var PieAnimation = Animation.extend({\n        setup: function() {\n            this.element.transform(transform()\n                .scale(START_SCALE, START_SCALE, this.options.center)\n            );\n        },\n\n        step: function(pos) {\n            this.element.transform(transform()\n                .scale(pos, pos, this.options.center)\n            );\n        }\n    });\n\n    setDefaultOptions(PieAnimation, {\n        easing: \"easeOutElastic\",\n        duration: INITIAL_ANIMATION_DURATION\n    });\n\n    AnimationFactory.current.register(PIE, PieAnimation);\n\n    var ScatterLineChart = ScatterChart.extend({\n        render: function() {\n            ScatterChart.fn.render.call(this);\n\n            this.renderSegments();\n        },\n\n        createSegment: function(linePoints, currentSeries, seriesIx) {\n            var style = currentSeries.style;\n            var pointType;\n\n            if (style === SMOOTH) {\n                pointType = SplineSegment;\n            } else {\n                pointType = LineSegment;\n            }\n\n            return new pointType(linePoints, currentSeries, seriesIx);\n        },\n\n        animationPoints: function() {\n            var points = ScatterChart.fn.animationPoints.call(this);\n            return points.concat(this._segments);\n        },\n\n        createMissingValue: function(value, missingValues) {\n            if (missingValues === ZERO) {\n                var missingValue = {\n                    x: value.x,\n                    y: value.y\n                };\n                if (!hasValue(missingValue.x)) {\n                    missingValue.x = 0;\n                }\n                if (!hasValue(missingValue.y)) {\n                    missingValue.y = 0;\n                }\n                return missingValue;\n            }\n        }\n    });\n\n    deepExtend(ScatterLineChart.prototype, LineChartMixin);\n\n    function autoMajorUnit(min, max) {\n        var diff = round(max - min, DEFAULT_PRECISION - 1);\n\n        if (diff === 0) {\n            if (max === 0) {\n                return 0.1;\n            }\n\n            diff = Math.abs(max);\n        }\n\n        var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n        var relativeValue = round((diff / scale), DEFAULT_PRECISION);\n        var scaleMultiplier = 1;\n\n        if (relativeValue < 1.904762) {\n            scaleMultiplier = 0.2;\n        } else if (relativeValue < 4.761904) {\n            scaleMultiplier = 0.5;\n        } else if (relativeValue < 9.523809) {\n            scaleMultiplier = 1;\n        } else {\n            scaleMultiplier = 2;\n        }\n\n        return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n    }\n\n    function getScatterTrendlineData(valueMapper, range, options) {\n        var data = [];\n        var xMin = range.xMin;\n        var xMax = range.xMax;\n\n        var forecast = (options || {}).forecast;\n        if (forecast) {\n            if (forecast.before > 0) {\n                xMin -= forecast.before;\n            }\n\n            if (forecast.after > 0) {\n                xMax += forecast.after;\n            }\n        }\n\n        var samplingInterval = (options || {}).samplingInterval;\n        var delta = valueOrDefault(samplingInterval,  autoMajorUnit(xMin, xMax) / 10);\n        if (samplingInterval <= 0) {\n            delta = xMax - xMin;\n        }\n\n        for (var x = xMin; x <= xMax; x += delta) {\n            data.push([\n                x,\n                valueMapper(x)\n            ]);\n        }\n\n        return data;\n    }\n\n    function scatterExponentialTrendline(context) {\n        var options = context.options;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$6({ seriesValues: seriesValues, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'scatterLine',\n                data: data});\n        }\n\n        return null;\n    }\n\n    var valueGetter$6 = function (fieldName) { return function (ref) {\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: valueFields.x, yValue: Math.log(valueFields[fieldName]) });\n     }    };\n\n    function getData$6(ref) {\n        var seriesValues = ref.seriesValues;\n        var options = ref.options;\n\n        var sourceValues = seriesValues();\n        if (!checkAllPositive(sourceValues, options.field)) {\n            return null;\n        }\n\n        var ref$1 = calculateSlope(sourceValues, valueGetter$6(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        var xMin = ref$1.xMin;\n        var xMax = ref$1.xMax;\n        var range = { xMin: xMin, xMax: xMax };\n\n        if (count > 0) {\n            // Exponential trendline equation:\n            // y = a * e ^ (b * x)\n            var a = Math.exp(intercept);\n            var b = slope;\n\n            return getScatterTrendlineData(function (x) { return a * Math.exp(b * x); }, range, options.trendline);\n        }\n\n        return null;\n    }\n\n    var scatterValueGetter = function (fieldName) { return function (ref) {\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: valueFields.x, yValue: valueFields[fieldName] });\n     }    };\n\n    function scatterLinearTrendline(context) {\n        var options = context.options;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$7({ seriesValues: seriesValues, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'scatterLine',\n                data: data});\n        }\n\n        return null;\n    }\n\n    function getData$7(ref) {\n        var seriesValues = ref.seriesValues;\n        var options = ref.options;\n\n        var ref$1 = calculateSlope(seriesValues(), scatterValueGetter(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        var xMin = ref$1.xMin;\n        var xMax = ref$1.xMax;\n        var range = { xMin: xMin, xMax: xMax };\n\n        if (count > 0) {\n            return getScatterTrendlineData(function (x) { return slope * x + intercept; }, range, options.trendline);\n        }\n\n        return null;\n    }\n\n    function xValueLimits(sourceValues, valueGetter) {\n        var xMin = Number.MAX_VALUE;\n        var xMax = Number.MIN_VALUE;\n\n        for (var i = 0; i < sourceValues.length; i++) {\n            var value = sourceValues[i];\n            var ref = valueGetter(value);\n            var xValue = ref.xValue;\n            var yValue = ref.yValue;\n\n            if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {\n                xMin = Math.min(xValue, xMin);\n                xMax = Math.max(xValue, xMax);\n            }\n        }\n\n        return { xMin: xMin, xMax: xMax };\n    }\n\n    function scatterLogarithmicTrendline(context) {\n        var options = context.options;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$8({ seriesValues: seriesValues, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'scatterLine',\n                data: data});\n        }\n\n        return null;\n    }\n\n    var valueGetter$7 = function (fieldName) { return function (ref) {\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: valueFields.x, yValue: valueFields[fieldName] });\n     }    };\n\n    var logValueGetter = function (fieldName) { return function (ref) {\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: Math.log(valueFields.x), yValue: valueFields[fieldName] });\n     }    };\n\n    function getData$8(ref) {\n        var seriesValues = ref.seriesValues;\n        var options = ref.options;\n\n        var sourceValues = seriesValues();\n        if (!checkAllPositive(sourceValues, 'x')) {\n            return null;\n        }\n\n        var ref$1 = calculateSlope(sourceValues, logValueGetter(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        var range = xValueLimits(sourceValues, valueGetter$7(options.field));\n\n        if (count > 0) {\n            // Logarithmic trendline equation:\n            // y = a * ln (x) + b\n            var a = slope;\n            var b = intercept;\n\n            return getScatterTrendlineData(function (x) { return a * Math.log(x) + b; }, range, options.trendline);\n        }\n\n        return null;\n    }\n\n    function scatterMovingAverageTrendline(context) {\n        var options = context.options;\n\n        var data = getData$9(context);\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'scatterLine',\n                data: data});\n        }\n\n        return null;\n    }\n\n    function getData$9(ref) {\n        var options = ref.options;\n        var seriesValues = ref.seriesValues;\n\n        var period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;\n        var range = { before: period, after: period };\n        var data = calculateMovingAverage(seriesValues(range), scatterValueGetter(options.field), period);\n\n        if (data.length > 0) {\n            return data;\n        }\n\n        return null;\n    }\n\n    function scatterPolynomialTrendline(context) {\n        var options = context.options;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$10({ seriesValues: seriesValues, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'scatterLine',\n                data: data});\n        }\n\n        return null;\n    }\n\n    function getData$10(ref) {\n        var seriesValues = ref.seriesValues;\n        var options = ref.options;\n\n        var order = (options.trendline || {}).order;\n        var valueGetter = scatterValueGetter(options.field);\n        var ref$1 = calculatePolynomial(seriesValues(), valueGetter, order);\n        var count = ref$1.count;\n        var valueMapper = ref$1.valueMapper;\n        var xMin = ref$1.xMin;\n        var xMax = ref$1.xMax;\n        var range = { xMin: xMin, xMax: xMax };\n\n        if (count > 0) {\n            // Polynomial trendline equation:\n            // y = aN * x^N + ... + a2 * x^2 + a1 * x + a0\n            return getScatterTrendlineData(valueMapper, range, options.trendline);\n        }\n\n        return null;\n    }\n\n    function scatterPowerTrendline(context) {\n        var options = context.options;\n        var seriesValues = context.seriesValues;\n\n        var data = getData$11({ seriesValues: seriesValues, options: options });\n        if (data) {\n            return $.extend({}, options,\n\n                {type: 'scatterLine',\n                data: data});\n        }\n\n        return null;\n    }\n\n    var valueGetter$8 = function (fieldName) { return function (ref) {\n            var valueFields = ref.valueFields;\n\n            return ({ xValue: Math.log(valueFields.x), yValue: Math.log(valueFields[fieldName]) });\n     }    };\n\n    function getData$11(ref) {\n        var seriesValues = ref.seriesValues;\n        var options = ref.options;\n\n        var sourceValues = seriesValues();\n        if (!checkAllPositive(sourceValues, 'x')) {\n            return null;\n        }\n\n        var ref$1 = calculateSlope(sourceValues, valueGetter$8(options.field));\n        var slope = ref$1.slope;\n        var intercept = ref$1.intercept;\n        var count = ref$1.count;\n        var range = xValueLimits(sourceValues, scatterValueGetter(options.field));\n\n        if (count > 0) {\n            // Power trendline equation:\n            // y = a * x ^ b\n            var a = Math.exp(intercept);\n            var b = slope;\n            return getScatterTrendlineData(function (x) { return a * Math.pow(x, b); }, range, options.trendline);\n        }\n\n        return null;\n    }\n\n    var scatterRegistry = {};\n    scatterRegistry[TRENDLINE_EXPONENTIAL] = scatterExponentialTrendline;\n    scatterRegistry[TRENDLINE_LINEAR] = scatterLinearTrendline;\n    scatterRegistry[TRENDLINE_LOGARITHMIC] = scatterLogarithmicTrendline;\n    scatterRegistry[TRENDLINE_MOVING_AVERAGE] = scatterMovingAverageTrendline;\n    scatterRegistry[TRENDLINE_POLYNOMIAL] = scatterPolynomialTrendline;\n    scatterRegistry[TRENDLINE_POWER] = scatterPowerTrendline;\n\n    var XYPlotArea = PlotAreaBase.extend({\n        initFields: function() {\n            this.namedXAxes = {};\n            this.namedYAxes = {};\n\n            this.xAxisRangeTracker = new AxisGroupRangeTracker();\n            this.yAxisRangeTracker = new AxisGroupRangeTracker();\n        },\n\n        render: function(panes) {\n            var this$1$1 = this;\n            if (panes === void 0) { panes = this.panes; }\n\n            this.series = [].concat( this.originalSeries );\n            this.createTrendlineSeries();\n\n            var seriesByPane = this.groupSeriesByPane();\n            for (var i = 0; i < panes.length; i++) {\n                var pane = panes[i];\n                var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n                this$1$1.addToLegend(paneSeries);\n                var filteredSeries = this$1$1.filterVisibleSeries(paneSeries);\n\n                if (!filteredSeries) {\n                    continue;\n                }\n\n                this$1$1.createScatterChart(\n                    filterSeriesByType(filteredSeries, SCATTER),\n                    pane\n                );\n\n                this$1$1.createScatterLineChart(\n                    filterSeriesByType(filteredSeries, SCATTER_LINE),\n                    pane\n                );\n\n                this$1$1.createBubbleChart(\n                    filterSeriesByType(filteredSeries, BUBBLE),\n                    pane\n                );\n            }\n\n            this.createAxes(panes);\n        },\n\n        appendChart: function(chart, pane) {\n            this.xAxisRangeTracker.update(chart.xAxisRanges);\n            this.yAxisRangeTracker.update(chart.yAxisRanges);\n\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n        },\n\n        removeAxis: function(axis) {\n            var axisName = axis.options.name;\n\n            PlotAreaBase.fn.removeAxis.call(this, axis);\n\n            if (axis.options.vertical) {\n                this.yAxisRangeTracker.reset(axisName);\n                delete this.namedYAxes[axisName];\n            } else {\n                this.xAxisRangeTracker.reset(axisName);\n                delete this.namedXAxes[axisName];\n            }\n\n            if (axis === this.axisX) {\n                delete this.axisX;\n            }\n\n            if (axis === this.axisY) {\n                delete this.axisY;\n            }\n        },\n\n        seriesPaneName: function(series) {\n            var options = this.options;\n            var xAxisName = series.xAxis;\n            var xAxisOptions = [].concat(options.xAxis);\n            var xAxis = grep(xAxisOptions, function(a) { return a.name === xAxisName; })[0];\n            var yAxisName = series.yAxis;\n            var yAxisOptions = [].concat(options.yAxis);\n            var yAxis = grep(yAxisOptions, function(a) { return a.name === yAxisName; })[0];\n            var panes = options.panes || [ {} ];\n            var defaultPaneName = panes[0].name || \"default\";\n            var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n\n            return paneName;\n        },\n\n        createScatterChart: function(series, pane) {\n            if (series.length > 0) {\n                this.appendChart(\n                    new ScatterChart(this, { series: series, clip: pane.options.clip }),\n                    pane\n                );\n            }\n        },\n\n        createScatterLineChart: function(series, pane) {\n            if (series.length > 0) {\n                this.appendChart(\n                    new ScatterLineChart(this, { series: series, clip: pane.options.clip }),\n                    pane\n                );\n            }\n        },\n\n        createBubbleChart: function(series, pane) {\n            if (series.length > 0) {\n                this.appendChart(\n                    new BubbleChart(this, { series: series, clip: pane.options.clip }),\n                    pane\n                );\n            }\n        },\n\n        createXYAxis: function(options, vertical, axisIndex) {\n            var axisName = options.name;\n            var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n            var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n            var axisOptions = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical: vertical });\n            var isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n            var defaultRange = tracker.query();\n            var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n            var range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n            var typeSamples = [ axisOptions.min, axisOptions.max ];\n            var series = this.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n                if ((seriesAxisName === axisOptions.name) || (axisIndex === 0 && !seriesAxisName)) {\n                    var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n                    typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n\n                    break;\n                }\n            }\n\n            if (axisIndex === 0 && defaultRange) {\n                range.min = Math.min(range.min, defaultRange.min);\n                range.max = Math.max(range.max, defaultRange.max);\n            }\n\n            var inferredDate;\n\n            for (var i = 0; i < typeSamples.length; i++) {\n                if (typeSamples[i] instanceof Date) {\n                    inferredDate = true;\n                    break;\n                }\n            }\n\n            var axisType;\n            if (equalsIgnoreCase(axisOptions.type, DATE) || (!axisOptions.type && inferredDate)) {\n                axisType = dataviz.DateValueAxis;\n            } else if (isLog) {\n                axisType = dataviz.LogarithmicAxis;\n            } else {\n                axisType = dataviz.NumericAxis;\n            }\n\n            var axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n            axis.axisIndex = axisIndex;\n\n            if (axisName) {\n                if (namedAxes[axisName]) {\n                    throw new Error(((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\"));\n                }\n                namedAxes[axisName] = axis;\n            }\n\n            this.appendAxis(axis);\n\n            return axis;\n        },\n\n        createAxes: function(panes) {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var xAxesOptions = [].concat(options.xAxis);\n            var xAxes = [];\n            var yAxesOptions = [].concat(options.yAxis);\n            var yAxes = [];\n\n            for (var idx = 0; idx < xAxesOptions.length; idx++) {\n                var axisPane = this$1$1.findPane(xAxesOptions[idx].pane);\n                if (inArray(axisPane, panes)) {\n                    xAxes.push(this$1$1.createXYAxis(xAxesOptions[idx], false, idx));\n                }\n            }\n\n            for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n                var axisPane$1 = this$1$1.findPane(yAxesOptions[idx$1].pane);\n                if (inArray(axisPane$1, panes)) {\n                    yAxes.push(this$1$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n                }\n            }\n\n            this.axisX = this.axisX || xAxes[0];\n            this.axisY = this.axisY || yAxes[0];\n        },\n\n        _dispatchEvent: function(chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n            var point = new Point(coords.x, coords.y);\n            var allAxes = this.axes;\n            var length = allAxes.length;\n            var xValues = [];\n            var yValues = [];\n\n            for (var i = 0; i < length; i++) {\n                var axis = allAxes[i];\n                var values = axis.options.vertical ? yValues : xValues;\n                var currentValue = axis.getValue(point);\n                if (currentValue !== null) {\n                    values.push(currentValue);\n                }\n            }\n\n            if (xValues.length > 0 && yValues.length > 0) {\n                chart.trigger(eventType, {\n                    element: eventElement(e),\n                    originalEvent: e,\n                    x: singleItemOrArray(xValues),\n                    y: singleItemOrArray(yValues)\n                });\n            }\n        },\n\n        updateAxisOptions: function(axis, options) {\n            var vertical = axis.options.vertical;\n            var axes = this.groupAxes(this.panes);\n            var index = (vertical ? axes.y : axes.x).indexOf(axis);\n\n            updateAxisOptions$1(this.options, index, vertical, options);\n            updateAxisOptions$1(this.originalOptions, index, vertical, options);\n        },\n\n        trendlineFactory: function(options, series) {\n            var seriesValues = this.seriesValues.bind(this, series.index);\n\n            var trendline = trendlineFactory(scatterRegistry, options.type, {\n                options: options,\n                seriesValues: seriesValues\n            });\n\n            if (trendline) {\n                // Inherit settings\n                trendline.xAxis = series.xAxis;\n                trendline.yAxis = series.yAxis;\n            }\n\n            return trendline;\n        },\n\n        seriesValues: function(seriesIx) {\n            var this$1$1 = this;\n\n            var result = [];\n            var currentSeries = this.series[seriesIx];\n\n            for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                var data = this$1$1.bindPoint(currentSeries, pointIx);\n                result.push({ pointIx: pointIx, valueFields: data.valueFields });\n            }\n\n            return result;\n        }\n    });\n\n    function updateAxisOptions$1(targetOptions, axisIndex, vertical, options) {\n        var axisOptions = ([].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis))[axisIndex];\n        deepExtend(axisOptions, options);\n    }\n\n    setDefaultOptions(XYPlotArea, {\n        xAxis: {},\n        yAxis: {}\n    });\n\n    deepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\n\n    var PieSegment = ChartElement.extend({\n        init: function(value, sector, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.value = value;\n            this.sector = sector;\n        },\n\n        render: function() {\n            if (this._rendered || this.visible === false) {\n                return;\n            }\n            this._rendered = true;\n\n            this.createLabel();\n        },\n\n        createLabel: function() {\n            var labels = this.options.labels;\n            var chartService = this.owner.chartService;\n            var labelText = this.getLabelText(labels);\n\n            if (labels.visible && (labelText || labelText === 0)) {\n                if (labels.position === CENTER || labels.position === INSIDE_END) {\n                    if (!labels.color) {\n                        labels.color = autoTextColor(this.options.color);\n                    }\n                    if (!labels.background) {\n                        labels.background = this.options.color;\n                    }\n                } else {\n                    var themeLabels = chartService.theme.seriesDefaults.labels;\n                    labels.color = labels.color || themeLabels.color;\n                    labels.background = labels.background || themeLabels.background;\n                }\n\n                this.label = new TextBox(labelText, deepExtend({}, labels, {\n                    align: CENTER,\n                    vAlign: \"\",\n                    animation: {\n                        type: FADEIN,\n                        delay: this.animationDelay\n                    }\n                }), this.pointData());\n\n                this.append(this.label);\n            }\n        },\n\n        getLabelText: function(options) {\n            var labelTemplate = getTemplate(options);\n\n            if (labelTemplate) {\n                return labelTemplate(this.pointData());\n            }\n\n            return this.owner.chartService.format.auto(options.format, this.value);\n        },\n\n        reflow: function(targetBox) {\n            this.render();\n            this.box = targetBox;\n            this.reflowLabel();\n        },\n\n        reflowLabel: function() {\n            var ref = this;\n            var labelsOptions = ref.options.labels;\n            var label = ref.label;\n            var sector = this.sector.clone();\n            var labelsDistance = labelsOptions.distance;\n            var angle = sector.middle();\n\n            if (label) {\n                var labelHeight = label.box.height();\n                var labelWidth = label.box.width();\n                var lp;\n\n                if (labelsOptions.position === CENTER) {\n                    sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\n                    lp = sector.point(angle);\n                    label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n                } else if (labelsOptions.position === INSIDE_END) {\n                    sector.radius = sector.radius - labelHeight / 2;\n                    lp = sector.point(angle);\n                    label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n                } else {\n                    var x1;\n                    lp = sector.clone().expand(labelsDistance).point(angle);\n                    if (lp.x >= sector.center.x) {\n                        x1 = lp.x + labelWidth;\n                        label.orientation = RIGHT;\n                    } else {\n                        x1 = lp.x - labelWidth;\n                        label.orientation = LEFT;\n                    }\n                    label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));\n                }\n            }\n        },\n\n        createVisual: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var sector = ref.sector;\n            var options = ref.options;\n\n            ChartElement.fn.createVisual.call(this);\n\n            this.addAccessibilityAttributesToVisual();\n\n            if (this.value) {\n                if (options.visual) {\n                    var startAngle = (sector.startAngle + 180) % 360;\n                    var visual = options.visual({\n                        category: this.category,\n                        dataItem: this.dataItem,\n                        value: this.value,\n                        series: this.series,\n                        percentage: this.percentage,\n                        center: new GeometryPoint(sector.center.x, sector.center.y),\n                        radius: sector.radius,\n                        innerRadius: sector.innerRadius,\n                        startAngle: startAngle,\n                        endAngle: startAngle + sector.angle,\n                        options: options,\n                        sender: this.getSender(),\n                        createVisual: function () {\n                            var group = new Group();\n                            this$1$1.createSegmentVisual(group);\n\n                            return group;\n                        }\n                    });\n\n                    if (visual) {\n                        this.visual.append(visual);\n                    }\n                } else {\n                    this.createSegmentVisual(this.visual);\n                }\n            }\n        },\n\n        createSegmentVisual: function(group) {\n            var ref = this;\n            var sector = ref.sector;\n            var options = ref.options;\n            var borderOptions = options.border || {};\n            var border = borderOptions.width > 0 ? {\n                stroke: {\n                    color: borderOptions.color,\n                    width: borderOptions.width,\n                    opacity: borderOptions.opacity,\n                    dashType: borderOptions.dashType\n                }\n            } : {};\n            var color = options.color;\n            var fill = {\n                color: color,\n                opacity: options.opacity\n            };\n            var visual = this.createSegment(sector, deepExtend({\n                fill: fill,\n                stroke: {\n                    opacity: options.opacity\n                },\n                zIndex: options.zIndex\n            }, border));\n\n            group.append(visual);\n\n            if (hasGradientOverlay(options)) {\n                group.append(this.createGradientOverlay(visual, {\n                    baseColor: color,\n                    fallbackFill: fill\n                }, deepExtend({\n                    center: [ sector.center.x, sector.center.y ],\n                    innerRadius: sector.innerRadius,\n                    radius: sector.radius,\n                    userSpace: true\n                }, options.overlay)));\n            }\n        },\n\n        createSegment: function(sector, options) {\n            if (options.singleSegment) {\n                return new Circle(new GeometryCircle(new GeometryPoint(sector.center.x, sector.center.y), sector.radius), options);\n            }\n\n            return dataviz.ShapeBuilder.current.createRing(sector, options);\n        },\n\n        createAnimation: function() {\n            var ref = this;\n            var options = ref.options;\n            var center = ref.sector.center;\n\n            deepExtend(options, {\n                animation: {\n                    center: [ center.x, center.y ],\n                    delay: this.animationDelay\n                }\n            });\n\n            ChartElement.fn.createAnimation.call(this);\n        },\n\n        createHighlight: function(options) {\n            var highlight = this.options.highlight || {};\n            var border = highlight.border || {};\n\n            return this.createSegment(this.sector, deepExtend({}, options, {\n                fill: {\n                    color: highlight.color,\n                    opacity: highlight.opacity\n                },\n                stroke: {\n                    opacity: border.opacity,\n                    width: border.width,\n                    color: border.color\n                }\n            }));\n        },\n\n        highlightVisual: function() {\n            return this.visual.children[0];\n        },\n\n        highlightVisualArgs: function() {\n            var sector = this.sector;\n\n            return {\n                options: this.options,\n                radius: sector.radius,\n                innerRadius: sector.innerRadius,\n                center: new GeometryPoint(sector.center.x, sector.center.y),\n                startAngle: sector.startAngle,\n                endAngle: sector.angle + sector.startAngle,\n                visual: this.visual\n            };\n        },\n\n        createFocusHighlight: function(style) {\n            var borderWidth = this.options.accessibility.highlight.border.width;\n            var result = this.createSegment(this.sector, deepExtend({}, style, {\n                stroke: {\n                    width: borderWidth * 2\n                }\n            }));\n\n            var clipPath = new MultiPath();\n\n            clipPath.paths.push(Path.fromRect(result.bbox()));\n            clipPath.paths.push(this.createSegment(this.sector, {}));\n\n            result.clip(clipPath);\n\n            return result;\n        },\n\n        tooltipAnchor: function() {\n            var sector = this.sector.clone().expand(TOOLTIP_OFFSET);\n            var midAndle = sector.middle();\n            var midPoint = sector.point(midAndle);\n\n            return {\n                point: midPoint,\n                align: tooltipAlignment(midAndle + 180)\n            };\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        pointData: function() {\n            return {\n                dataItem: this.dataItem,\n                category: this.category,\n                value: this.value,\n                series: this.series,\n                percentage: this.percentage\n            };\n        },\n\n        getIndex: function() {\n            return this.index;\n        }\n    });\n\n    var RAD_30 = round(rad(30), DEFAULT_PRECISION);\n    var RAD_60 = round(rad(60), DEFAULT_PRECISION);\n\n    function tooltipAlignment(angle) {\n        var radians = rad(angle);\n        var sine = round(Math.sin(radians), DEFAULT_PRECISION);\n        var cosine = round(Math.cos(radians), DEFAULT_PRECISION);\n\n        var horizontal;\n        if (Math.abs(sine) > RAD_60) {\n            horizontal = CENTER;\n        } else if (cosine < 0) {\n            horizontal = RIGHT;\n        } else {\n            horizontal = LEFT;\n        }\n\n        var vertical;\n        if (Math.abs(sine) < RAD_30) {\n            vertical = CENTER;\n        } else if (sine < 0) {\n            vertical = BOTTOM;\n        } else {\n            vertical = TOP;\n        }\n\n        return {\n            horizontal: horizontal,\n            vertical: vertical\n        };\n    }\n\n    setDefaultOptions(PieSegment, {\n        color: WHITE,\n        overlay: {\n            gradient: \"roundedBevel\"\n        },\n        border: {\n            width: 0.5\n        },\n        labels: {\n            visible: false,\n            distance: 35,\n            font: datavizConstants.DEFAULT_FONT,\n            margin: getSpacing(0.5),\n            align: CIRCLE,\n            zIndex: 1,\n            position: OUTSIDE_END\n        },\n        animation: {\n            type: PIE\n        },\n        highlight: {\n            visible: true,\n            border: {\n                width: 1\n            }\n        },\n        visible: true,\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    });\n\n    deepExtend(PieSegment.prototype, PointEventsMixin);\n    deepExtend(PieSegment.prototype, AccessibilityAttributesMixin);\n\n    var PieChartMixin = {\n        createLegendItem: function(value, point, options) {\n            var legendOptions = this.options.legend || {};\n            var labelsOptions = legendOptions.labels || {};\n            var inactiveItems = legendOptions.inactiveItems || {};\n            var inactiveItemsLabels = inactiveItems.labels || {};\n\n            if (options && options.visibleInLegend !== false) {\n                var pointVisible = options.visible !== false;\n                var labelTemplate = pointVisible ? getTemplate(labelsOptions) :\n                    getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);\n                var text = options.category;\n\n                if (labelTemplate) {\n                    text = labelTemplate({\n                        text: text,\n                        series: options.series,\n                        dataItem: options.dataItem,\n                        percentage: options.percentage,\n                        value: value\n                    });\n                }\n\n                var itemLabelOptions, markerColor;\n                if (pointVisible) {\n                    itemLabelOptions = {};\n                    markerColor = point.color;\n                } else {\n                    itemLabelOptions = {\n                        color: inactiveItemsLabels.color,\n                        font: inactiveItemsLabels.font\n                    };\n                    markerColor = (inactiveItems.markers || {}).color;\n                }\n\n                if (hasValue(text) && text !== \"\") {\n                    this.legendItems.push({\n                        active: pointVisible,\n                        pointIndex: options.index,\n                        text: text,\n                        series: options.series,\n                        markerColor: markerColor,\n                        labels: itemLabelOptions\n                    });\n                }\n            }\n        }\n    };\n\n    var PIE_SECTOR_ANIM_DELAY = 70;\n\n    var PieChart = ChartElement.extend({\n        init: function(plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this.points = [];\n            this.legendItems = [];\n            this.render();\n        },\n\n        render: function() {\n            this.traverseDataPoints(this.addValue.bind(this));\n        },\n\n        traverseDataPoints: function(callback) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var seriesColors = ref.plotArea.options.seriesColors; if (seriesColors === void 0) { seriesColors = []; }\n            var colorsCount = seriesColors.length;\n            var series = options.series;\n            var seriesCount = series.length;\n\n            for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var data = currentSeries.data;\n                var ref$1 = bindSegments(currentSeries);\n                var total = ref$1.total;\n                var points = ref$1.points;\n                var count = ref$1.count;\n                var anglePerValue = 360 / total;\n                var constantAngle = (void 0);\n                if (!isFinite(anglePerValue)) {\n                    constantAngle = 360 / count;\n                }\n                var currentAngle = (void 0);\n\n                if (defined(currentSeries.startAngle)) {\n                    currentAngle = currentSeries.startAngle;\n                } else {\n                    currentAngle = options.startAngle;\n                }\n\n                if (seriesIx !== seriesCount - 1) {\n                    if (currentSeries.labels.position === OUTSIDE_END) {\n                        currentSeries.labels.position = CENTER;\n                    }\n                }\n\n                for (var i = 0; i < points.length; i++) {\n                    var pointData = points[i];\n                    if (!pointData) {\n                        continue;\n                    }\n\n                    var fields = pointData.fields;\n                    var value = pointData.value;\n                    var visible = pointData.visible;\n                    var angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\n                    var explode = data.length !== 1 && Boolean(fields.explode);\n\n                    if (!isFunction(currentSeries.color)) {\n                        currentSeries.color = fields.color || seriesColors[i % colorsCount];\n                    }\n\n                    callback(value, new dataviz.Ring(null, 0, 0, currentAngle, angle), {\n                        owner: this$1$1,\n                        category: defined(fields.category) ? fields.category : \"\",\n                        index: i,\n                        series: currentSeries,\n                        seriesIx: seriesIx,\n                        dataItem: data[i],\n                        percentage: total !== 0 ? value / total : 0,\n                        explode: explode,\n                        visibleInLegend: fields.visibleInLegend,\n                        visible: visible,\n                        zIndex: seriesCount - seriesIx,\n                        animationDelay: this$1$1.animationDelay(i, seriesIx, seriesCount)\n                    });\n\n                    if (visible !== false) {\n                        currentAngle += angle;\n                    }\n                }\n            }\n        },\n\n        evalSegmentOptions: function(options, value, fields) {\n            var series = fields.series;\n\n            evalOptions(options, {\n                value: value,\n                series: series,\n                dataItem: fields.dataItem,\n                category: fields.category,\n                percentage: fields.percentage\n            }, { defaults: series._defaults, excluded: [\n                \"data\", \"content\", \"template\", \"visual\", \"toggle\",\n                \"ariaTemplate\", \"ariaContent\"\n            ] });\n        },\n\n        addValue: function(value, sector, fields) {\n            var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n            this.evalSegmentOptions(segmentOptions, value, fields);\n\n            this.createLegendItem(value, segmentOptions, fields);\n\n            if (fields.visible === false) {\n                return;\n            }\n\n            var segment = new PieSegment(value, sector, segmentOptions);\n            $.extend(segment, fields);\n            this.append(segment);\n            this.points.push(segment);\n        },\n\n        reflow: function(targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var points = ref.points;\n            var seriesConfigs = ref.seriesConfigs; if (seriesConfigs === void 0) { seriesConfigs = []; }\n            var count = points.length;\n            var box = targetBox.clone();\n            var space = 5;\n            var minWidth = Math.min(box.width(), box.height());\n            var halfMinWidth = minWidth / 2;\n            var defaultPadding = minWidth - minWidth * 0.85;\n            var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n            var newBoxCenter = newBox.center();\n            var boxCenter = box.center();\n            var seriesCount = options.series.length;\n            var leftSideLabels = [];\n            var rightSideLabels = [];\n            var padding = valueOrDefault(options.padding, defaultPadding);\n\n            this.targetBox = targetBox;\n\n            padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n            newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n\n            var radius = halfMinWidth - padding;\n            var center = new Point(\n                radius + newBox.x1 + padding,\n                radius + newBox.y1 + padding\n            );\n\n            for (var i = 0; i < count; i++) {\n                var segment = points[i];\n                var sector = segment.sector;\n                var seriesIndex = segment.seriesIx;\n                sector.radius = radius;\n                sector.center = center;\n\n                if (seriesConfigs.length) {\n                    var seriesConfig = seriesConfigs[seriesIndex];\n                    sector.innerRadius = seriesConfig.innerRadius;\n                    sector.radius = seriesConfig.radius;\n                }\n\n                if (seriesIndex === seriesCount - 1 && segment.explode) {\n                    sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n                }\n\n                segment.reflow(newBox);\n\n                var label = segment.label;\n                if (label) {\n                    if (label.options.position === OUTSIDE_END) {\n                        if (seriesIndex === seriesCount - 1) {\n                            if (label.orientation === RIGHT) {\n                                rightSideLabels.push(label);\n                            } else {\n                                leftSideLabels.push(label);\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (leftSideLabels.length > 0) {\n                leftSideLabels.sort(this.labelComparator(true));\n                this.leftLabelsReflow(leftSideLabels);\n            }\n\n            if (rightSideLabels.length > 0) {\n                rightSideLabels.sort(this.labelComparator(false));\n                this.rightLabelsReflow(rightSideLabels);\n            }\n\n            this.box = newBox;\n        },\n\n        leftLabelsReflow: function(labels) {\n            var distances = this.distanceBetweenLabels(labels);\n\n            this.distributeLabels(distances, labels);\n        },\n\n        rightLabelsReflow: function(labels) {\n            var distances = this.distanceBetweenLabels(labels);\n\n            this.distributeLabels(distances, labels);\n        },\n\n        distanceBetweenLabels: function(labels) {\n            var segment = last(this.points);\n            var sector = segment.sector;\n            var count = labels.length - 1;\n            var lr = sector.radius + segment.options.labels.distance;\n            var distances = [];\n            var firstBox = labels[0].box;\n            var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n\n            distances.push(distance);\n\n            for (var i = 0; i < count; i++) {\n                var secondBox = labels[i + 1].box;\n\n                firstBox = labels[i].box;\n                distance = round(secondBox.y1 - firstBox.y2);\n                distances.push(distance);\n            }\n            distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n            distances.push(distance);\n\n            return distances;\n        },\n\n        distributeLabels: function(distances, labels) {\n            var this$1$1 = this;\n\n            var count = distances.length;\n            var left, right, remaining;\n\n            for (var i = 0; i < count; i++) {\n                remaining = -distances[i];\n                left = right = i;\n\n                while (remaining > 0 && (left >= 0 || right < count)) {\n                    remaining = this$1$1._takeDistance(distances, i, --left, remaining);\n                    remaining = this$1$1._takeDistance(distances, i, ++right, remaining);\n                }\n            }\n\n            this.reflowLabels(distances, labels);\n        },\n\n        _takeDistance: function(distances, anchor, position, amount) {\n            var result = amount;\n            if (distances[position] > 0) {\n                var available = Math.min(distances[position], result);\n                result -= available;\n                distances[position] -= available;\n                distances[anchor] += available;\n            }\n\n            return result;\n        },\n\n        reflowLabels: function(distances, labels) {\n            var this$1$1 = this;\n\n            var segment = last(this.points);\n            var sector = segment.sector;\n            var labelOptions = segment.options.labels;\n            var labelsCount = labels.length;\n            var labelDistance = labelOptions.distance;\n            var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n            var boxX;\n\n            distances[0] += 2;\n            for (var i = 0; i < labelsCount; i++) {\n                var label = labels[i];\n                var box = label.box;\n\n                boxY += distances[i];\n                boxX = this$1$1.hAlignLabel(\n                    box.x2,\n                    sector.clone().expand(labelDistance),\n                    boxY,\n                    boxY + box.height(),\n                    label.orientation === RIGHT);\n\n                if (label.orientation === RIGHT) {\n                    if (labelOptions.align !== CIRCLE) {\n                        boxX = sector.radius + sector.center.x + labelDistance;\n                    }\n                    label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n                } else {\n                    if (labelOptions.align !== CIRCLE) {\n                        boxX = sector.center.x - sector.radius - labelDistance;\n                    }\n                    label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n                }\n\n                boxY += box.height();\n            }\n        },\n\n        createVisual: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var connectors = ref.options.connectors;\n            var points = ref.points;\n            var count = points.length;\n            var space = 4;\n\n            ChartElement.fn.createVisual.call(this);\n\n            this._connectorLines = [];\n\n            for (var i = 0; i < count; i++) {\n                var segment = points[i];\n                var sector = segment.sector;\n                var label = segment.label;\n                var angle = sector.middle();\n                var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n                if (label) {\n                    var connectorLine = new Path({\n                        stroke: {\n                            color: connectorsColor,\n                            width: connectors.width\n                        },\n                        animation: {\n                            type: FADEIN,\n                            delay: segment.animationDelay\n                        }\n                    });\n\n                    if (label.options.position === OUTSIDE_END) {\n                        var box = label.box;\n                        var centerPoint = sector.center;\n                        var start = sector.point(angle);\n                        var middle = new Point(box.x1, box.center().y);\n                        var sr = (void 0), end = (void 0), crossing = (void 0);\n\n                        start = sector.clone().expand(connectors.padding).point(angle);\n                        connectorLine.moveTo(start.x, start.y);\n                        // TODO: Extract into a method to remove duplication\n                        if (label.orientation === RIGHT) {\n                            end = new Point(box.x1 - connectors.padding, box.center().y);\n                            crossing = intersection(centerPoint, start, middle, end);\n                            middle = new Point(end.x - space, end.y);\n                            crossing = crossing || middle;\n                            crossing.x = Math.min(crossing.x, middle.x);\n\n                            if (this$1$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                                crossing.x < sector.center.x) {\n                                sr = sector.center.x + sector.radius + space;\n                                if (segment.options.labels.align !== COLUMN) {\n                                    if (sr < middle.x) {\n                                        connectorLine.lineTo(sr, start.y);\n                                    } else {\n                                        connectorLine.lineTo(start.x + space * 2, start.y);\n                                    }\n                                } else {\n                                    connectorLine.lineTo(sr, start.y);\n                                }\n                                connectorLine.lineTo(middle.x, end.y);\n                            } else {\n                                crossing.y = end.y;\n                                connectorLine.lineTo(crossing.x, crossing.y);\n                            }\n                        } else {\n                            end = new Point(box.x2 + connectors.padding, box.center().y);\n                            crossing = intersection(centerPoint, start, middle, end);\n                            middle = new Point(end.x + space, end.y);\n                            crossing = crossing || middle;\n                            crossing.x = Math.max(crossing.x, middle.x);\n\n                            if (this$1$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                                crossing.x > sector.center.x) {\n                                sr = sector.center.x - sector.radius - space;\n                                if (segment.options.labels.align !== COLUMN) {\n                                    if (sr > middle.x) {\n                                        connectorLine.lineTo(sr, start.y);\n                                    } else {\n                                        connectorLine.lineTo(start.x - space * 2, start.y);\n                                    }\n                                } else {\n                                    connectorLine.lineTo(sr, start.y);\n                                }\n                                connectorLine.lineTo(middle.x, end.y);\n                            } else {\n                                crossing.y = end.y;\n                                connectorLine.lineTo(crossing.x, crossing.y);\n                            }\n                        }\n\n                        connectorLine.lineTo(end.x, end.y);\n\n                        this$1$1._connectorLines.push(connectorLine);\n                        this$1$1.visual.append(connectorLine);\n                    }\n                }\n            }\n        },\n\n        renderVisual: function() {\n            ChartElement.fn.renderVisual.call(this);\n\n            if (dataviz.find(this.options.series, function (options) { return options.autoFit; })) {\n                var targetBox = this.targetBox;\n                var pieCenter = this.box.center();\n                var bbox = this.visual.bbox();\n                if (!bbox) {\n                    return;\n                }\n\n                var bboxBottom = bbox.bottomRight();\n\n                var scale = Math.min(\n                    (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),\n                    (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),\n                    (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),\n                    (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)\n                );\n\n                if (scale < 1) {\n                    this.visual.transform(transform().scale(scale, scale, [ pieCenter.x, pieCenter.y ]));\n                }\n            }\n        },\n\n        labelComparator: function(reverse) {\n            var reverseValue = reverse ? -1 : 1;\n\n            return function(a, b) {\n                var first = (a.parent.sector.middle() + 270) % 360;\n                var second = (b.parent.sector.middle() + 270) % 360;\n                return (first - second) * reverseValue;\n            };\n        },\n\n        hAlignLabel: function(originalX, sector, y1, y2, direction) {\n            var radius = sector.radius;\n            var sector_center = sector.center;\n            var cx = sector_center.x;\n            var cy = sector_center.y;\n            var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n            if (t > radius) {\n                return originalX;\n            }\n\n            return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\n        },\n\n        pointInCircle: function(point, center, radius) {\n            return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n        },\n\n        formatPointValue: function(point, format) {\n            return this.chartService.format.auto(format, point.value);\n        },\n\n        animationDelay: function(categoryIndex) {\n            return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n        },\n\n        stackRoot: function() {\n            return this;\n        }\n    });\n\n    function intersection(a1, a2, b1, b2) {\n        var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n        var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n        var result;\n        if (ub !== 0) {\n            var ua = (uat / ub);\n\n            result = new Point(\n                a1.x + ua * (a2.x - a1.x),\n                a1.y + ua * (a2.y - a1.y)\n            );\n        }\n\n        return result;\n    }\n\n    setDefaultOptions(PieChart, {\n        startAngle: 90,\n        connectors: {\n            width: 2,\n            color: \"#939393\",\n            padding: 8\n        },\n        inactiveItems: {\n            markers: {},\n            labels: {}\n        }\n    });\n\n    deepExtend(PieChart.prototype, PieChartMixin);\n\n    PieChart.prototype.isStackRoot = true;\n\n    var PiePlotArea = PlotAreaBase.extend({\n        render: function() {\n            this.createPieChart(this.series);\n        },\n\n        createPieChart: function(series) {\n            var firstSeries = series[0];\n            var pieChart = new PieChart(this, {\n                series: series,\n                padding: firstSeries.padding,\n                startAngle: firstSeries.startAngle,\n                connectors: firstSeries.connectors,\n                legend: this.options.legend\n            });\n\n            this.appendChart(pieChart);\n        },\n\n        appendChart: function(chart, pane) {\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n            append(this.options.legend.data, chart.legendItems);\n        },\n\n        getPointBelow: function(point) {\n            return this.getPointToTheRight(point);\n        },\n\n        getPointAbove: function(point) {\n            return this.getPointToTheLeft(point);\n        }\n    });\n\n    var DonutSegment = PieSegment.extend({\n        reflowLabel: function() {\n            var ref = this;\n            var labelsOptions = ref.options.labels;\n            var label = ref.label;\n            var sector = this.sector.clone();\n            var angle = sector.middle();\n\n            if (label) {\n                var labelHeight = label.box.height();\n                if (labelsOptions.position === CENTER) {\n                    sector.radius -= (sector.radius - sector.innerRadius) / 2;\n\n                    var lp = sector.point(angle);\n\n                    label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\n                } else {\n                    PieSegment.fn.reflowLabel.call(this);\n                }\n            }\n        },\n\n        createSegment: function(sector, options) {\n            return dataviz.ShapeBuilder.current.createRing(sector, options);\n        }\n    });\n\n    setDefaultOptions(DonutSegment, {\n        overlay: {\n            gradient: \"roundedGlass\"\n        },\n        labels: {\n            position: CENTER\n        },\n        animation: {\n            type: PIE\n        }\n    });\n\n    deepExtend(DonutSegment.prototype, PointEventsMixin);\n\n    var DONUT_SECTOR_ANIM_DELAY = 50;\n\n    var DonutChart = PieChart.extend({\n        addValue: function(value, sector, fields) {\n            var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n            this.evalSegmentOptions(segmentOptions, value, fields);\n\n            this.createLegendItem(value, segmentOptions, fields);\n\n            if (fields.visible === false) {\n                return;\n            }\n\n            var segment = new DonutSegment(value, sector, segmentOptions);\n\n            $.extend(segment, fields);\n            this.append(segment);\n            this.points.push(segment);\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var box = targetBox.clone();\n            var space = 5;\n            var minWidth = Math.min(box.width(), box.height());\n            var halfMinWidth = minWidth / 2;\n            var defaultPadding = minWidth - minWidth * 0.85;\n            var series = options.series;\n            var seriesCount = series.length;\n\n            var padding = valueOrDefault(options.padding, defaultPadding);\n            padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n\n            var totalSize = halfMinWidth - padding;\n            var seriesWithoutSize = 0;\n            var holeSize;\n\n            for (var i = 0; i < seriesCount; i++) {\n                var currentSeries = series[i];\n                if (i === 0) {\n                    if (defined(currentSeries.holeSize)) {\n                        holeSize = currentSeries.holeSize;\n                        totalSize -= currentSeries.holeSize;\n                    }\n                }\n\n                if (defined(currentSeries.size)) {\n                    totalSize -= currentSeries.size;\n                } else {\n                    seriesWithoutSize++;\n                }\n\n                if (defined(currentSeries.margin) && i !== seriesCount - 1) {\n                    totalSize -= currentSeries.margin;\n                }\n            }\n\n            if (!defined(holeSize)) {\n                var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);\n                holeSize = currentSize * 0.75;\n                totalSize -= holeSize;\n            }\n\n            var innerRadius = holeSize;\n            var margin = 0;\n            var size, radius;\n\n            this.seriesConfigs = [];\n\n            for (var i$1 = 0; i$1 < seriesCount; i$1++) {\n                var currentSeries$1 = series[i$1];\n                size = valueOrDefault(currentSeries$1.size, totalSize / seriesWithoutSize);\n                innerRadius += margin;\n                radius = innerRadius + size;\n                this$1$1.seriesConfigs.push({ innerRadius: innerRadius, radius: radius });\n                margin = currentSeries$1.margin || 0;\n                innerRadius = radius;\n            }\n\n            PieChart.fn.reflow.call(this, targetBox);\n        },\n\n        animationDelay: function(categoryIndex, seriesIndex, seriesCount) {\n            return categoryIndex * DONUT_SECTOR_ANIM_DELAY +\n                (INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1));\n        }\n    });\n\n    setDefaultOptions(DonutChart, {\n        startAngle: 90,\n        connectors: {\n            width: 2,\n            color: \"#939393\",\n            padding: 8\n        }\n    });\n\n    var DonutPlotArea = PiePlotArea.extend({\n        render: function() {\n            this.createDonutChart(this.series);\n        },\n\n        createDonutChart: function(series) {\n            var firstSeries = series[0];\n            var donutChart = new DonutChart(this, {\n                series: series,\n                padding: firstSeries.padding,\n                connectors: firstSeries.connectors,\n                legend: this.options.legend\n            });\n\n            this.appendChart(donutChart);\n        },\n\n        getPointBelow: function(point) {\n            return this._getNextPoint(point, this._pointsByVertical, -1);\n        },\n\n        getPointAbove: function(point) {\n            return this._getNextPoint(point, this._pointsByVertical, 1);\n        }\n    });\n\n    var DEFAULT_PADDING = 0.15;\n\n    var PolarPlotAreaBase = PlotAreaBase.extend({\n        initFields: function() {\n            this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n        },\n\n        render: function() {\n            this.addToLegend(this.series);\n            this.createPolarAxis();\n            this.createCharts();\n            this.createValueAxis();\n        },\n\n        alignAxes: function() {\n            var axis = this.valueAxis;\n            var range = axis.range();\n            var crossingValue = axis.options.reverse ? range.max : range.min;\n            var slot = axis.getSlot(crossingValue);\n            var center = this.polarAxis.getSlot(0).center;\n            var axisBox = axis.box.translate(\n                center.x - slot.x1,\n                center.y - slot.y1\n            );\n\n            axis.reflow(axisBox);\n        },\n\n        createValueAxis: function() {\n            var tracker = this.valueAxisRangeTracker;\n            var defaultRange = tracker.query();\n            var axisOptions = this.valueAxisOptions({\n                roundToMajorUnit: false,\n                zIndex: -1\n            });\n            var axisType, axisDefaultRange;\n\n            if (axisOptions.type === LOGARITHMIC) {\n                axisType = dataviz.RadarLogarithmicAxis;\n                axisDefaultRange = { min: 0.1, max: 1 };\n            } else {\n                axisType = dataviz.RadarNumericAxis;\n                axisDefaultRange = { min: 0, max: 1 };\n            }\n\n            var range = tracker.query(name) || defaultRange || axisDefaultRange;\n\n            if (range && defaultRange) {\n                range.min = Math.min(range.min, defaultRange.min);\n                range.max = Math.max(range.max, defaultRange.max);\n            }\n\n            var valueAxis = new axisType(\n                range.min, range.max,\n                axisOptions,\n                this.chartService\n            );\n\n            this.valueAxis = valueAxis;\n            this.appendAxis(valueAxis);\n        },\n\n        reflowAxes: function() {\n            var ref = this;\n            var options = ref.options.plotArea;\n            var valueAxis = ref.valueAxis;\n            var polarAxis = ref.polarAxis;\n            var box = ref.box;\n            var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;\n            var padding = getSpacing(options.padding || {}, defaultPadding);\n            var paddingBox = box.clone().unpad(padding);\n            var axisBox = paddingBox.clone();\n\n            axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());\n            axisBox.align(paddingBox, Y, CENTER);\n\n            var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);\n\n            polarAxis.reflow(axisBox);\n            valueAxis.reflow(valueAxisBox);\n            var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();\n            valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));\n\n            this.axisBox = axisBox;\n            this.alignAxes(axisBox);\n        },\n\n        backgroundBox: function() {\n            return this.box;\n        },\n\n        detachLabels: function() {}\n    });\n\n    var PolarScatterChart = ScatterChart.extend({\n        pointSlot: function(slotX, slotY) {\n            var valueRadius = slotX.center.y - slotY.y1;\n            var slot = Point.onCircle(slotX.center, slotX.startAngle, valueRadius);\n\n            return new Box(slot.x, slot.y, slot.x, slot.y);\n        }\n    });\n\n    setDefaultOptions(PolarScatterChart, {\n        clip: false\n    });\n\n    var PolarLineChart = ScatterLineChart.extend({\n\n    });\n\n    PolarLineChart.prototype.pointSlot = PolarScatterChart.prototype.pointSlot;\n\n    setDefaultOptions(PolarLineChart, {\n        clip: false\n    });\n\n    var SplinePolarAreaSegment = SplineAreaSegment.extend({\n        fillToAxes: function(fillPath) {\n            var center = this._polarAxisCenter();\n            fillPath.lineTo(center.x, center.y);\n        },\n\n        _polarAxisCenter: function() {\n            var polarAxis = this.parent.plotArea.polarAxis;\n            var center = polarAxis.box.center();\n            return center;\n        },\n\n        strokeSegments: function() {\n            var segments = this._strokeSegments;\n\n            if (!segments) {\n                var center = this._polarAxisCenter();\n                var curveProcessor = new CurveProcessor(false);\n                var linePoints = this.points();\n\n                linePoints.push(center);\n                segments = this._strokeSegments = curveProcessor.process(linePoints);\n                segments.pop();\n            }\n\n            return segments;\n        }\n    });\n\n    var PolarAreaSegment = AreaSegment.extend({\n        fillToAxes: function(fillPath) {\n            var polarAxis = this.parent.plotArea.polarAxis;\n            var center = polarAxis.box.center();\n            var centerSegment = new geometry.Segment([ center.x, center.y ]);\n\n            fillPath.segments.unshift(centerSegment);\n            fillPath.segments.push(centerSegment);\n        }\n    });\n\n    var PolarAreaChart = PolarLineChart.extend({\n        createSegment: function(linePoints, currentSeries, seriesIx) {\n            var style = (currentSeries.line || {}).style;\n            var segment;\n\n            if (style === SMOOTH) {\n                segment = new SplinePolarAreaSegment(linePoints, currentSeries, seriesIx);\n            } else {\n                segment = new PolarAreaSegment(linePoints, currentSeries, seriesIx);\n            }\n            return segment;\n        },\n\n        createMissingValue: function(value, missingValues) {\n            var missingValue;\n\n            if (hasValue(value.x) && missingValues !== INTERPOLATE) {\n                missingValue = {\n                    x: value.x,\n                    y: value.y\n                };\n                if (missingValues === ZERO) {\n                    missingValue.y = 0;\n                }\n            }\n\n            return missingValue;\n        },\n\n        seriesMissingValues: function(series) {\n            return series.missingValues || ZERO;\n        },\n\n        _hasMissingValuesGap: function() {\n            var this$1$1 = this;\n\n            var series = this.options.series;\n\n            for (var idx = 0; idx < series.length; idx++) {\n                if (this$1$1.seriesMissingValues(series[idx]) === GAP) {\n                    return true;\n                }\n            }\n        },\n\n        sortPoints: function(points) {\n            var this$1$1 = this;\n\n            points.sort(xComparer);\n\n            if (this._hasMissingValuesGap()) {\n                for (var idx = 0; idx < points.length; idx++) {\n                    var point = points[idx];\n                    if (point) {\n                        var value = point.value;\n                        if (!hasValue(value.y) && this$1$1.seriesMissingValues(point.series) === GAP) {\n                            delete points[idx];\n                        }\n                    }\n                }\n            }\n\n            return points;\n        }\n    });\n\n    function xComparer(a, b) {\n        return a.value.x - b.value.x;\n    }\n\n    var PolarPlotArea = PolarPlotAreaBase.extend({\n        createPolarAxis: function() {\n            var polarAxis = new dataviz.PolarAxis(this.options.xAxis, this.chartService);\n\n            this.polarAxis = polarAxis;\n            this.axisX = polarAxis;\n            this.appendAxis(polarAxis);\n        },\n\n        render: function() {\n            this.series = [].concat( this.originalSeries );\n            this.createTrendlineSeries();\n\n            PolarPlotAreaBase.fn.render.call(this);\n        },\n\n        valueAxisOptions: function(defaults) {\n            return deepExtend(defaults, {\n                majorGridLines: { type: ARC },\n                minorGridLines: { type: ARC }\n            }, this.options.yAxis);\n        },\n\n        createValueAxis: function() {\n            PolarPlotAreaBase.fn.createValueAxis.call(this);\n            this.axisY = this.valueAxis;\n        },\n\n        trendlineFactory: function(options, series) {\n            var trendline = XYPlotArea.prototype.trendlineFactory.call(this, options, series);\n            if (trendline) {\n                trendline.type = POLAR_LINE;\n            }\n\n            return trendline;\n        },\n\n        appendChart: function(chart, pane) {\n            this.valueAxisRangeTracker.update(chart.yAxisRanges);\n\n            PlotAreaBase.prototype.appendChart.call(this, chart, pane);\n        },\n\n        createCharts: function() {\n            var series = this.filterVisibleSeries(this.series);\n            var pane = this.panes[0];\n\n            this.createLineChart(\n                filterSeriesByType(series, [ POLAR_LINE ]),\n                pane\n            );\n\n            this.createScatterChart(\n                filterSeriesByType(series, [ POLAR_SCATTER ]),\n                pane\n            );\n\n            this.createAreaChart(\n                filterSeriesByType(series, [ POLAR_AREA ]),\n                pane\n            );\n        },\n\n        createLineChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var lineChart = new PolarLineChart(this, { series: series });\n\n            this.appendChart(lineChart, pane);\n        },\n\n        createScatterChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var scatterChart = new PolarScatterChart(this, { series: series });\n\n            this.appendChart(scatterChart, pane);\n        },\n\n        createAreaChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var areaChart = new PolarAreaChart(this, { series: series });\n\n            this.appendChart(areaChart, pane);\n        },\n\n        _dispatchEvent: function(chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n            var point = new Point(coords.x, coords.y);\n            var xValue = this.axisX.getValue(point);\n            var yValue = this.axisY.getValue(point);\n\n            if (xValue !== null && yValue !== null) {\n                chart.trigger(eventType, {\n                    element: eventElement(e),\n                    x: xValue,\n                    y: yValue\n                });\n            }\n        },\n\n        createCrosshairs: function() {}\n    });\n\n    setDefaultOptions(PolarPlotArea, {\n        xAxis: {},\n        yAxis: {}\n    });\n\n    deepExtend(PolarPlotArea.prototype, PlotAreaEventsMixin, {\n        seriesValues: XYPlotArea.prototype.seriesValues\n    });\n\n    function groupBySeriesIx(segments) {\n        var seriesSegments = [];\n        for (var idx = 0; idx < segments.length; idx++) {\n            var segment = segments[idx];\n            seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];\n            seriesSegments[segment.seriesIx].push(segment);\n        }\n\n        return seriesSegments;\n    }\n\n    var RadarLineChart = LineChart.extend({\n        pointSlot: function(categorySlot, valueSlot) {\n            var valueRadius = categorySlot.center.y - valueSlot.y1;\n            var slot = Point.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);\n\n            return new Box(slot.x, slot.y, slot.x, slot.y);\n        },\n\n        renderSegments: function() {\n            LineChart.fn.renderSegments.call(this);\n\n            if (this._segments && this._segments.length > 1) {\n                var seriesSegments = groupBySeriesIx(this._segments);\n\n                for (var idx = 0; idx < seriesSegments.length; idx++) {\n                    var segments = seriesSegments[idx];\n                    if (segments && segments.length > 1) {\n                        var firstPoint = segments[0].linePoints[0];\n                        var lastSegment = last(segments);\n                        var lastPoint = last(lastSegment.linePoints);\n                        var isFirstDataPoint = firstPoint.categoryIx === 0;\n                        var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;\n                        if (isFirstDataPoint && isLastDataPoint) {\n                            last(segments).linePoints.push(firstPoint);\n                        }\n                    }\n                }\n            }\n        },\n\n        createSegment: function(linePoints, currentSeries, seriesIx) {\n            var style = currentSeries.style;\n            var pointType;\n\n            if (style === SMOOTH) {\n                pointType = SplineSegment;\n            } else {\n                pointType = LineSegment;\n            }\n\n            var segment = new pointType(linePoints, currentSeries, seriesIx);\n            var missingValues = this.seriesMissingValues(currentSeries);\n\n            if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {\n                segment.options.closed = true;\n            }\n\n            return segment;\n        }\n    });\n\n    setDefaultOptions(RadarLineChart, {\n        clip: false,\n        limitPoints: false\n    });\n\n    var SplineRadarAreaSegment = SplineAreaSegment.extend({\n        fillToAxes: function() {}\n    });\n\n    var RadarAreaSegment = AreaSegment.extend({\n        fillToAxes: function() {}\n    });\n\n    var RadarAreaChart = RadarLineChart.extend({\n        createSegment: function(linePoints, currentSeries, seriesIx, prevSegment) {\n            var isStacked = this.options.isStacked;\n            var style = (currentSeries.line || {}).style;\n            var previousSegment;\n            var stackPoints;\n            var segment;\n\n            if (isStacked && seriesIx > 0 && prevSegment) {\n                stackPoints = prevSegment.linePoints.slice(0);\n                previousSegment = prevSegment;\n            }\n\n            if (style === SMOOTH) {\n                segment = new SplineRadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n                segment.options.closed = true;\n            } else {\n                linePoints.push(linePoints[0]);\n                segment = new RadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n            }\n\n            return segment;\n        },\n\n        seriesMissingValues: function(series) {\n            return series.missingValues || ZERO;\n        }\n    });\n\n    var RadarSegment = DonutSegment.extend({\n        init: function(value, options) {\n            DonutSegment.fn.init.call(this, value, null, options);\n        },\n\n        getIndex: function() {\n            return this.categoryIx;\n        }\n    });\n\n    setDefaultOptions(RadarSegment, {\n        overlay: {\n            gradient: \"none\"\n        },\n        labels: {\n            distance: 10\n        }\n    });\n\n    var RadarClusterLayout = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.forEach = options.rtl ? forEachReverse : forEach;\n        },\n\n        reflow: function(sector) {\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var gap = options.gap;\n            var spacing = options.spacing;\n            var count = children.length;\n            var slots = count + gap + (spacing * (count - 1));\n            var slotAngle = sector.angle / slots;\n            var angle = sector.startAngle + slotAngle * (gap / 2);\n\n            this.forEach(children, function (child) {\n                var slotSector = sector.clone();\n                slotSector.startAngle = angle;\n                slotSector.angle = slotAngle;\n\n                if (child.sector) {\n                    slotSector.radius = child.sector.radius;\n                }\n\n                child.reflow(slotSector);\n                child.sector = slotSector;\n\n                angle += slotAngle + (slotAngle * spacing);\n            });\n        }\n    });\n\n    setDefaultOptions(RadarClusterLayout, {\n        gap: 1,\n        spacing: 0\n    });\n\n    var RadarStackLayout = ChartElement.extend({\n        reflow: function(sector) {\n            var ref = this;\n            var reverse = ref.options.reverse;\n            var children = ref.children;\n            var childrenCount = children.length;\n            var first = reverse ? childrenCount - 1 : 0;\n            var step = reverse ? -1 : 1;\n\n            this.box = new Box();\n\n            for (var i = first; i >= 0 && i < childrenCount; i += step) {\n                var childSector = children[i].sector;\n                childSector.startAngle = sector.startAngle;\n                childSector.angle = sector.angle;\n            }\n        }\n    });\n\n    var RadarBarChart = BarChart.extend({\n        pointType: function() {\n            return RadarSegment;\n        },\n\n        clusterType: function() {\n            return RadarClusterLayout;\n        },\n\n        stackType: function() {\n            return RadarStackLayout;\n        },\n\n        categorySlot: function(categoryAxis, categoryIx) {\n            return categoryAxis.getSlot(categoryIx);\n        },\n\n        pointSlot: function(categorySlot, valueSlot) {\n            var slot = categorySlot.clone();\n            var y = categorySlot.center.y;\n\n            slot.radius = y - valueSlot.y1;\n            slot.innerRadius = y - valueSlot.y2;\n\n            return slot;\n        },\n\n        reflowPoint: function(point, pointSlot) {\n            point.sector = pointSlot;\n            point.reflow();\n        },\n\n        createAnimation: function() {\n            this.options.animation.center = this.box.toRect().center();\n            BarChart.fn.createAnimation.call(this);\n        }\n    });\n\n    RadarBarChart.prototype.reflow = CategoricalChart.prototype.reflow;\n\n    setDefaultOptions(RadarBarChart, {\n        clip: false,\n        limitPoints: false,\n        animation: {\n            type: \"pie\"\n        }\n    });\n\n    var RadarPlotArea = PolarPlotAreaBase.extend({\n        createPolarAxis: function() {\n            var categoryAxis = new dataviz.RadarCategoryAxis(this.options.categoryAxis, this.chartService);\n\n            this.polarAxis = categoryAxis;\n            this.categoryAxis = categoryAxis;\n            this.appendAxis(categoryAxis);\n            this.aggregateCategories();\n            this.createTrendlineSeries();\n            this.createCategoryAxesLabels();\n        },\n\n        valueAxisOptions: function(defaults) {\n            if (this._hasBarCharts) {\n                deepExtend(defaults, {\n                    majorGridLines: { type: ARC },\n                    minorGridLines: { type: ARC }\n                });\n            }\n\n            if (this._isStacked100) {\n                deepExtend(defaults, {\n                    roundToMajorUnit: false,\n                    labels: { format: \"P0\" }\n                });\n            }\n\n            return deepExtend(defaults, this.options.valueAxis);\n        },\n\n        aggregateCategories: function() {\n            // No separate panes in radar charts\n            CategoricalPlotArea.prototype.aggregateCategories.call(this, this.panes);\n        },\n\n        createCategoryAxesLabels: function() {\n            CategoricalPlotArea.prototype.createCategoryAxesLabels.call(this, this.panes);\n        },\n\n        filterSeries: function(currentSeries) {\n            // Not supported for radar charts\n            return currentSeries;\n        },\n\n        trendlineFactory: function(options, series) {\n            var trendline = CategoricalPlotArea.prototype.trendlineFactory.call(this, options, series);\n            if (trendline) {\n                trendline.type = RADAR_LINE;\n            }\n\n            return trendline;\n        },\n\n        createCharts: function() {\n            var series = this.filterVisibleSeries(this.series);\n            var pane = this.panes[0];\n\n            this.createAreaChart(\n                filterSeriesByType(series, [ RADAR_AREA ]),\n                pane\n            );\n\n            this.createLineChart(\n                filterSeriesByType(series, [ RADAR_LINE ]),\n                pane\n            );\n\n            this.createBarChart(\n                filterSeriesByType(series, [ RADAR_COLUMN ]),\n                pane\n            );\n        },\n\n        chartOptions: function(series) {\n            var options = { series: series };\n            var firstSeries = series[0];\n            if (firstSeries) {\n                var filteredSeries = this.filterVisibleSeries(series);\n                var stack = firstSeries.stack;\n                options.isStacked = stack && filteredSeries.length > 1;\n                options.isStacked100 = stack && stack.type === \"100%\" && filteredSeries.length > 1;\n\n                if (options.isStacked100) {\n                    this._isStacked100 = true;\n                }\n            }\n\n            return options;\n        },\n\n        createAreaChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var areaChart = new RadarAreaChart(this, this.chartOptions(series));\n            this.appendChart(areaChart, pane);\n        },\n\n        createLineChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var lineChart = new RadarLineChart(this, this.chartOptions(series));\n            this.appendChart(lineChart, pane);\n        },\n\n        createBarChart: function(series, pane) {\n            if (series.length === 0) {\n                return;\n            }\n\n            var firstSeries = series[0];\n            var options = this.chartOptions(series);\n            var filteredSeries = this.filterVisibleSeries(series);\n            var anyStackedSeries = filteredSeries.some(function (s) { return s.stack; });\n            var isStacked100 = filteredSeries.some(function (s) { return s.stack && s.stack.type === \"100%\"; });\n            options.gap = firstSeries.gap;\n            options.spacing = firstSeries.spacing;\n            options.defaultStack = firstSeries.stack && filteredSeries.length > 1;\n            options.isStacked = anyStackedSeries && filteredSeries.length > 1;\n            options.isStacked100 = isStacked100 && filteredSeries.length > 1;\n\n            var barChart = new RadarBarChart(this, options);\n            this.appendChart(barChart, pane);\n\n            this._hasBarCharts = true;\n        },\n\n        seriesCategoryAxis: function() {\n            return this.categoryAxis;\n        },\n\n        _dispatchEvent: function(chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n            var point = new Point(coords.x, coords.y);\n            var category = this.categoryAxis.getCategory(point);\n            var value = this.valueAxis.getValue(point);\n\n            if (category !== null && value !== null) {\n                chart.trigger(eventType, {\n                    element: eventElement(e),\n                    category: category,\n                    value: value\n                });\n            }\n        },\n\n        createCrosshairs: function() {},\n\n        _pointsByVertical: function(basePoint) {\n            return PolarPlotAreaBase.fn._pointsByVertical.call(this, basePoint).sort(this._getSeriesCompareFn());\n        },\n\n        _getSeriesCompareFn: function() {\n            return function (a, b) { return b.value - a.value; };\n        }\n    });\n\n    deepExtend(RadarPlotArea.prototype, PlotAreaEventsMixin, {\n        appendChart: CategoricalPlotArea.prototype.appendChart,\n        aggregateSeries: CategoricalPlotArea.prototype.aggregateSeries,\n        seriesSourcePoints: CategoricalPlotArea.prototype.seriesSourcePoints,\n        seriesValues: CategoricalPlotArea.prototype.seriesValues\n    });\n\n    setDefaultOptions(RadarPlotArea, {\n        categoryAxis: {\n            categories: []\n        },\n        valueAxis: {}\n    });\n\n    var FunnelSegment = ChartElement.extend({\n        init: function(value, options, segmentOptions) {\n            ChartElement.fn.init.call(this, options);\n\n            this.value = value;\n            this.options.index = segmentOptions.index;\n        },\n\n        getLabelText: function(options) {\n            var labelTemplate = getTemplate(options);\n\n            if (labelTemplate) {\n                return labelTemplate(this.pointData());\n            } else if (options.format) {\n                return this.formatValue(options.format);\n            }\n\n            return this.value;\n        },\n\n        reflow: function(chartBox) {\n            var points = this.points;\n            var label = this.children[0];\n            var x1 = Math.min(points[0].x, points[3].x);\n            var x2 = Math.max(points[1].x, points[2].x);\n\n            this.box = new Box(x1, points[0].y, x2, points[2].y);\n\n            if (label) {\n                label.reflow(new Box(chartBox.x1, points[0].y, chartBox.x2, points[2].y));\n            }\n        },\n\n        createVisual: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var visual;\n\n            ChartElement.fn.createVisual.call(this);\n\n            this.addAccessibilityAttributesToVisual();\n\n            if (options.visual) {\n                visual = options.visual({\n                    category: this.category,\n                    dataItem: this.dataItem,\n                    value: this.value,\n                    series: this.series,\n                    percentage: this.percentage,\n                    points: this.points,\n                    options: options,\n                    sender: this.getSender(),\n                    createVisual: function () { return this$1$1.createPath(); }\n                });\n            } else {\n                visual = this.createPath();\n            }\n\n            if (visual) {\n                this.visual.append(visual);\n            }\n        },\n\n        createPath: function() {\n            var options = this.options;\n            var border = options.border;\n            var path = Path.fromPoints(this.points, {\n                fill: {\n                    color: options.color,\n                    opacity: options.opacity\n                },\n                stroke: {\n                    color: border.color,\n                    opacity: border.opacity,\n                    width: border.width\n                }\n            }).close();\n\n            return path;\n        },\n\n        createHighlight: function(style) {\n            return Path.fromPoints(this.points, style);\n        },\n\n        highlightVisual: function() {\n            return this.visual.children[0];\n        },\n\n        highlightVisualArgs: function() {\n            var path = Path.fromPoints(this.points).close();\n\n            return {\n                options: this.options,\n                path: path\n            };\n        },\n\n        createFocusHighlight: function(style) {\n            var borderWidth = this.options.accessibility.highlight.border.width;\n            var result = Path.fromPoints(this.points, deepExtend({}, style, {\n                stroke: {\n                    width: borderWidth * 2\n                }\n            })).close();\n\n            var clipPath = new MultiPath();\n\n            clipPath.paths.push(Path.fromRect(this.box.clone().pad(borderWidth).toRect()));\n            clipPath.paths.push(Path.fromPoints(this.points));\n\n            result.clip(clipPath);\n\n            return result;\n        },\n\n        tooltipAnchor: function() {\n            var box = this.box;\n            return {\n                point: new Point(box.center().x, box.y1),\n                align: {\n                    horizontal: \"center\",\n                    vertical: \"top\"\n                }\n            };\n        },\n\n        formatValue: function(format) {\n            var point = this;\n            return point.owner.formatPointValue(point, format);\n        },\n\n        pointData: function() {\n            return {\n                dataItem: this.dataItem,\n                category: this.category,\n                value: this.value,\n                series: this.series,\n                percentage: this.percentage\n            };\n        },\n\n        getIndex: function() {\n            return this.index;\n        }\n    });\n\n    setDefaultOptions(FunnelSegment, {\n        color: WHITE,\n        border: {\n            width: 1\n        },\n        labels: {\n            format: \"\"\n        },\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    });\n\n    deepExtend(FunnelSegment.prototype, PointEventsMixin);\n    deepExtend(FunnelSegment.prototype, AccessibilityAttributesMixin);\n\n    var FunnelChart = ChartElement.extend({\n        init: function(plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this.points = [];\n            this.labels = [];\n            this.legendItems = [];\n            this.render();\n        },\n\n        formatPointValue: function(point, format) {\n            return this.plotArea.chartService.format.auto(format,point.value);\n        },\n\n        render: function() {\n            var this$1$1 = this;\n\n            var seriesIx = 0;\n            var ref = this;\n            var options = ref.options;\n            var seriesColors = ref.plotArea.options.seriesColors; if (seriesColors === void 0) { seriesColors = []; }\n            var series = options.series[seriesIx];\n            var data = series.data;\n\n            if (!data) {\n                return;\n            }\n\n            var ref$1 = bindSegments(series);\n            var total = ref$1.total;\n            var points = ref$1.points;\n\n            for (var i = 0; i < points.length; i++) {\n                var pointData = points[i];\n\n                if (!pointData) {\n                    continue;\n                }\n\n                var fields = pointData.fields;\n\n                if (!isFunction(series.color)) {\n                    series.color = fields.color || seriesColors[i % seriesColors.length];\n                }\n\n                fields = deepExtend({\n                    index: i,\n                    owner: this$1$1,\n                    series: series,\n                    seriesIx: seriesIx,\n                    dataItem: data[i],\n                    percentage: pointData.value / total\n                }, fields, { visible: pointData.visible });\n\n                var value = pointData.valueFields.value;\n                var segment = this$1$1.createSegment(value, fields);\n                var label = this$1$1.createLabel(value, fields);\n\n                if (segment && label) {\n                    segment.append(label);\n                }\n            }\n        },\n\n        evalSegmentOptions: function(options, value, fields) {\n            var series = fields.series;\n\n            evalOptions(options, {\n                value: value,\n                series: series,\n                dataItem: fields.dataItem,\n                index: fields.index\n            }, { defaults: series._defaults, excluded: [\n                \"data\", \"content\", \"template\", \"toggle\", \"visual\",\n                \"ariaTemplate\", \"ariaContent\"\n            ] });\n        },\n\n        createSegment: function(value, fields) {\n            var seriesOptions = deepExtend({}, fields.series);\n            this.evalSegmentOptions(seriesOptions, value, fields);\n\n            this.createLegendItem(value, seriesOptions, fields);\n\n            if (fields.visible !== false) {\n\n                var segment = new FunnelSegment(value, seriesOptions, fields);\n                $.extend(segment, fields);\n\n                this.append(segment);\n                this.points.push(segment);\n\n                return segment;\n            }\n        },\n\n        createLabel: function(value, fields) {\n            var series = fields.series;\n            var dataItem = fields.dataItem;\n            var labels = deepExtend({}, this.options.labels, series.labels);\n            var text = value;\n\n            if (labels.visible) {\n                var labelTemplate = getTemplate(labels);\n                var data = {\n                    dataItem: dataItem,\n                    value: value,\n                    percentage: fields.percentage,\n                    category: fields.category,\n                    series: series\n                };\n                if (labelTemplate) {\n                    text = labelTemplate(data);\n                } else if (labels.format) {\n                    text = this.chartService.format.auto(labels.format, text);\n                }\n\n                if (!labels.color) {\n                    labels.color = autoTextColor(series.color);\n                    if (!labels.background) {\n                        labels.background = series.color;\n                    }\n                }\n\n                this.evalSegmentOptions(labels, value, fields);\n                var textBox = new TextBox(text, deepExtend({\n                    vAlign: labels.position\n                }, labels), data);\n\n                this.labels.push(textBox);\n\n                return textBox;\n            }\n        },\n\n        labelPadding: function() {\n            var labels = this.labels;\n            var padding = { left: 0, right: 0 };\n\n            for (var i = 0; i < labels.length; i++) {\n                var label = labels[i];\n                var align = label.options.align;\n                if (align !== CENTER) {\n                    var width = labels[i].box.width();\n\n                    if (align === LEFT) {\n                        padding.left = Math.max(padding.left, width);\n                    } else {\n                        padding.right = Math.max(padding.right, width);\n                    }\n                }\n            }\n\n            return padding;\n        },\n\n        dynamicSlopeReflow: function(box, width, totalHeight) {\n            var ref = this;\n            var options = ref.options;\n            var segments = ref.points;\n            var count = segments.length;\n            var firstSegment = segments[0];\n            var maxSegment = firstSegment;\n\n            for (var idx = 0; idx < segments.length; idx++) {\n                if (segments[idx].percentage > maxSegment.percentage) {\n                    maxSegment = segments[idx];\n                }\n            }\n\n            var lastUpperSide = (firstSegment.percentage / maxSegment.percentage) * width;\n            var previousOffset = (width - lastUpperSide) / 2;\n            var previousHeight = 0;\n\n            for (var idx$1 = 0; idx$1 < count; idx$1++) {\n                var percentage = segments[idx$1].percentage;\n                var nextSegment = segments[idx$1 + 1];\n                var nextPercentage = (nextSegment ? nextSegment.percentage : percentage);\n                var points = segments[idx$1].points = [];\n                var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n                var offset = (void 0);\n\n                if (!percentage) {\n                    offset = nextPercentage ? 0 : width / 2;\n                } else {\n                    offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n                }\n\n                offset = limitValue(offset, 0, width);\n\n                points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\n                points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\n                points.push(new GeometryPoint(box.x1 + width - offset, box.y1 + height + previousHeight));\n                points.push(new GeometryPoint(box.x1 + offset, box.y1 + height + previousHeight));\n\n                previousOffset = offset;\n                previousHeight += height + options.segmentSpacing;\n                lastUpperSide = limitValue(width - 2 * offset, 0, width);\n            }\n        },\n\n        constantSlopeReflow: function(box, width, totalHeight) {\n            var ref = this;\n            var options = ref.options;\n            var segments = ref.points;\n            var count = segments.length;\n            var decreasingWidth = options.neckRatio <= 1;\n            var neckRatio = decreasingWidth ? options.neckRatio * width : width;\n            var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n            var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n            var finalNarrow = (topMostWidth - neckRatio) / 2;\n            var previousHeight = 0;\n\n            for (var idx = 0; idx < count; idx++) {\n                var points = segments[idx].points = [];\n                var percentage = segments[idx].percentage;\n                var offset = (options.dynamicHeight) ? (finalNarrow * percentage) : (finalNarrow / count);\n                var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n\n                points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\n                points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\n                points.push(new GeometryPoint(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n                points.push(new GeometryPoint(box.x1 + previousOffset + offset,box.y1 + height + previousHeight));\n                previousOffset += offset;\n                previousHeight += height + options.segmentSpacing;\n            }\n        },\n\n        reflow: function(chartBox) {\n            var points = this.points;\n            var count = points.length;\n\n            if (!count) {\n                return;\n            }\n\n            var options = this.options;\n            var box = chartBox.clone().unpad(this.labelPadding());\n            var totalHeight = box.height() - options.segmentSpacing * (count - 1);\n            var width = box.width();\n\n            if (options.dynamicSlope) {\n                this.dynamicSlopeReflow(box, width, totalHeight);\n            } else {\n                this.constantSlopeReflow(box, width, totalHeight);\n            }\n\n            for (var idx = 0; idx < count; idx++) {\n                points[idx].reflow(chartBox);\n            }\n        }\n    });\n\n    setDefaultOptions(FunnelChart, {\n        neckRatio: 0.3,\n        width: 300,\n        dynamicSlope: false,\n        dynamicHeight: true,\n        segmentSpacing: 0,\n        labels: {\n            visible: false,\n            align: CENTER,\n            position: CENTER,\n            zIndex: 1\n        }\n    });\n\n    deepExtend(FunnelChart.prototype, PieChartMixin);\n\n    var MAX_NECK_RATIO = 1e6;\n\n    var PyramidChart = FunnelChart.extend({\n        init: function(plotArea, options) {\n            options.dynamicSlope = false;\n            options.neckRatio = MAX_NECK_RATIO;\n\n            FunnelChart.fn.init.call(this, plotArea, options);\n        }\n    });\n\n    var FunnelPlotArea = PlotAreaBase.extend({\n        render: function() {\n            this.createChart(FunnelChart, filterSeriesByType(this.series, [ FUNNEL ]));\n            this.createChart(PyramidChart, filterSeriesByType(this.series, [ PYRAMID ]));\n        },\n\n        createChart: function(chartType, series) {\n            var firstSeries = series[0];\n            if (!firstSeries) {\n                return;\n            }\n\n            var chart = new chartType(this, {\n                series: series,\n                legend: this.options.legend,\n                neckRatio: firstSeries.neckRatio,\n                dynamicHeight: firstSeries.dynamicHeight,\n                dynamicSlope: firstSeries.dynamicSlope,\n                segmentSpacing: firstSeries.segmentSpacing,\n                highlight: firstSeries.highlight\n            });\n\n            this.appendChart(chart);\n        },\n\n        appendChart: function(chart, pane) {\n            PlotAreaBase.fn.appendChart.call(this, chart, pane);\n            append(this.options.legend.data, chart.legendItems);\n        },\n\n        _pointsByVertical: function(basePoint) {\n            return this.pointsBySeriesIndex(basePoint.series.index);\n        },\n\n        getPointToTheRight: function(point) {\n            return this.getPointBelow(point);\n        },\n\n        getPointToTheLeft: function(point) {\n            return this.getPointAbove(point);\n        }\n    });\n\n    // Linear color scale from the given color to white minus minimum lightness offset.\n    var colorScale = function (color, minLightnessOffset) {\n        if (minLightnessOffset === void 0) { minLightnessOffset = 0.05; }\n\n        var baseColor = kendo.parseColor(color);\n        var offset = 1 - minLightnessOffset;\n\n        return function (value) {\n            var hsl = baseColor.toHSL();\n            var range = 100 - hsl.l;\n            var point = offset - value;\n            hsl.l += Math.min(point * range, range);\n\n            return hsl.toCss();\n        };\n    };\n\n    var HeatmapPoint = ChartElement.extend({\n        init: function(value, options) {\n            ChartElement.fn.init.call(this);\n\n            this.options = options;\n            this.color = options.color || WHITE;\n            this.value = value;\n        },\n\n        render: function() {\n            if (this._rendered) {\n                return;\n            }\n\n            this._rendered = true;\n\n            this.createMarker();\n            this.createLabel();\n            this.createNote();\n        },\n\n        createLabel: function() {\n            var options = this.options;\n            var labels = options.labels;\n\n            if (labels.visible) {\n                this.label = this.createLabelElement(labels);\n                this.append(this.label);\n            }\n        },\n\n        createLabelElement: function(options) {\n            var labelColor = options.color;\n\n            if (!labelColor) {\n                labelColor = autoTextColor(this.color);\n            }\n\n            return new TextBox(this.getLabelText(options),\n                deepExtend({\n                    align: CENTER,\n                    vAlign: CENTER,\n                    margin: {\n                        left: 5,\n                        right: 5\n                    },\n                    zIndex: valueOrDefault(options.zIndex, this.series.zIndex)\n                },\n                options, {\n                    color: labelColor\n                }),\n                this.pointData()\n            );\n        },\n\n        getLabelText: function(options) {\n            var labelTemplate = getTemplate(options);\n\n            if (labelTemplate) {\n                return labelTemplate(this.pointData());\n            }\n\n            return this.formatValue(options.format);\n        },\n\n        formatValue: function(format) {\n            return this.owner.formatPointValue(this, format);\n        },\n\n        reflow: function(targetBox) {\n            this.render();\n\n            var label = this.label;\n\n            this.box = targetBox;\n\n            if (label) {\n                label.reflow(this.markerBox());\n            }\n\n            if (this.note) {\n                this.note.reflow(targetBox);\n            }\n\n            this.marker.reflow(this.markerBox());\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            this.addAccessibilityAttributesToVisual();\n        },\n\n        markerBox: function() {\n            var options = this.options;\n            var markers = options.markers;\n            var border = markers.border;\n            var rect = this.box.toRect();\n            var type = valueOrDefault(markers.type, 'rect');\n            var isRoundRect = type === datavizConstants.ROUNDED_RECT;\n            var borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);\n            var halfBorderWidth = Math.round(borderWidth / 2);\n\n            if (markers.size) {\n                var center = rect.center();\n                rect.size.width = rect.size.height = markers.size;\n                rect.origin.x = Math.round(center.x - rect.size.width / 2);\n                rect.origin.y = Math.round(center.y - rect.size.height / 2);\n            }\n\n            rect.size.width -= borderWidth;\n            rect.size.height -= borderWidth;\n            rect.origin.y += halfBorderWidth + 0.5;\n            rect.origin.x += halfBorderWidth + 0.5;\n\n            return dataviz.rectToBox(rect);\n        },\n\n        markerBorder: function() {\n            var options = this.options;\n            var markers = options.markers;\n            var border = markers.border;\n            var opacity = valueOrDefault(border.opacity, options.opacity);\n\n            return {\n                color: border.color || this.color,\n                width: border.width,\n                opacity: opacity,\n                dashType: border.dashType\n            };\n        },\n\n        createMarker: function() {\n            var options = this.options;\n            var markerOptions = options.markers;\n            var marker = new ShapeElement({\n                type: valueOrDefault(markerOptions.type, 'rect'),\n                width: markerOptions.size,\n                height: markerOptions.size,\n                rotation: markerOptions.rotation,\n                background: this.color,\n                border: this.markerBorder(),\n                borderRadius: markerOptions.borderRadius,\n                opacity: this.series.opacity || options.opacity,\n                zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n                animation: options.animation,\n                visual: options.visual\n            }, {\n                dataItem: this.dataItem,\n                value: this.value,\n                series: this.series,\n                category: this.category\n            });\n\n            this.marker = marker;\n            this.append(marker);\n        },\n\n        createHighlight: function(style) {\n            var options = this.options;\n            var markerOptions = this.options.highlight.markers || this.options.markers;\n\n            var highlight = new ShapeElement({\n                type: valueOrDefault(markerOptions.type, 'rect'),\n                width: markerOptions.size,\n                height: markerOptions.size,\n                rotation: markerOptions.rotation,\n                background: markerOptions.color || this.color,\n                border: this.markerBorder(),\n                borderRadius: markerOptions.borderRadius,\n                opacity: this.series.opacity || options.opacity,\n                zIndex: valueOrDefault(options.zIndex, this.series.zIndex)\n            });\n\n            highlight.reflow(this.markerBox());\n            var visual = highlight.getElement();\n\n            visual.options.fill = style.fill;\n            visual.options.stroke = style.stroke;\n\n            return visual;\n        },\n\n        highlightVisual: function() {\n            return this.rectVisual;\n        },\n\n        highlightVisualArgs: function() {\n            return {\n                options: this.options,\n                rect: this.box.toRect(),\n                visual: this.rectVisual\n            };\n        },\n\n        createFocusHighlight: function() {\n            var markerOptions = this.options.markers;\n            var highlightOptions = this.options.accessibility.highlight;\n\n            var highlight = new ShapeElement({\n                type: valueOrDefault(markerOptions.type, 'rect'),\n                width: markerOptions.size,\n                height: markerOptions.size,\n                rotation: markerOptions.rotation,\n                background: highlightOptions.color,\n                border: highlightOptions.border,\n                borderRadius: markerOptions.borderRadius,\n                padding: highlightOptions.border.width / 2,\n                zIndex: highlightOptions.zIndex\n            });\n\n            highlight.reflow(this.markerBox());\n\n            return highlight.getElement();\n        },\n\n        tooltipAnchor: function() {\n            var left = this.box.center().x;\n            var top = this.box.y1 - TOOLTIP_OFFSET;\n\n            return {\n                point: new Point(left, top),\n                align: {\n                    horizontal: CENTER,\n                    vertical: BOTTOM\n                }\n            };\n        },\n\n        overlapsBox: function(box) {\n            return this.box.overlaps(box);\n        },\n\n        unclipElements: function() {\n            /* noop, clip labels */\n        },\n\n        pointData: function() {\n            return {\n                x: this.value.x,\n                y: this.value.y,\n                value: this.value.value,\n                dataItem: this.dataItem,\n                series: this.series\n            };\n        }\n    });\n\n    deepExtend(HeatmapPoint.prototype, PointEventsMixin);\n    deepExtend(HeatmapPoint.prototype, NoteMixin);\n    deepExtend(HeatmapPoint.prototype, AccessibilityAttributesMixin);\n\n    HeatmapPoint.prototype.defaults = {\n        markers: {\n            type: 'rect',\n            borderRadius: 4,\n            border: {\n                color: 'transparent'\n            }\n        },\n        padding: { top: 1 },\n        labels: {\n            visible: false,\n            padding: 3\n        },\n        opacity: 1,\n        notes: {\n            label: {}\n        },\n        accessibility: {\n            role: CHART_POINT_ROLE,\n            className: CHART_POINT_CLASSNAME,\n            ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION\n        }\n    };\n\n    var HeatmapChart = ChartElement.extend({\n        init: function(plotArea, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.plotArea = plotArea;\n            this.chartService = plotArea.chartService;\n            this._initFields();\n\n            this.render();\n        },\n\n        _initFields: function() {\n            this.points = [];\n            this.seriesOptions = [];\n            this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };\n            this._evalSeries = [];\n        },\n\n        render: function() {\n            this.setRange();\n            this.traverseDataPoints(this.addValue.bind(this));\n        },\n\n        setRange: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var series = ref.options.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n\n                for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                    var ref$1 = this$1$1.plotArea.bindPoint(currentSeries, pointIx);\n                    var valueFields = ref$1.valueFields;\n                    if (defined(valueFields.value) && valueFields.value !== null) {\n                        this$1$1.valueRange.min = Math.min(this$1$1.valueRange.min, valueFields.value);\n                        this$1$1.valueRange.max = Math.max(this$1$1.valueRange.max, valueFields.value);\n                    }\n                }\n            }\n        },\n\n        addValue: function(value, fields) {\n            var point;\n            if (value && defined(value.value) && value.value !== null) {\n                point = this.createPoint(value, fields);\n                if (point) {\n                    $.extend(point, fields);\n                }\n            }\n\n            this.points.push(point);\n        },\n\n        evalPointOptions: function(options, value, fields) {\n            var series = fields.series;\n            var seriesIx = fields.seriesIx;\n            var state = {\n                defaults: series._defaults,\n                excluded: [\n                    \"data\", \"tooltip\", \"content\", \"template\",\n                    \"visual\", \"toggle\", \"drilldownSeriesFactory\",\n                    \"ariaTemplate\", \"ariaContent\"\n                ]\n            };\n\n            var doEval = this._evalSeries[seriesIx];\n            if (!defined(doEval)) {\n                this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n            }\n\n            var pointOptions = options;\n            if (doEval) {\n                pointOptions = deepExtend({}, options);\n                evalOptions(pointOptions, {\n                    value: value,\n                    series: series,\n                    dataItem: fields.dataItem,\n                    min: this.valueRange.min,\n                    max: this.valueRange.max\n                }, state);\n            }\n\n            return pointOptions;\n        },\n\n        pointType: function() {\n            return HeatmapPoint;\n        },\n\n        pointOptions: function(series, seriesIx) {\n            var options = this.seriesOptions[seriesIx];\n            if (!options) {\n                var defaults = this.pointType().prototype.defaults;\n                this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                    markers: {\n                        opacity: series.opacity\n                    },\n                    tooltip: {\n                        format: this.options.tooltip.format\n                    },\n                    labels: {\n                        format: this.options.labels.format\n                    }\n                }, series);\n            }\n\n            return options;\n        },\n\n        createPoint: function(value, fields) {\n            var series = fields.series;\n            var pointOptions = this.pointOptions(series, fields.seriesIx);\n            var color = fields.color || series.color;\n\n            pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n            if (isFunction(series.color)) {\n                color = pointOptions.color;\n            } else if (this.valueRange.max !== 0) {\n                var scale = colorScale(color);\n                color = scale(value.value / this.valueRange.max);\n            }\n\n            var point = new HeatmapPoint(value, pointOptions);\n            point.color = color;\n\n            this.append(point);\n\n            return point;\n        },\n\n        seriesAxes: function(series) {\n            var xAxisName = series.xAxis;\n            var yAxisName = series.yAxis;\n            var plotArea = this.plotArea;\n            var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n            var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n            if (!xAxis) {\n                throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n            }\n\n            if (!yAxis) {\n                throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n            }\n\n            return { xAxis: xAxis, yAxis: yAxis };\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var chartPoints = this.points;\n            var limit = !this.options.clip;\n            var pointIx = 0;\n\n            this.traverseDataPoints(function (value, fields) {\n                var point = chartPoints[pointIx++];\n                var ref = this$1$1.seriesAxes(fields.series);\n                var xAxis = ref.xAxis;\n                var yAxis = ref.yAxis;\n                var indexX = xAxis.categoryIndex(value.x);\n                var indexY = yAxis.categoryIndex(value.y);\n                var slotX = xAxis.getSlot(indexX, indexX, limit);\n                var slotY = yAxis.getSlot(indexY, indexY, limit);\n\n                if (point) {\n                    if (slotX && slotY) {\n                        var pointSlot = this$1$1.pointSlot(slotX, slotY);\n                        point.reflow(pointSlot);\n                    } else {\n                        point.visible = false;\n                    }\n                }\n            });\n\n            this.box = targetBox;\n        },\n\n        pointSlot: function(slotX, slotY) {\n            return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n        },\n\n        traverseDataPoints: function(callback) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var series = ref.options.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var ref$1 = this$1$1.seriesAxes(currentSeries);\n                var xAxis = ref$1.xAxis;\n                var yAxis = ref$1.yAxis;\n                var xRange = xAxis.currentRangeIndices();\n                var yRange = yAxis.currentRangeIndices();\n\n                for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                    var ref$2 = this$1$1.plotArea.bindPoint(currentSeries, pointIx);\n                    var value = ref$2.valueFields;\n                    var fields = ref$2.fields;\n                    var xIndex = xAxis.totalIndex(value.x);\n                    var yIndex = yAxis.totalIndex(value.y);\n                    var xIn = xRange.min <= xIndex && xIndex <= xRange.max;\n                    var yIn = yRange.min <= yIndex && yIndex <= yRange.max;\n\n                    if (xIn && yIn) {\n                        callback(value, deepExtend({\n                            pointIx: pointIx,\n                            series: currentSeries,\n                            seriesIx: seriesIx,\n                            dataItem: currentSeries.data[pointIx],\n                            owner: this$1$1\n                        }, fields));\n                    }\n                }\n            }\n        },\n\n        formatPointValue: function(point, format) {\n            var value = point.value;\n            return this.chartService.format.auto(format, value.x, value.y, value.value);\n        },\n\n        animationPoints: function() {\n            var points = this.points;\n            var result = [];\n            for (var idx = 0; idx < points.length; idx++) {\n                result.push((points[idx] || {}).marker);\n            }\n            return result;\n        }\n    });\n    setDefaultOptions(HeatmapChart, {\n        series: [],\n        tooltip: {\n            format: \"{0}, {1}: {2}\"\n        },\n        labels: {\n            format: \"{2}\"\n        },\n        clip: true\n    });\n\n    var HeatmapPlotArea = PlotAreaBase.extend({\n        initFields: function() {\n            this.namedXAxes = {};\n            this.namedYAxes = {};\n        },\n\n        render: function(panes) {\n            if (panes === void 0) { panes = this.panes; }\n\n            this.bindCategories();\n            this.createAxes(panes);\n            this.createCharts(panes);\n            this.createAxisLabels();\n        },\n\n        bindCategories: function() {\n            var this$1$1 = this;\n\n            var series = this.srcSeries || this.series;\n\n            for (var i = 0; i < series.length; i++) {\n                var currentSeries = series[i];\n                var data = currentSeries.data || [];\n                var ref = this$1$1.seriesAxes(currentSeries);\n                var xAxis = ref.xAxis;\n                var yAxis = ref.yAxis;\n\n                var xCategories = dataviz.createHashSet(xAxis.categories || []);\n                var yCategories = dataviz.createHashSet(yAxis.categories || []);\n\n                for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {\n                    var ref$1 = SeriesBinder.current.bindPoint(currentSeries, pointIndex).valueFields;\n                    var x = ref$1.x;\n                    var y = ref$1.y;\n\n                    if (!xCategories.has(x)) {\n                        xCategories.add(x);\n                    }\n\n                    if (!yCategories.has(y)) {\n                        yCategories.add(y);\n                    }\n                }\n\n                xAxis.categories = xCategories.values();\n                yAxis.categories = yCategories.values();\n            }\n        },\n\n        createCharts: function(panes) {\n            var this$1$1 = this;\n\n            var seriesByPane = this.groupSeriesByPane();\n\n            for (var i = 0; i < panes.length; i++) {\n                var pane = panes[i];\n                var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n                this$1$1.addToLegend(paneSeries);\n                var filteredSeries = this$1$1.filterVisibleSeries(paneSeries);\n\n                if (!filteredSeries) {\n                    continue;\n                }\n\n                this$1$1.createHeatmapChart(\n                    filterSeriesByType(filteredSeries, [ HEATMAP ]),\n                    pane\n                );\n            }\n        },\n\n        createHeatmapChart: function(series, pane) {\n            var chart = new HeatmapChart(this, {\n                series: series\n            });\n\n            this.appendChart(chart, pane);\n        },\n\n        seriesPaneName: function(series) {\n            var options = this.options;\n            var xAxisName = series.xAxis;\n            var xAxisOptions = [].concat(options.xAxis);\n            var xAxis = grep(xAxisOptions, function(a) { return a.name === xAxisName; })[0];\n            var yAxisName = series.yAxis;\n            var yAxisOptions = [].concat(options.yAxis);\n            var yAxis = grep(yAxisOptions, function(a) { return a.name === yAxisName; })[0];\n            var panes = options.panes || [ {} ];\n            var defaultPaneName = panes[0].name || \"default\";\n            var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n\n            return paneName;\n        },\n\n        seriesAxes: function(series) {\n            var xAxis;\n            var yAxis;\n\n            var options = this.options;\n\n            var xAxisOptions = [].concat(options.xAxis);\n            var xAxisName = series.xAxis;\n            if (xAxisName) {\n                xAxis = xAxisOptions.find(function (axis) { return axis.name === xAxisName; });\n            } else {\n                xAxis = xAxisOptions[0];\n            }\n\n            var yAxisOptions = [].concat(options.yAxis);\n            var yAxisName = series.yAxis;\n            if (yAxisName) {\n                yAxis = yAxisOptions.find(function (axis) { return axis.name === yAxisName; });\n            } else {\n                yAxis = yAxisOptions[0];\n            }\n\n            if (!xAxis) {\n                throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n            }\n\n            if (!yAxis) {\n                throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n            }\n\n            return { xAxis: xAxis, yAxis: yAxis };\n        },\n\n        createAxisLabels: function() {\n            var axes = this.axes;\n            for (var i = 0; i < axes.length; i++) {\n                axes[i].createLabels();\n            }\n        },\n\n        createXYAxis: function(options, vertical, axisIndex) {\n            var axisName = options.name;\n            var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n            var axisOptions = $.extend({\n                axisCrossingValue: 0\n            }, options, {\n                vertical: vertical,\n                reverse: (vertical || this.chartService.rtl) ? !options.reverse : options.reverse,\n                justified: false\n            });\n            var firstCategory = axisOptions.categories ? axisOptions.categories[0] : null;\n            var typeSamples = [ axisOptions.min, axisOptions.max, firstCategory ];\n            var series = this.series;\n\n            for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n                var currentSeries = series[seriesIx];\n                var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n                if ((seriesAxisName === axisOptions.name) || (axisIndex === 0 && !seriesAxisName)) {\n                    var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n                    typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n\n                    break;\n                }\n            }\n\n            var inferredDate;\n\n            for (var i = 0; i < typeSamples.length; i++) {\n                if (typeSamples[i] instanceof Date) {\n                    inferredDate = true;\n                    break;\n                }\n            }\n\n            var axisType;\n            if (equalsIgnoreCase(axisOptions.type, DATE) || (!axisOptions.type && inferredDate)) {\n                axisType = dataviz.DateCategoryAxis;\n            } else {\n                axisType = CategoryAxis;\n            }\n\n            var axis = new axisType(axisOptions, this.chartService);\n            axis.axisIndex = axisIndex;\n\n            if (axisName) {\n                if (namedAxes[axisName]) {\n                    throw new Error(((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\"));\n                }\n                namedAxes[axisName] = axis;\n            }\n\n            this.appendAxis(axis);\n            axis.indexCategories();\n\n            return axis;\n        },\n\n        createAxes: function(panes) {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var xAxesOptions = [].concat(options.xAxis);\n            var xAxes = [];\n            var yAxesOptions = [].concat(options.yAxis);\n            var yAxes = [];\n\n            for (var idx = 0; idx < xAxesOptions.length; idx++) {\n                var axisPane = this$1$1.findPane(xAxesOptions[idx].pane);\n                if (inArray(axisPane, panes)) {\n                    xAxes.push(this$1$1.createXYAxis(xAxesOptions[idx], false, idx));\n                }\n            }\n\n            for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n                var axisPane$1 = this$1$1.findPane(yAxesOptions[idx$1].pane);\n                if (inArray(axisPane$1, panes)) {\n                    yAxes.push(this$1$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n                }\n            }\n\n            this.axisX = this.axisX || xAxes[0];\n            this.axisY = this.axisY || yAxes[0];\n        },\n\n        removeAxis: function(axis) {\n            var axisName = axis.options.name;\n\n            PlotAreaBase.fn.removeAxis.call(this, axis);\n\n            if (axis.options.vertical) {\n                delete this.namedYAxes[axisName];\n            } else {\n                delete this.namedXAxes[axisName];\n            }\n\n            if (axis === this.axisX) {\n                delete this.axisX;\n            }\n\n            if (axis === this.axisY) {\n                delete this.axisY;\n            }\n        },\n\n        _dispatchEvent: function(chart, e, eventType) {\n            var coords = chart._eventCoordinates(e);\n            var point = new Point(coords.x, coords.y);\n            var allAxes = this.axes;\n            var length = allAxes.length;\n            var xValues = [];\n            var yValues = [];\n\n            for (var i = 0; i < length; i++) {\n                var axis = allAxes[i];\n                var values = axis.options.vertical ? yValues : xValues;\n                appendIfNotNull(values, axis.getCategory(point));\n            }\n\n            if (xValues.length > 0 && yValues.length > 0) {\n                chart.trigger(eventType, {\n                    element: eventElement(e),\n                    originalEvent: e,\n                    x: singleItemOrArray(xValues),\n                    y: singleItemOrArray(yValues)\n                });\n            }\n        },\n\n        updateAxisOptions: function(axis, options) {\n            var vertical = axis.options.vertical;\n            var axes = this.groupAxes(this.panes);\n            var index = (vertical ? axes.y : axes.x).indexOf(axis);\n\n            updateAxisOptions$2(this.options, index, vertical, options);\n            updateAxisOptions$2(this.originalOptions, index, vertical, options);\n        },\n\n        crosshairOptions: function(axis) {\n            // Stack the crosshair above the series points.\n            return $.extend({}, axis.options.crosshair, { zIndex: 0 });\n        },\n\n        _pointsByVertical: function(basePoint, offset) {\n            var this$1$1 = this;\n            if (offset === void 0) { offset = 0; }\n\n            var normalizedOffset = this.axisX.options.reverse ? offset * -1 : offset;\n            var axisXItems = this.axisX.children;\n            var xIndex = this._getPointAxisXIndex(basePoint) + normalizedOffset;\n\n            xIndex = cycleIndex(xIndex, axisXItems.length);\n            var targetXValue = axisXItems[xIndex].value;\n\n            var points = this\n                .filterPoints(function (point) { return compareValues(point.pointData().x, targetXValue); })\n                .sort(function (a, b) { return this$1$1._getPointAxisYIndex(a) - this$1$1._getPointAxisYIndex(b); });\n\n            if (this.axisY.options.reverse) {\n                return points.reverse();\n            }\n\n            return points;\n        },\n\n        _pointsByHorizontal: function(basePoint, offset) {\n            var this$1$1 = this;\n            if (offset === void 0) { offset = 0; }\n\n            var normalizedOffset = this.axisY.options.reverse ? offset * -1 : offset;\n            var axisYItems = this.axisY.children;\n            var yIndex = this._getPointAxisYIndex(basePoint) + normalizedOffset;\n\n            yIndex = cycleIndex(yIndex, axisYItems.length);\n            var targetYValue = axisYItems[yIndex].value;\n\n            var points = this\n                .filterPoints(function (point) { return compareValues(point.pointData().y, targetYValue); })\n                .sort(function (a, b) { return this$1$1._getPointAxisXIndex(a) - this$1$1._getPointAxisXIndex(b); });\n\n            if (this.axisX.options.reverse) {\n                return points.reverse();\n            }\n\n            return points;\n        },\n\n        _getPointAxisXIndex: function(point) {\n            return this._getPointAxisIndex(this.axisX, point.pointData().x);\n        },\n\n        _getPointAxisYIndex: function(point) {\n            return this._getPointAxisIndex(this.axisY, point.pointData().y);\n        },\n\n        _getPointAxisIndex: function(axis, pointValue) {\n            return axis.children.findIndex(function (axisItem) { return compareValues(pointValue, axisItem.value); });\n        }\n    });\n\n    function compareValues(a, b) {\n        if (a instanceof Date && b instanceof Date) {\n            return dataviz.dateEquals(a, b);\n        }\n\n        return a === b;\n    }\n\n    function updateAxisOptions$2(targetOptions, axisIndex, vertical, options) {\n        var axisOptions = ([].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis))[axisIndex];\n        deepExtend(axisOptions, options);\n    }\n\n    setDefaultOptions(HeatmapPlotArea, {\n        xAxis: {},\n        yAxis: {}\n    });\n\n    deepExtend(HeatmapPlotArea.prototype, PlotAreaEventsMixin);\n\n    var COLOR = \"color\";\n    var FIRST = \"first\";\n    var FROM = \"from\";\n    var MAX = \"max\";\n    var MIN = \"min\";\n    var NOTE_TEXT = \"noteText\";\n    var SUMMARY_FIELD = \"summary\";\n    var TO = \"to\";\n\n    PlotAreaFactory.current.register(CategoricalPlotArea, [\n        BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA,\n        CANDLESTICK, OHLC, BULLET, VERTICAL_BULLET, BOX_PLOT, VERTICAL_BOX_PLOT,\n        RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, RANGE_AREA, VERTICAL_RANGE_AREA ].concat( TRENDLINE_SERIES\n    ));\n\n    PlotAreaFactory.current.register(XYPlotArea, [\n        SCATTER, SCATTER_LINE, BUBBLE ].concat( TRENDLINE_SERIES\n    ));\n\n    PlotAreaFactory.current.register(PiePlotArea, [ PIE ]);\n    PlotAreaFactory.current.register(DonutPlotArea, [ DONUT ]);\n    PlotAreaFactory.current.register(FunnelPlotArea, [ FUNNEL, PYRAMID ]);\n\n    PlotAreaFactory.current.register(PolarPlotArea, [\n        POLAR_AREA, POLAR_LINE, POLAR_SCATTER ].concat( TRENDLINE_SERIES\n    ));\n\n    PlotAreaFactory.current.register(RadarPlotArea, [\n        RADAR_AREA, RADAR_COLUMN, RADAR_LINE ].concat( TRENDLINE_SERIES\n    ));\n\n    PlotAreaFactory.current.register(HeatmapPlotArea, [ HEATMAP ]);\n\n    SeriesBinder.current.register(\n        [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA ],\n        [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD ]\n    );\n\n    SeriesBinder.current.register(\n        [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\n        [ FROM, TO ], [ CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD ]\n    );\n\n    SeriesBinder.current.register(\n        [ WATERFALL, HORIZONTAL_WATERFALL ],\n        [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD ]\n    );\n\n    SeriesBinder.current.register([ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ], [ X, Y ], [ COLOR, DRILLDOWN_FIELD ]);\n    SeriesBinder.current.register([ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ], [ VALUE ], [ CATEGORY, COLOR, DRILLDOWN_FIELD ]);\n\n    SeriesBinder.current.register(\n        [ FUNNEL, PYRAMID ],\n        [ VALUE ], [ CATEGORY, COLOR, \"visibleInLegend\", \"visible\", DRILLDOWN_FIELD ]\n    );\n\n    DefaultAggregates.current.register(\n        [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL ],\n        { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }\n    );\n\n    DefaultAggregates.current.register(\n        [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\n        { from: MIN, to: MAX, color: FIRST, noteText: FIRST }\n    );\n\n    DefaultAggregates.current.register(\n        [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ],\n        { value: MAX, color: FIRST }\n    );\n\n    SeriesBinder.current.register(\n        [ SCATTER, SCATTER_LINE, BUBBLE ],\n        [ X, Y ], [ COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD ]\n    );\n\n    SeriesBinder.current.register(\n        [ BUBBLE ], [ X, Y, \"size\" ], [ COLOR, CATEGORY, NOTE_TEXT ]\n    );\n\n    SeriesBinder.current.register(\n        [ HEATMAP ],\n        [ X, Y, VALUE ], [ COLOR, NOTE_TEXT ]\n    );\n\n    SeriesBinder.current.register(\n        [ CANDLESTICK, OHLC ],\n        [ \"open\", \"high\", \"low\", \"close\" ], [ CATEGORY, COLOR, \"downColor\", NOTE_TEXT ]\n    );\n\n    DefaultAggregates.current.register(\n        [ CANDLESTICK, OHLC ],\n        { open: MAX, high: MAX, low: MIN, close: MAX,\n            color: FIRST, downColor: FIRST, noteText: FIRST }\n    );\n\n    SeriesBinder.current.register(\n        [ BOX_PLOT, VERTICAL_BOX_PLOT ],\n        [ \"lower\", \"q1\", \"median\", \"q3\", \"upper\", \"mean\", \"outliers\" ], [ CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD ]\n    );\n\n    DefaultAggregates.current.register(\n        [ BOX_PLOT, VERTICAL_BOX_PLOT ],\n        { lower: MAX, q1: MAX, median: MAX, q3: MAX, upper: MAX, mean: MAX, outliers: FIRST,\n            color: FIRST, noteText: FIRST }\n    );\n\n    SeriesBinder.current.register(\n        [ BULLET, VERTICAL_BULLET ],\n        [ \"current\", \"target\" ], [ CATEGORY, COLOR, \"visibleInLegend\", NOTE_TEXT, DRILLDOWN_FIELD ]\n    );\n\n    DefaultAggregates.current.register(\n        [ BULLET, VERTICAL_BULLET ],\n        { current: MAX, target: MAX, color: FIRST, noteText: FIRST }\n    );\n\n    SeriesBinder.current.register(\n        [ PIE, DONUT ],\n        [ VALUE ], [ CATEGORY, COLOR, \"explode\", \"visibleInLegend\", \"visible\", DRILLDOWN_FIELD ]\n    );\n\n    var AXIS_NAMES = [ CATEGORY, VALUE, X, Y ];\n\n    var MOUSEDOWN = \"mousedown\";\n    var MOUSEMOVE = \"mousemove\";\n    var CONTEXTMENU = \"contextmenu\";\n    var MOUSELEAVE = \"mouseleave\";\n    var KEYDOWN = \"keydown\";\n    var FOCUS = \"focus\";\n    var BLUR = \"blur\";\n    var MOUSEMOVE_DELAY = 20;\n\n    var Chart = Class.extend({\n        init: function(element, userOptions, themeOptions, context) {\n            var this$1$1 = this;\n            if (context === void 0) { context = {}; }\n\n            this.observers = [];\n            this.addObserver(context.observer);\n            this.chartService = new services.ChartService(this, context);\n            this.chartService.theme = themeOptions;\n\n            this._initElement(element);\n\n            var options = deepExtend({}, this.options, userOptions);\n            this._originalOptions = deepExtend({}, options);\n            this._theme = themeOptions;\n            this._initTheme(options, themeOptions);\n            this._focusState = {};\n\n            this._initHandlers();\n            this._initSurface();\n\n            this.bindCategories();\n            dataviz.FontLoader.preloadFonts(userOptions, function () {\n                this$1$1.fontLoaded = true;\n                if (!this$1$1._destroyed) {\n                    this$1$1.trigger('init');\n                    this$1$1._redraw();\n                    this$1$1._attachEvents();\n                }\n            });\n        },\n\n        _initElement: function(element) {\n            this._setElementClass(element);\n            element.style.position = \"relative\";\n            element.tabIndex = element.getAttribute(\"tabindex\") ? element.getAttribute(\"tabindex\") : 0;\n            // To support user agents and assistive technologies based on the ARIA 1.0 specification, authors may wish to include the document role as a fallback value, in the form role=\"graphics-document document\".\n            element.setAttribute(\"role\", \"graphics-document document\");\n            while (element.firstChild) {\n                element.removeChild(element.firstChild);\n            }\n            this.element = element;\n        },\n\n        _setElementClass: function(element) {\n            dataviz.addClass(element, \"k-chart\");\n        },\n\n        _initTheme: function(options, themeOptions) {\n            var seriesCopies = [];\n            var series = options.series || [];\n\n            for (var i = 0; i < series.length; i++) {\n                seriesCopies.push($.extend({}, series[i]));\n            }\n            options.series = seriesCopies;\n\n            resolveAxisAliases(options);\n            this.applyDefaults(options, themeOptions);\n\n            // Clean up default if not overriden by data attributes\n            if (options.seriesColors === null) {\n                delete options.seriesColors;\n            }\n\n            if (isString(options.title)) {\n                options.title = { text: options.title };\n            }\n\n            this.options = deepExtend({}, themeOptions, options);\n            this.applySeriesColors();\n        },\n\n        getSize: function() {\n            var chartArea = this.options.chartArea || {};\n            var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);\n            var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);\n\n            return {\n                width: width,\n                height: height\n            };\n        },\n\n        resize: function(force) {\n            var size = this.getSize();\n            var currentSize = this._size;\n            var hasSize = size.width > 0 || size.height > 0;\n\n            if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n                this._size = size;\n                this._resize(size, force);\n                this.trigger(\"resize\", size);\n            } else if (hasSize && this._selections && dataviz.find(this._selections, function (s) { return !s.visible; })) {\n                this._destroySelections();\n                this._setupSelection();\n            }\n        },\n\n        _resize: function() {\n            this._noTransitionsRedraw();\n        },\n\n        redraw: function(paneName) {\n            this.applyDefaults(this.options);\n            this.applySeriesColors();\n\n            if (paneName) {\n                var plotArea = this._model._plotArea;\n                var pane = plotArea.findPane(paneName);\n                plotArea.redraw(pane);\n            } else {\n                this._redraw();\n            }\n        },\n\n        getAxis: function(name) {\n            return findAxisByName(name, this._plotArea.axes);\n        },\n\n        findAxisByName: function(name) {\n            return this.getAxis(name);\n        },\n\n        findPaneByName: function(name) {\n            var panes = this._plotArea.panes;\n\n            for (var idx = 0; idx < panes.length; idx++) {\n                if (panes[idx].options.name === name) {\n                    return new ChartPane(panes[idx]);\n                }\n            }\n        },\n\n        findPaneByIndex: function(idx) {\n            var panes = this._plotArea.panes;\n            if (panes[idx]) {\n                return new ChartPane(panes[idx]);\n            }\n        },\n\n        plotArea: function() {\n            return new ChartPlotArea(this._plotArea);\n        },\n\n        toggleHighlight: function(show, filter) {\n            var plotArea = this._plotArea;\n            var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\n            var points;\n\n            if (isFunction(filter)) {\n                points = plotArea.filterPoints(filter);\n            } else {\n                var seriesName, categoryName;\n                if (isObject(filter)) {\n                    seriesName = filter.series;\n                    categoryName = filter.category;\n                } else {\n                    seriesName = categoryName = filter;\n                }\n\n                if (firstSeries.type === DONUT) {\n                    points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\n                } else if (inArray(firstSeries.type, [ PIE, FUNNEL, PYRAMID ])) {\n                    points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\n                } else {\n                    points = plotArea.pointsBySeriesName(seriesName);\n                }\n            }\n\n            if (points) {\n                this.togglePointsHighlight(show, points);\n            }\n        },\n\n        togglePointsHighlight: function(show, points) {\n            var highlight = this._highlight;\n            for (var idx = 0; idx < points.length; idx++) {\n                highlight.togglePointHighlight(points[idx], show);\n            }\n        },\n\n        showTooltip: function(filter) {\n            var shared = this._sharedTooltip();\n            var ref = this;\n            var tooltip = ref._tooltip;\n            var plotArea = ref._plotArea;\n            var point, categoryIndex;\n\n            if (isFunction(filter)) {\n                point = plotArea.findPoint(filter);\n                if (point && shared) {\n                    categoryIndex = point.categoryIx;\n                }\n            } else if (shared && defined(filter)) {\n                categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\n            }\n\n            if (shared) {\n                if (categoryIndex >= 0) {\n                    var points = this._plotArea.pointsByCategoryIndex(categoryIndex);\n                    tooltip.showAt(points);\n                }\n            } else if (point) {\n                tooltip.show(point);\n            }\n        },\n\n        hideTooltip: function() {\n            this._tooltip.hide();\n        },\n\n        _initSurface: function() {\n            var surface = this.surface;\n            var wrap = this._surfaceWrap();\n\n            var chartArea = this.options.chartArea || {};\n            if (chartArea.width) {\n                dataviz.elementSize(wrap, { width: chartArea.width });\n            }\n            if (chartArea.height) {\n                dataviz.elementSize(wrap, { height: chartArea.height });\n            }\n\n            if (!surface || surface.options.type !== this.options.renderAs) {\n                this._destroySurface();\n\n                this.surface = drawing.Surface.create(wrap, {\n                    type: this.options.renderAs\n                });\n\n                this.surface.bind(\"mouseenter\", this._surfaceMouseenterHandler);\n                this.surface.bind(\"mouseleave\", this._surfaceMouseleaveHandler);\n\n            } else {\n                this.surface.clear();\n                this.surface.resize();\n            }\n        },\n\n        _surfaceWrap: function() {\n            return this.element;\n        },\n\n        _redraw: function() {\n            var model = this._getModel();\n            this._size = {\n                width: model.options.width,\n                height: model.options.height\n            };\n\n            this._destroyView();\n\n            this._setElementAccessibilityAttributes();\n\n            this._model = model;\n            this._plotArea = model._plotArea;\n            this._legend = model._legend;\n\n            model.renderVisual();\n\n            if (this.options.transitions !== false) {\n                model.traverse(function(element) {\n                    if (element.animation) {\n                        element.animation.setup();\n                    }\n                });\n            }\n\n            this._initSurface();\n            this.surface.draw(model.visual);\n\n            if (this.options.transitions !== false) {\n                model.traverse(function(element) {\n                    if (element.animation) {\n                        element.animation.play();\n                    }\n                });\n            }\n\n            this._tooltip = this._createTooltip();\n            this._highlight = new Highlight();\n            this._setupSelection();\n            this._createPannable();\n            this._createZoomSelection();\n            this._createMousewheelZoom();\n\n            this.trigger(RENDER);\n            triggerPaneRender(this._plotArea.panes);\n\n            if (!this._navState) {\n                this._cancelDomEvents();\n            }\n\n            this._redrawFocusHighlight();\n        },\n\n        _redrawFocusHighlight: function() {\n            var ref = this;\n            var ref_focusState = ref._focusState;\n            var legendInFocus = ref_focusState.legendInFocus;\n            var preserveHighlight = ref_focusState.preserveHighlight;\n\n            if (legendInFocus && preserveHighlight) {\n                this._focusElement(this._getFocusedLegendItem(), false);\n                this._focusState.preserveHighlight = false;\n            }\n        },\n\n        _setElementAccessibilityAttributes: function() {\n            var titleOptions = this.options.title;\n            var title = isString(titleOptions) ? titleOptions : (titleOptions.description || titleOptions.text);\n\n            if (title) {\n                this.element.setAttribute(\"aria-roledescription\", title);\n            }\n        },\n\n        exportVisual: function(exportOptions) {\n            var visual;\n            if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\n                var currentOptions = this.options;\n                var options = deepExtend({}, exportOptions.options, {\n                    chartArea: {\n                        width: exportOptions.width,\n                        height: exportOptions.height\n                    }\n                });\n\n                clearMissingValues(this._originalOptions, options);\n                this.options = deepExtend({}, this._originalOptions, options);\n                this._initTheme(this.options, this._theme);\n                this.bindCategories();\n\n                var model = this._getModel();\n\n                model.renderVisual();\n                triggerPaneRender(model._plotArea.panes);\n\n                visual = model.visual;\n\n                this.options = currentOptions;\n            } else {\n                visual = this.surface.exportVisual();\n            }\n\n            return visual;\n        },\n\n        _sharedTooltip: function() {\n            return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip && this.options.tooltip.shared;\n        },\n\n        _createPannable: function() {\n            var options = this.options;\n            if (options.pannable !== false) {\n                this._pannable = new Pannable(this._plotArea, options.pannable);\n            }\n        },\n\n        _createZoomSelection: function() {\n            var zoomable = this.options.zoomable;\n            var selection = (zoomable || {}).selection;\n            if (zoomable !== false && selection !== false) {\n                this._zoomSelection = new ZoomSelection(this, selection);\n            }\n        },\n\n        _createMousewheelZoom: function() {\n            var zoomable = this.options.zoomable;\n            var mousewheel = (zoomable || {}).mousewheel;\n            if (zoomable !== false && mousewheel !== false) {\n                this._mousewheelZoom = new MousewheelZoom(this, mousewheel);\n            }\n        },\n\n        _toggleDragZoomEvents: function() {\n            var pannable = this.options.pannable;\n            var zoomable = this.options.zoomable;\n            var selection = (zoomable || {}).selection;\n            var mousewheel = (zoomable || {}).mousewheel;\n            var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ]);\n            var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ ZOOM_START, ZOOM, ZOOM_END ]);\n            var element = this.element;\n\n            if (this._dragZoomEnabled && allowDrag && allowZoom) {\n                element.style.touchAction = this._touchAction || '';\n                this._dragZoomEnabled = false;\n            } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {\n                element.style.touchAction = \"none\";\n\n                this._dragZoomEnabled = true;\n            }\n\n            this._toggleDomEvents(!allowDrag, !allowZoom);\n        },\n\n        _toggleDomEvents: function(drag, zoom) {\n            var domEvents = this.domEvents;\n            if (!domEvents) {\n                return;\n            }\n\n            if (domEvents.toggleDrag) {\n                domEvents.toggleDrag(drag);\n            }\n\n            if (domEvents.toggleZoom) {\n                domEvents.toggleZoom(zoom);\n            }\n        },\n\n        _createTooltip: function() {\n            var ref = this;\n            var tooltipOptions = ref.options.tooltip;\n            var tooltip;\n\n            if (this._sharedTooltip()) {\n                tooltip = this._createSharedTooltip(tooltipOptions);\n            } else {\n                tooltip = new Tooltip(this.chartService, tooltipOptions);\n            }\n\n            return tooltip;\n        },\n\n        _createSharedTooltip: function(options) {\n            return new SharedTooltip(this._plotArea, options);\n        },\n\n        applyDefaults: function(options, themeOptions) {\n            applyAxisDefaults(options, themeOptions);\n            applySeriesDefaults(options, themeOptions);\n        },\n\n        applySeriesColors: function() {\n            var options = this.options;\n            var series = options.series;\n            var colors = options.seriesColors || [];\n\n            for (var i = 0; i < series.length; i++) {\n                var currentSeries = series[i];\n                var seriesColor = colors[i % colors.length];\n                var defaults = currentSeries._defaults;\n\n                currentSeries.color = currentSeries.color || seriesColor;\n                if (defaults) {\n                    defaults.color = defaults.color || seriesColor;\n                }\n            }\n        },\n\n        _getModel: function() {\n            var options = this.options;\n            var plotArea = this._createPlotArea();\n            var model = new dataviz.RootElement(this._modelOptions());\n            model.chart = this;\n            model._plotArea = plotArea;\n\n            var title = Title.buildTitle(options.title);\n            var subtitle = Title.buildTitle(options.subtitle, {\n                align: options.title.align,\n                position: options.title.position\n            });\n            model.append.apply(model, Title.orderTitles([title, subtitle]));\n\n            if (options.legend && options.legend.visible) {\n                var legend = new Legend(plotArea.options.legend, this.chartService);\n                model.append(legend);\n                model._legend = legend;\n            }\n            model.append(plotArea);\n            model.reflow();\n\n            return model;\n        },\n\n        _modelOptions: function() {\n            var options = this.options;\n            var size = this.getSize();\n\n            return deepExtend({\n                transitions: options.transitions,\n                width: size.width || datavizConstants.DEFAULT_WIDTH,\n                height: size.height || datavizConstants.DEFAULT_HEIGHT\n            }, options.chartArea);\n        },\n\n        _createPlotArea: function(skipSeries) {\n            var options = this.options;\n\n            var plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options.series, options, this.chartService);\n\n            return plotArea;\n        },\n\n        _setupSelection: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var axes = ref._plotArea.axes;\n            var selections = this._selections = [];\n\n            for (var i = 0; i < axes.length; i++) {\n                var axis = axes[i];\n                var options = axis.options;\n                if (axis instanceof CategoryAxis && options.select && !options.vertical) {\n                    var range = axis.range();\n\n                    var selection = new Selection(this$1$1, axis,\n                        deepExtend({ min: range.min, max: range.max }, options.select)\n                    );\n\n                    selections.push(selection);\n                }\n            }\n        },\n\n        _selectStart: function(e) {\n            return this.trigger(SELECT_START, e);\n        },\n\n        _select: function(e) {\n            return this.trigger(SELECT, e);\n        },\n\n        _selectEnd: function(e) {\n            return this.trigger(SELECT_END, e);\n        },\n\n        _initHandlers: function() {\n            this._clickHandler = this._click.bind(this);\n            this._keydownHandler = this._keydown.bind(this);\n            this._focusHandler = this._focus.bind(this);\n            this._blurHandler = this._blur.bind(this);\n            this._mousedownHandler = this._mousedown.bind(this);\n            this._mousewheelHandler = this._mousewheel.bind(this);\n            this._mouseleaveHandler = this._mouseleave.bind(this);\n            this._surfaceMouseenterHandler = this._mouseover.bind(this);\n            this._surfaceMouseleaveHandler = this._mouseout.bind(this);\n\n            this._mousemove = kendo.throttle(\n                this._mousemove.bind(this),\n                MOUSEMOVE_DELAY\n            );\n        },\n\n        addObserver: function(observer) {\n            if (observer) {\n                this.observers.push(observer);\n            }\n        },\n\n        removeObserver: function(observer) {\n            var index = this.observers.indexOf(observer);\n            if (index >= 0) {\n                this.observers.splice(index, 1);\n            }\n        },\n\n        requiresHandlers: function(eventNames) {\n            var observers = this.observers;\n            for (var idx = 0; idx < observers.length; idx++) {\n                if (observers[idx].requiresHandlers(eventNames)) {\n                    return true;\n                }\n            }\n        },\n\n        trigger: function(name, args) {\n            if (args === void 0) { args = {}; }\n\n            args.sender = this;\n\n            if (name === SHOW_TOOLTIP) {\n                args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\n            } else if (name === SERIES_OVER) {\n                this._updateDrilldownPoint(args.point);\n            } else if (name === SERIES_LEAVE) {\n                this._resetDrilldownPoint();\n            } else if (name === SERIES_CLICK) {\n                this._focusPoint(args.point);\n                this._startDrilldown(args.point);\n            } else if (name === LEGEND_ITEM_CLICK) {\n                this._focusLegendItem(args);\n            }\n\n            var observers = this.observers;\n            var isDefaultPrevented = false;\n            for (var idx = 0; idx < observers.length; idx++) {\n                if (observers[idx].trigger(name, args)) {\n                    isDefaultPrevented = true;\n                }\n            }\n\n            return isDefaultPrevented;\n        },\n\n        _attachEvents: function() {\n            var element = this.element;\n\n            this._touchAction = element.style.touchAction;\n\n            var obj;\n            bindEvents(element, ( obj = {}, obj[ CONTEXTMENU ] = this._clickHandler, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj[ MOUSELEAVE ] = this._mouseleaveHandler, obj[ KEYDOWN ] = this._keydownHandler, obj[ MOUSEDOWN ] = this._mousedownHandler, obj[ FOCUS ] = this._focusHandler, obj[ BLUR] = this._blurHandler, obj ));\n\n            if (this._shouldAttachMouseMove()) {\n                var obj$1;\n                bindEvents(element, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mousemove, obj$1 ));\n            }\n\n            this.domEvents = services.DomEventsBuilder.create(this.element, {\n                start: this._start.bind(this),\n                move: this._move.bind(this),\n                end: this._end.bind(this),\n                tap: this._tap.bind(this),\n                gesturestart: this._gesturestart.bind(this),\n                gesturechange: this._gesturechange.bind(this),\n                gestureend: this._gestureend.bind(this)\n            });\n\n            this._toggleDragZoomEvents();\n        },\n\n        _mouseleave: function(e) {\n            if (this._hoveredPoint) {\n                this._hoveredPoint.out(this, e);\n                this._hoveredPoint = null;\n            }\n\n            if (this._plotAreaHovered) {\n                this._plotAreaHovered = false;\n                this.trigger(PLOT_AREA_LEAVE);\n            }\n\n            if (this._hasInactiveOpacity() && this._activeChartInstance) {\n                this._applySeriesOpacity(this._activeChartInstance.children, null, true);\n                this._updateSeriesOpacity(null, true);\n            }\n        },\n\n        _cancelDomEvents: function() {\n            if (this.domEvents && this.domEvents.cancel) {\n                this.domEvents.cancel();\n            }\n        },\n\n        _gesturestart: function(e) {\n            if (this._mousewheelZoom && !this._stopChartHandlers(e)) {\n                this._gestureDistance = e.distance;\n                this._unsetActivePoint();\n                this._clearFocusedElement();\n                this.surface.suspendTracking();\n            }\n        },\n\n        _gestureend: function(e) {\n            if (this._zooming && !this._stopChartHandlers(e)) {\n                if (this.surface) {\n                    this.surface.resumeTracking();\n                }\n                this._zooming = false;\n                this.trigger(ZOOM_END, {});\n            }\n        },\n\n        _gesturechange: function(e) {\n            var mousewheelZoom = this._mousewheelZoom;\n\n            if (mousewheelZoom && !this._stopChartHandlers(e)) {\n                e.preventDefault();\n                var previousGestureDistance = this._gestureDistance;\n                var scaleDelta = -e.distance / previousGestureDistance + 1;\n\n                if (Math.abs(scaleDelta) >= 0.1) {\n                    scaleDelta = Math.round(scaleDelta * 10);\n\n                    this._gestureDistance = e.distance;\n                    var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };\n                    if (this._zooming || !this.trigger(ZOOM_START, args)) {\n                        var coords = this._eventCoordinates(e);\n\n                        if (!this._zooming) {\n                            this._zooming = true;\n                        }\n\n                        var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);\n                        if (ranges && !this.trigger(ZOOM, args)) {\n                            mousewheelZoom.zoom();\n                        }\n                    }\n                }\n            }\n        },\n\n        _mouseout: function(e) {\n            if (e.element) {\n                var element = this._drawingChartElement(e.element, e);\n\n                if (element && element.leave) {\n                    element.leave(this, e.originalEvent);\n                }\n            }\n        },\n\n        _start: function(e) {\n            var coords = this._eventCoordinates(e);\n\n            if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n                return;\n            }\n\n            if (this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ])) {\n                this._startNavigation(e, coords, DRAG_START);\n            }\n\n            if (this._pannable && this._pannable.start(e)) {\n                this.surface.suspendTracking();\n                this._unsetActivePoint();\n                this._clearFocusedElement();\n                this._suppressHover = true;\n                this.chartService.panning = true;\n            }\n\n            if (this._zoomSelection) {\n                if (this._zoomSelection.start(e)) {\n                    this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });\n                }\n            }\n        },\n\n        _move: function(e) {\n            var ref = this;\n            var state = ref._navState;\n            var pannable = ref._pannable;\n\n            if (this._stopChartHandlers(e)) {\n                return;\n            }\n\n            if (pannable) {\n                var ranges = pannable.move(e);\n\n                if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {\n                    pannable.pan();\n                }\n            } else if (state) {\n                var ranges$1 = {};\n                var axes = state.axes;\n\n                for (var i = 0; i < axes.length; i++) {\n                    var currentAxis = axes[i];\n                    var axisName = currentAxis.options.name;\n                    if (axisName) {\n                        var axis = currentAxis.options.vertical ? e.y : e.x;\n                        var delta = axis.startLocation - axis.location;\n\n                        if (delta !== 0) {\n                            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);\n                        }\n                    }\n                }\n\n                state.axisRanges = ranges$1;\n                this.trigger(DRAG, {\n                    axisRanges: ranges$1,\n                    originalEvent: e\n                });\n            }\n\n            if (this._zoomSelection) {\n                this._zoomSelection.move(e);\n            }\n        },\n\n        _end: function(e) {\n            if (this._stopChartHandlers(e)) {\n                return;\n            }\n\n            var pannable = this._pannable;\n            if (pannable && pannable.end(e)) {\n                this.surface.resumeTracking();\n                this.trigger(DRAG_END, {\n                    axisRanges: axisRanges(this._plotArea.axes),\n                    originalEvent: e\n                });\n                this._suppressHover = false;\n                this.chartService.panning = false;\n            } else {\n                this._endNavigation(e, DRAG_END);\n            }\n\n            if (this._zoomSelection) {\n                var ranges = this._zoomSelection.end(e);\n                if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {\n                    this._zoomSelection.zoom();\n                    this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });\n                }\n            }\n        },\n\n        _stopChartHandlers: function(e) {\n            var selections = this._selections || [];\n            if (!selections.length) {\n                return false;\n            }\n\n            var coords = this._eventCoordinates(e);\n            var pane = this._plotArea.paneByPoint(coords);\n            if (pane) {\n                for (var idx = 0; idx < selections.length; idx++) {\n                    if (selections[idx].onPane(pane)) {\n                        return true;\n                    }\n                }\n            }\n        },\n\n        _mousewheelZoomRate: function() {\n            var zoomable = this.options.zoomable;\n            var mousewheel = (zoomable || {}).mousewheel || {};\n            return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);\n        },\n\n        _mousewheel: function(e) {\n            var this$1$1 = this;\n\n            var delta = dataviz.mousewheelDelta(e);\n            var mousewheelZoom = this._mousewheelZoom;\n            var coords = this._eventCoordinates(e);\n\n            if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n                return;\n            }\n\n            if (mousewheelZoom) {\n                var args = { delta: delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };\n                if (this._zooming || !this.trigger(ZOOM_START, args)) {\n                    e.preventDefault();\n\n                    if (!this._zooming) {\n                        this._unsetActivePoint();\n                        this._clearFocusedElement();\n                        this.surface.suspendTracking();\n                        this._zooming = true;\n                    }\n\n                    if (this._mwTimeout) {\n                        clearTimeout(this._mwTimeout);\n                    }\n\n                    args.axisRanges = mousewheelZoom.updateRanges(delta, coords);\n                    if (args.axisRanges && !this.trigger(ZOOM, args)) {\n                        mousewheelZoom.zoom();\n                    }\n\n                    this._mwTimeout = setTimeout(function () {\n                        this$1$1.trigger(ZOOM_END, args);\n                        this$1$1._zooming = false;\n                        if (this$1$1.surface) {\n                            this$1$1.surface.resumeTracking();\n                        }\n                    }, MOUSEWHEEL_DELAY);\n                }\n            } else {\n                var state = this._navState;\n                if (!state) {\n                    var prevented = this._startNavigation(e, coords, ZOOM_START);\n                    if (!prevented) {\n                        state = this._navState;\n                    }\n                }\n\n                if (state) {\n                    var totalDelta = state.totalDelta || delta;\n                    state.totalDelta = totalDelta + delta;\n\n                    var axes = this._navState.axes;\n                    var ranges = {};\n\n                    for (var i = 0; i < axes.length; i++) {\n                        var currentAxis = axes[i];\n                        var axisName = currentAxis.options.name;\n                        if (axisName) {\n                            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1$1._mousewheelZoomRate(), coords);\n                        }\n                    }\n\n                    this.trigger(ZOOM, {\n                        delta: delta,\n                        axisRanges: ranges,\n                        originalEvent: e\n                    });\n\n                    if (this._mwTimeout) {\n                        clearTimeout(this._mwTimeout);\n                    }\n\n                    this._mwTimeout = setTimeout(function () {\n                        this$1$1._endNavigation(e, ZOOM_END);\n                    }, MOUSEWHEEL_DELAY);\n                }\n            }\n        },\n\n        _startNavigation: function(e, coords, chartEvent) {\n            var plotArea = this._model._plotArea;\n            var pane = plotArea.findPointPane(coords);\n            var axes = plotArea.axes.slice(0);\n\n            if (!pane) {\n                return;\n            }\n\n            var ranges = axisRanges(axes);\n\n            var prevented = this.trigger(chartEvent, {\n                axisRanges: ranges,\n                originalEvent: e\n            });\n\n            if (prevented) {\n                this._cancelDomEvents();\n            } else {\n                this._suppressHover = true;\n                this._unsetActivePoint();\n                this._clearFocusedElement();\n                this._navState = {\n                    axisRanges: ranges,\n                    pane: pane,\n                    axes: axes\n                };\n            }\n        },\n\n        _endNavigation: function(e, chartEvent) {\n            if (this._navState) {\n                this.trigger(chartEvent, {\n                    axisRanges: this._navState.axisRanges,\n                    originalEvent: e\n                });\n                this._suppressHover = false;\n                this._navState = null;\n            }\n        },\n\n        _getChartElement: function(e, match) {\n            var element = this.surface.eventTarget(e);\n            if (element) {\n                return this._drawingChartElement(element, e, match);\n            }\n        },\n\n        _drawingChartElement: function(element, e, match) {\n            var current = element;\n            var chartElement;\n            while (current && !chartElement) {\n                chartElement = current.chartElement;\n                current = current.parent;\n            }\n\n            if (chartElement) {\n                if (chartElement.aliasFor) {\n                    chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\n                }\n\n                if (match) {\n                    chartElement = chartElement.closest(match);\n                    if (chartElement && chartElement.aliasFor) {\n                        chartElement = chartElement.aliasFor();\n                    }\n                }\n\n                return chartElement;\n            }\n        },\n\n        _eventCoordinates: function(e) {\n            var coordinates = dataviz.eventCoordinates(e);\n            return this._toModelCoordinates(coordinates.x, coordinates.y);\n        },\n\n        _elementPadding: function() {\n            if (!this._padding) {\n                var ref = elementStyles(this.element, [ \"paddingLeft\", \"paddingTop\" ]);\n                var paddingLeft = ref.paddingLeft;\n                var paddingTop = ref.paddingTop;\n                this._padding = {\n                    top: paddingTop,\n                    left: paddingLeft\n                };\n            }\n\n            return this._padding;\n        },\n\n        _toDocumentCoordinates: function(point) {\n            var padding = this._elementPadding();\n            var offset = dataviz.elementOffset(this.element);\n\n            return {\n                left: round(point.x + padding.left + offset.left),\n                top: round(point.y + padding.top + offset.top)\n            };\n        },\n\n        _toModelCoordinates: function(clientX, clientY) {\n            var element = this.element;\n            var offset = dataviz.elementOffset(element);\n            var padding = this._elementPadding();\n            var inverseTransform = dataviz.elementScale(element).invert();\n            var point = new GeometryPoint(\n                clientX - offset.left - padding.left,\n                clientY - offset.top - padding.top\n            ).transform(inverseTransform);\n\n            return new Point(point.x, point.y);\n        },\n\n        _tap: function(e) {\n            var this$1$1 = this;\n\n            var drawingElement = this.surface.eventTarget(e);\n            var element = this._drawingChartElement(drawingElement, e);\n            var sharedTooltip = this._sharedTooltip();\n\n            if (!this._startHover(drawingElement, e) && !sharedTooltip) {\n                this._unsetActivePoint();\n            }\n\n            if (sharedTooltip) {\n                this._trackSharedTooltip(this._eventCoordinates(e), e, true);\n            }\n\n            this._propagateClick(element, e);\n\n            //part of fix for hover issue on windows touch\n            this.handlingTap = true;\n            setTimeout(function () {\n                this$1$1.handlingTap = false;\n            }, 0);\n        },\n\n        _click: function(e) {\n            var element = this._getChartElement(e);\n            this._propagateClick(element, e);\n        },\n\n        _propagateClick: function(element, e) {\n            var this$1$1 = this;\n\n            var current = element;\n            while (current) {\n                if (current.click) {\n                    current.click(this$1$1, e);\n                }\n\n                current = current.parent;\n            }\n        },\n\n        _isLegendBeforeChart: function() {\n            var ref = this;\n            var legendPosition = ref.options.legend.position;\n            var legend = ref._legend;\n\n            return legend && legend.hasItems() && (legendPosition === TOP || legendPosition === LEFT);\n        },\n\n        _focus: function() {\n            if (!this._preventInitialPointFocus) {\n                if (this._isLegendBeforeChart()) {\n                    this._focusFirstLegendItem();\n                } else {\n                    this._focusFirstPoint();\n                }\n            }\n\n            this._preventInitialPointFocus = false;\n        },\n\n        _keydown: function(e) {\n            var ref = this;\n            var ref_focusState = ref._focusState;\n            var legendInFocus = ref_focusState.legendInFocus;\n            var focusedElement = ref_focusState.focusedElement;\n            var legend = ref._legend;\n\n            if (e.key === datavizConstants.TAB) {\n                this._clearFocusedElement();\n                var isLegendBeforeChart = this._isLegendBeforeChart();\n\n                if (legendInFocus && isLegendBeforeChart !== e.shiftKey) {\n                    this._navigatePoints(e);\n                } else if (!legendInFocus && isLegendBeforeChart === e.shiftKey && legend.hasItems()) {\n                    this._navigateLegend(e);\n                }\n            } else if (e.key === datavizConstants.ESCAPE) {\n                if (focusedElement) {\n                    e.stopPropagation();\n                }\n\n                if (this._tooltip && this._tooltip.visible) {\n                    this._hideTooltip();\n                } else {\n                    this._blur();\n                }\n            } else if (e.key === datavizConstants.ENTER) {\n                if (focusedElement) {\n                    this._focusState.preserveHighlight = true;\n                    this._propagateClick(focusedElement, e);\n                    this._focusElement(focusedElement);\n                }\n            } else if (!legendInFocus) {\n                this._navigatePoints(e);\n            } else {\n                this._navigateLegend(e);\n            }\n        },\n\n        _navigatePoints: function(e) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var focusState = ref._focusState;\n            var plotArea = ref._plotArea;\n\n            focusState.legendInFocus = false;\n\n            if (!focusState.focusedElement) {\n                this._focusFirstPoint();\n                e.preventDefault();\n                return;\n            }\n\n            var moveFocus = function (point) {\n                focusState.focusedPoint = point;\n\n                this$1$1._focusElement(focusState.focusedPoint);\n                this$1$1._displayTooltip(point);\n                e.preventDefault();\n            };\n\n            switch (e.key) {\n                case datavizConstants.ARROW_RIGHT:\n                    moveFocus(plotArea.getPointToTheRight(focusState.focusedPoint));\n                    break;\n                case datavizConstants.ARROW_LEFT:\n                    moveFocus(plotArea.getPointToTheLeft(focusState.focusedPoint));\n                    break;\n                case datavizConstants.ARROW_DOWN:\n                    moveFocus(plotArea.getPointBelow(focusState.focusedPoint));\n                    break;\n                case datavizConstants.ARROW_UP:\n                    moveFocus(plotArea.getPointAbove(focusState.focusedPoint));\n                    break;\n                default:\n                    break;\n            }\n        },\n\n        _navigateLegend: function(e) {\n            var this$1$1 = this;\n\n            var ref = this;\n            var focusState = ref._focusState;\n            var legend = ref._legend;\n            var rtl = ref.chartService.rtl;\n\n            focusState.legendInFocus = true;\n\n            if (!focusState.focusedElement) {\n                this._focusFirstLegendItem();\n                e.preventDefault();\n                return;\n            }\n\n            var itemsLength = legend.getItems().length;\n            var moveFocus = function (cycleFunc) {\n                focusState.focusedLegendItemIndex = cycleFunc(\n                    focusState.focusedLegendItemIndex,\n                    itemsLength\n                );\n                this$1$1._focusElement(this$1$1._getFocusedLegendItem());\n                e.preventDefault();\n            };\n\n            switch (e.key) {\n                case datavizConstants.ARROW_UP:\n                case datavizConstants.ARROW_LEFT:\n                    moveFocus(rtl ? dataviz.cycleUp : dataviz.cycleDown);\n                    break;\n                case datavizConstants.ARROW_DOWN:\n                case datavizConstants.ARROW_RIGHT:\n                    moveFocus(rtl ? dataviz.cycleDown : dataviz.cycleUp);\n                    break;\n                default:\n                    break;\n            }\n        },\n\n        _focusFirstPoint: function() {\n            var point = this._focusState.focusedPoint = this._plotArea.getFirstPoint();\n\n            if (point) {\n                this._focusElement(point);\n                this._displayTooltip(point);\n            }\n        },\n\n        _hasFocus: function() {\n            return this.element.ownerDocument.activeElement === this.element;\n        },\n\n        _mousedown: function() {\n            if (!this._hasFocus()) {\n                this._preventInitialPointFocus = true;\n            }\n        },\n\n        _focusChart: function() {\n            if (!this._hasFocus()) {\n                this._preventInitialPointFocus = true;\n                this.element.focus();\n            }\n        },\n\n        _focusPoint: function(point) {\n            this._focusState.focusedPoint = point;\n\n            this._focusChart();\n\n            this._focusElement(point, true);\n        },\n\n        _focusFirstLegendItem: function() {\n            var ref = this;\n            var focusState = ref._focusState;\n\n            focusState.focusedLegendItemIndex = 0;\n            this._focusElement(this._getFocusedLegendItem());\n            focusState.legendInFocus = true;\n\n            this._hideTooltip();\n        },\n\n        _focusLegendItem: function(args) {\n            var ref = this;\n            var focusState = ref._focusState;\n\n            focusState.focusedLegendItemIndex = this._legend\n                .getItems()\n                .findIndex(function (x) { return x.options.series.index === args.seriesIndex\n                    && x.options.pointIndex === args.pointIndex; });\n\n            focusState.legendInFocus = true;\n\n            this._focusChart();\n\n            this._focusElement(this._getFocusedLegendItem(), true);\n        },\n\n        _getFocusedLegendItem: function() {\n            var ref = this;\n            var focusState = ref._focusState;\n            var legend = ref._legend;\n\n            return legend.getItems()[focusState.focusedLegendItemIndex];\n        },\n\n        _focusElement: function(element, omitHighlight) {\n            var ref = this;\n            var focusState = ref._focusState;\n\n            this._clearFocusedElement();\n\n            if (!element) {\n                return;\n            }\n\n            focusState.focusedElement = element;\n\n            this._setElementActiveDescendant(element);\n\n            if (!omitHighlight) {\n                element.focusVisual();\n\n                if (focusState.legendInFocus) {\n                    var options = element.options;\n\n                    this._showSeriesInactiveOpacity(options.series.index, options.pointIndex);\n                } else {\n                    this._showInactiveOpacity(element);\n                }\n            }\n        },\n\n        _clearFocusedElement: function() {\n            var ref = this;\n            var focusState = ref._focusState;\n\n            if (!focusState) {\n                return;\n            }\n\n            if (focusState.focusedElement) {\n                focusState.focusedElement.clearFocusFromVisual();\n                this._clearElementActiveDescendant();\n            }\n\n            focusState.focusedElement = null;\n        },\n\n        _setElementActiveDescendant: function(element) {\n            if (this.options.renderAs === \"canvas\") {\n                this._pseudoFocusedElement = this._createPseudoFocusedElement(element);\n                this.element.append(this._pseudoFocusedElement);\n            }\n\n            this.element.setAttribute(datavizConstants.ARIA_ACTIVE_DESCENDANT, element._id);\n        },\n\n        _clearElementActiveDescendant: function() {\n            if (this._pseudoFocusedElement) {\n                this._pseudoFocusedElement.remove();\n                this._pseudoFocusedElement = null;\n            }\n\n            this.element.removeAttribute(datavizConstants.ARIA_ACTIVE_DESCENDANT);\n        },\n\n        _createPseudoFocusedElement: function(element) {\n            var pseudoElement = document.createElement(\"div\");\n            var accessibilityOptions = element.options.accessibility;\n\n            pseudoElement.id = element._id;\n            pseudoElement.setAttribute(\"aria-label\", element.getAriaLabelText());\n            pseudoElement.setAttribute(\"role\", accessibilityOptions.role);\n            pseudoElement.setAttribute(\"aria-roledescription\", accessibilityOptions.ariaRoleDescription);\n\n            var checked = accessibilityOptions.ariaChecked;\n            if (defined(checked)) {\n                pseudoElement.setAttribute(\"aria-checked\", checked);\n            }\n\n            return pseudoElement;\n        },\n\n        _blur: function() {\n            this._focusState.legendInFocus = false;\n            this._clearFocusedElement();\n            this._hideInactiveOpacity();\n        },\n\n        _startHover: function(element, e) {\n            if (this._suppressHover) {\n                return false;\n            }\n\n            var point = this._drawingChartElement(element, e, function(element) {\n                return (element.hover || element.over) && !(element instanceof PlotAreaBase);\n            });\n\n            var activePoint = this._activePoint;\n\n            this._updateHoveredPoint(point, e);\n\n            if (point && activePoint !== point && point.hover) {\n                this._activePoint = point;\n\n                if (!this._sharedTooltip() && !point.hover(this, e)) {\n                    this._displayTooltip(point);\n\n                    this._showInactiveOpacity(point);\n                }\n            }\n\n            return point;\n        },\n\n        _displayTooltip: function(point) {\n            var tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);\n            if (tooltipOptions.visible) {\n                this._tooltip.show(point);\n            }\n        },\n\n        _hideTooltip: function() {\n            if (this._tooltip) {\n                this._tooltip.hide();\n            }\n        },\n\n        _displayInactiveOpacity: function(activePoint, multipleSeries, highlightPoints) {\n            var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);\n            if (!chartInstance) {\n                return;\n            }\n\n            if (multipleSeries) {\n                this._updateSeriesOpacity(activePoint);\n                this._applySeriesOpacity(chartInstance.children, null, true);\n                this._applySeriesOpacity(chartInstance.children, activePoint.series);\n                this._highlight.show(highlightPoints || activePoint);\n            } else {\n                var inactivePoints;\n\n                if (!chartInstance.supportsPointInactiveOpacity()) {\n                    this._highlight.show(activePoint);\n                    return;\n                }\n\n                inactivePoints = this._getInactivePoints(activePoint, chartInstance);\n\n                if (inactivePoints && inactivePoints.length) {\n                    this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));\n                }\n            }\n        },\n\n        _getInactivePoints: function(activePoint, chartInstance) {\n            var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);\n\n            return allPoints.filter(function (point) { return point !== activePoint; });\n        },\n\n        _getAllPointsOfType: function(container, type) {\n            var this$1$1 = this;\n\n            var points = [];\n\n            for (var i = 0; i < container.children.length; i++) {\n                var element = container.children[i];\n\n                if (element.constructor === type) {\n                    points.push(element);\n                } else if (element.children && element.children.length) {\n                    points = points.concat(this$1$1._getAllPointsOfType(element, type));\n                }\n            }\n\n            return points;\n        },\n\n        _updateHoveredPoint: function(point, e) {\n            var hoveredPoint = this._hoveredPoint;\n\n            if (hoveredPoint && hoveredPoint !== point) {\n                hoveredPoint.out(this, e);\n                this._hoveredPoint = null;\n            }\n\n            if (point && hoveredPoint !== point && point.over) {\n                this._hoveredPoint = point;\n                point.over(this, e);\n            }\n        },\n\n        _updateDrilldownPoint: function(point) {\n            if (!point || !point.series) {\n                return;\n            }\n\n            var ref = SeriesBinder.current.bindPoint(point.series, null, point.dataItem);\n            var fields = ref.fields;\n            if (fields.drilldown) {\n                this._drilldownState = { cursor: this.element.style.cursor };\n                this.element.style.cursor = 'pointer';\n            }\n        },\n\n        _resetDrilldownPoint: function() {\n            if (this._drilldownState) {\n                this.element.style.cursor = this._drilldownState.cursor;\n                this._drilldownState = null;\n            }\n        },\n\n        _startDrilldown: function(point) {\n            if (!point || !point.series) {\n                return;\n            }\n\n            var series = point.series;\n            var ref = SeriesBinder.current.bindPoint(series, null, point.dataItem);\n            var fields = ref.fields;\n            var value = fields.drilldown;\n            if (value) {\n                var args = { series: series, point: point, value: value, sender: this };\n                this.trigger(DRILLDOWN, args);\n            }\n        },\n\n        _updateSeriesOpacity: function(point, resetOpacity) {\n            var this$1$1 = this;\n\n            var plotArea = this._plotArea;\n            var length = plotArea.series.length;\n\n            for (var i = 0; i < length; i++) {\n                var currSeries = plotArea.series[i];\n                var defaultOpacity = this$1$1._getDefaultOpacityForSeries(currSeries);\n                var inactiveOpacity = this$1$1._getInactiveOpacityForSeries(currSeries);\n\n                if (!resetOpacity && currSeries !== point.series) {\n                    currSeries.defaultOpacity = defaultOpacity;\n                    currSeries.opacity = inactiveOpacity;\n\n                    if (currSeries.line) {\n                        currSeries.line.opacity = inactiveOpacity;\n                    }\n                } else {\n                    currSeries.opacity = defaultOpacity;\n\n                    if (currSeries.line) {\n                        currSeries.line.opacity = defaultOpacity;\n                    }\n                }\n            }\n        },\n\n        _applySeriesOpacity: function(elements, activeSeries, reset, series) {\n            var this$1$1 = this;\n\n            for (var i = 0; i < elements.length; i++) {\n                var element = elements[i];\n                var currSeries = element.series || series;\n                var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;\n\n                if (shouldHighlight && element.visual) {\n                    var opacity = series ? series.opacity : element.series.opacity;\n                    if (currSeries !== activeSeries || reset) {\n                        element.visual.opacity(reset ? 1 : opacity);\n                    }\n                }\n\n                if (element.children && element.children.length) {\n                    this$1$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);\n                }\n            }\n        },\n\n        _chartInstanceFromPoint: function(point) {\n            var chartInstance = point.parent;\n\n            while (chartInstance && !chartInstance.plotArea) {\n                chartInstance = chartInstance.parent;\n            }\n\n            return chartInstance;\n        },\n\n        _showInactiveOpacity: function(point) {\n            var multipleSeries = this._plotArea.series.length > 1;\n            var hasInactiveOpacity = this._hasInactiveOpacity();\n\n            if (hasInactiveOpacity) {\n                this._displayInactiveOpacity(point, multipleSeries);\n            } else {\n                this._highlight.show(point);\n            }\n        },\n\n        _hideInactiveOpacity: function(point) {\n            var multipleSeries = this._plotArea.series.length > 1;\n            var hasInactiveOpacity = this._hasInactiveOpacity();\n            if (hasInactiveOpacity) {\n                if (multipleSeries && this._activeChartInstance) {\n                    this._updateSeriesOpacity(point, true);\n                    this._applySeriesOpacity(this._activeChartInstance.children, null, true);\n                    this._activeChartInstance = null;\n                }\n                this._highlight && this._highlight.hide();\n                this._activePoint = null;\n            }\n        },\n\n        _hasInactiveOpacity: function() {\n            var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== undefined;\n            var hasInactiveOpacity = this.options.series.filter(function (s) { return s.highlight.inactiveOpacity !== undefined; } ).length > 0;\n            return hasDefaultInactiveOpacity || hasInactiveOpacity;\n        },\n\n        _getInactiveOpacityForSeries: function(series) {\n            var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;\n            var seriesInactiveOpacity = series.highlight.inactiveOpacity;\n            return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || datavizConstants.DEFAULT_SERIES_OPACITY;\n        },\n\n        _getDefaultOpacityForSeries: function(series) {\n            return series.defaultOpacity || series.opacity || datavizConstants.DEFAULT_SERIES_OPACITY;\n        },\n\n        _mouseover: function(e) {\n            var point = this._startHover(e.element, e.originalEvent);\n\n            if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {\n                this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);\n                var obj;\n                bindEvents(document, ( obj = {}, obj[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj ));\n            }\n        },\n\n        _mouseMoveTracking: function(e) {\n            var ref = this;\n            var options = ref.options;\n            var tooltip = ref._tooltip;\n            var highlight = ref._highlight;\n            var point = ref._activePoint;\n            var coords = this._eventCoordinates(e);\n\n            if (this._plotArea.box.containsPoint(coords)) {\n                if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\n                    var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\n                    if (seriesPoint && seriesPoint !== point) {\n                        this._activePoint = seriesPoint;\n\n                        if (!seriesPoint.hover(this, e)) {\n                            var tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);\n                            if (tooltipOptions.visible) {\n                                tooltip.show(seriesPoint);\n                            }\n\n                            highlight.show(seriesPoint);\n                        }\n                    }\n                }\n            } else {\n                var obj;\n                unbindEvents(document, ( obj = {}, obj[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj ));\n                this._unsetActivePoint();\n                this._clearFocusedElement();\n                this._mouseMoveTrackHandler = null;\n\n                this._hideInactiveOpacity(point);\n            }\n        },\n\n        _mousemove: function(e) {\n            var coords = this._eventCoordinates(e);\n            var plotArea = this._plotArea;\n\n            this._trackCrosshairs(coords);\n\n            if (plotArea.hover) {\n                var overPlotArea = plotArea.backgroundContainsPoint(coords);\n                if (overPlotArea) {\n                    this._plotAreaHovered = true;\n                    this._plotArea.hover(this, e);\n                } else if (this._plotAreaHovered && !overPlotArea) {\n                    this._plotAreaHovered = false;\n                    this.trigger(PLOT_AREA_LEAVE);\n                }\n            }\n\n            if (this._sharedTooltip()) {\n                this._trackSharedTooltip(coords, e);\n            }\n        },\n\n        _trackCrosshairs: function(coords) {\n            var crosshairs = this._plotArea.crosshairs;\n\n            for (var i = 0; i < crosshairs.length; i++) {\n                var current = crosshairs[i];\n\n                if (current.box.containsPoint(coords)) {\n                    current.showAt(coords);\n                } else {\n                    current.hide();\n                }\n            }\n        },\n\n        _trackSharedTooltip: function(coords, e, toggle) {\n            if (this._suppressHover) {\n                return;\n            }\n\n            var ref = this;\n            var tooltipOptions = ref.options.tooltip;\n            var plotArea = ref._plotArea;\n            var categoryAxis = ref._plotArea.categoryAxis;\n            var tooltip = ref._tooltip;\n            var highlight = ref._highlight;\n\n            if (plotArea.backgroundContainsPoint(coords)) {\n                var index = categoryAxis.pointCategoryIndex(coords);\n                if (index !== this._tooltipCategoryIx || (!this._sharedHighlight && toggle)) {\n                    var points = plotArea.pointsByCategoryIndex(index);\n                    var pointArgs = points.map(function(point) {\n                        return point.eventArgs(e);\n                    });\n                    var hoverArgs = pointArgs[0] || {};\n                    hoverArgs.categoryPoints = pointArgs;\n\n                    if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\n                        if (tooltipOptions.visible) {\n                            tooltip.showAt(points, coords);\n                        }\n\n                        highlight.show(points);\n\n                        this._sharedHighlight = true;\n                    } else {\n                        tooltip.hide();\n                    }\n\n                    this._tooltipCategoryIx = index;\n                } else if (toggle && this._sharedHighlight) {\n                    highlight.hide();\n                    tooltip.hide();\n                    this._sharedHighlight = false;\n                }\n            } else if (this._sharedHighlight) {\n                highlight.hide();\n                tooltip.hide();\n                this._tooltipCategoryIx = null;\n                this._sharedHighlight = false;\n            }\n        },\n\n        hideElements: function(options) {\n            var plotArea = this._plotArea;\n            this._mousemove.cancel();\n\n            plotArea.hideCrosshairs();\n\n            this._unsetActivePoint(options);\n        },\n\n        _unsetActivePoint: function(options) {\n            var ref = this;\n            var highlight = ref._highlight;\n\n            this._activePoint = null;\n            this._hoveredPoint = null;\n\n            if (!options || !options.keepTooltipOpen) {\n                this._hideTooltip();\n            }\n\n            this._tooltipCategoryIx = null;\n            this._sharedHighlight = false;\n\n            if (highlight) {\n                highlight.hide();\n            }\n        },\n\n        _deferRedraw: function() {\n            this._redraw();\n        },\n\n        _clearRedrawTimeout: function() {\n            if (this._redrawTimeout) {\n                clearInterval(this._redrawTimeout);\n                this._redrawTimeout = null;\n            }\n        },\n\n        bindCategories: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var definitions = [].concat(options.categoryAxis);\n\n            for (var axisIx = 0; axisIx < definitions.length; axisIx++) {\n                var axis = definitions[axisIx];\n                if (axis.autoBind !== false) {\n                    this$1$1.bindCategoryAxisFromSeries(axis, axisIx);\n                }\n            }\n        },\n\n        bindCategoryAxisFromSeries: function(axis, axisIx) {\n            var this$1$1 = this;\n\n            var uniqueCategories = new Set();\n            var seriesOnAxis = this.options.series.filter(function (series) { return series.categoryAxis === axis.name || (!series.categoryAxis && axisIx === 0); });\n            var hasCategoryBinding = seriesOnAxis.some(function (series) { return Boolean(series.categoryField); });\n            var seriesWithData = seriesOnAxis.filter(function (series) { return series.data && series.data.length > 0; });\n            var categorySamples = seriesWithData.map(function (series) { return SeriesBinder.current.bindPoint(series, 0).fields.category; });\n            var dateAxis = categorySamples.reduce(function (result, firstCategory) { return result || isDateAxis(axis, firstCategory); }, false);\n            var seriesWithBinding = seriesWithData.filter(function (series, seriesIx) { return series.categoryField || defined(categorySamples[seriesIx]); });\n\n            seriesWithBinding.forEach(function (series) { return series.data.forEach(function (row, index) {\n                var category = SeriesBinder.current.bindPoint(series, index).fields.category;\n                if (dateAxis) {\n                    var date = parseDateCategory(category, row, this$1$1.chartService.intl);\n                    category = date ? date.getTime() : undefined;\n                }\n\n                uniqueCategories.add(category);\n            }); });\n\n            if (uniqueCategories.size > 0) {\n                var categories = Array.from(uniqueCategories.values());\n                if (dateAxis) {\n                    categories = categories.sort().map(function (time) { return time && new Date(time); });\n                }\n\n                axis.categories = categories;\n            } else if (hasCategoryBinding) {\n                axis.categories = [];\n            }\n        },\n\n        _isBindable: function(series) {\n            var valueFields = SeriesBinder.current.valueFields(series);\n            var result = true;\n\n            for (var i = 0; i < valueFields.length; i++) {\n                var field = valueFields[i];\n                if (field === VALUE) {\n                    field = \"field\";\n                } else {\n                    field = field + \"Field\";\n                }\n\n                if (!defined(series[field])) {\n                    result = false;\n                    break;\n                }\n            }\n\n            return result;\n        },\n\n        _noTransitionsRedraw: function() {\n            var options = this.options;\n            var transitionsState;\n\n            if (options.transitions !== false) {\n                options.transitions = false;\n                transitionsState = true;\n            }\n\n            this._redraw();\n\n            if (transitionsState) {\n                options.transitions = true;\n            }\n        },\n\n        _legendItemHover: function(seriesIndex, pointIndex) {\n            this._showSeriesInactiveOpacity(seriesIndex, pointIndex);\n        },\n\n        _showSeriesInactiveOpacity: function(seriesIndex, pointIndex) {\n            var ref = this;\n            var plotArea = ref._plotArea;\n            var highlight = ref._highlight;\n            var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n            var items;\n\n            if (inArray(currentSeries.type, [ PIE, DONUT, FUNNEL, PYRAMID ])) {\n                items = plotArea.findPoint(function(point) {\n                    return point.series.index === seriesIndex && point.index === pointIndex;\n                });\n            } else {\n                items = plotArea.pointsBySeriesIndex(seriesIndex);\n            }\n\n            if (this._hasInactiveOpacity() && currentSeries.visible && items) {\n                var multipleSeries = plotArea.series.length > 1;\n                var point = items.length ? items[0] : items;\n\n                this._displayInactiveOpacity(point, multipleSeries, items);\n            } else {\n                highlight.show(items);\n            }\n        },\n\n        _shouldAttachMouseMove: function() {\n            return this._plotArea.crosshairs.length || (this._tooltip && this._sharedTooltip()) || this.requiresHandlers([ PLOT_AREA_HOVER, PLOT_AREA_LEAVE ]);\n        },\n\n        updateMouseMoveHandler: function() {\n            var obj;\n            unbindEvents(this.element, ( obj = {}, obj[ MOUSEMOVE ] = this._mousemove, obj ));\n\n            if (this._shouldAttachMouseMove()) {\n                var obj$1;\n                bindEvents(this.element, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mousemove, obj$1 ));\n            }\n        },\n\n        applyOptions: function(options, theme) {\n            clearMissingValues(this._originalOptions, options);\n            this._originalOptions = deepExtend(this._originalOptions, options);\n            this.options = deepExtend({}, this._originalOptions);\n\n            if (theme) {\n                this._theme = theme;\n                this.chartService.theme = theme;\n            }\n            this._initTheme(this.options, this._theme);\n\n            this._toggleDragZoomEvents();\n        },\n\n        setOptions: function(options, theme) {\n            this.applyOptions(options, theme);\n            this.bindCategories();\n            this.redraw();\n            this.updateMouseMoveHandler();\n        },\n\n        setDirection: function(rtl) {\n            this.chartService.rtl = Boolean(rtl);\n            if (this.surface && this.surface.type === 'svg') {\n                this._destroySurface();\n            }\n        },\n\n        setIntlService: function(intl) {\n            this.chartService.intl = intl;\n        },\n\n        noTransitionsRedraw: function() {\n            this._noTransitionsRedraw();\n        },\n\n        destroy: function() {\n            this._destroyed = true;\n\n            var obj;\n            unbindEvents(this.element, ( obj = {}, obj[ CONTEXTMENU ] = this._clickHandler, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj[ MOUSEMOVE ] = this._mousemove, obj[ MOUSELEAVE ] = this._mouseleaveHandler, obj[ KEYDOWN ] = this._keydownHandler, obj[ FOCUS ] = this._focusHandler, obj[ BLUR] = this._blurHandler, obj ));\n\n            if (this.domEvents) {\n                this.domEvents.destroy();\n                delete this.domEvents;\n            }\n\n            if (this._mouseMoveTrackHandler) {\n                var obj$1;\n                unbindEvents(document, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj$1 ));\n            }\n\n            this._focusState = null;\n\n            this._destroyView();\n\n            this._destroySurface();\n\n            this._clearRedrawTimeout();\n        },\n\n        _destroySurface: function() {\n            var surface = this.surface;\n            if (surface) {\n                surface.unbind(\"mouseenter\", this._surfaceMouseenterHandler);\n                surface.unbind(\"mouseleave\", this._surfaceMouseleaveHandler);\n                surface.destroy();\n\n                this.surface = null;\n            }\n        },\n\n        _destroySelections: function() {\n            var selections = this._selections;\n\n            if (selections) {\n                while (selections.length > 0) {\n                    selections.shift().destroy();\n                }\n            }\n        },\n\n        _destroyView: function() {\n            var model = this._model;\n\n            if (model) {\n                model.destroy();\n                this._model = null;\n            }\n\n            this._unsetActivePoint();\n            this._clearFocusedElement();\n            this._resetDrilldownPoint();\n            this._destroySelections();\n\n            if (this._tooltip) {\n                this._tooltip.destroy();\n            }\n\n            if (this._highlight) {\n                this._highlight.destroy();\n            }\n\n            if (this._zoomSelection) {\n                this._zoomSelection.destroy();\n                delete this._zoomSelection;\n            }\n\n            if (this._pannable) {\n                this._pannable.destroy();\n                delete this._pannable;\n            }\n\n            if (this._mousewheelZoom) {\n                this._mousewheelZoom.destroy();\n                delete this._mousewheelZoom;\n            }\n        }\n    });\n\n    function resolveAxisAliases(options) {\n        var aliases = AXIS_NAMES;\n\n        for (var idx = 0; idx < aliases.length; idx++) {\n            var alias = aliases[idx] + \"Axes\";\n            if (options[alias]) {\n                options[aliases[idx] + \"Axis\"] = options[alias];\n                delete options[alias];\n            }\n        }\n    }\n\n    function pointByCategoryName(points, name) {\n        if (points) {\n            for (var idx = 0; idx < points.length; idx++) {\n                if (points[idx].category === name) {\n                    return [ points[idx] ];\n                }\n            }\n        }\n    }\n\n    function applyAxisDefaults(options, themeOptions) {\n        var themeAxisDefaults = ((themeOptions || {}).axisDefaults) || {};\n        var axisName, axisDefaults, axes;\n\n        function mapAxisOptions(axisOptions) {\n            var axisColor = (axisOptions || {}).color || axisDefaults.color;\n            var result = deepExtend({},\n                themeAxisDefaults,\n                themeAxisDefaults[axisName],\n                axisDefaults,\n                axisDefaults[axisName], {\n                    line: { color: axisColor },\n                    labels: { color: axisColor },\n                    title: { color: axisColor }\n                },\n                axisOptions\n            );\n\n            delete result[axisName];\n\n            return result;\n        }\n\n        for (var idx = 0; idx < AXIS_NAMES.length; idx++) {\n            axisName = AXIS_NAMES[idx] + \"Axis\";\n            axisDefaults = options.axisDefaults || {};\n            axes = [].concat(options[axisName]);\n\n            axes = axes.map(mapAxisOptions);\n\n            options[axisName] = axes.length > 1 ? axes : axes[0];\n        }\n    }\n\n    function applySeriesDefaults(options, themeOptions) {\n        var series = options.series;\n        var seriesLength = series.length;\n        var seriesDefaults = options.seriesDefaults;\n        var commonDefaults = deepExtend({}, options.seriesDefaults);\n        var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\n        var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\n\n        cleanupNestedSeriesDefaults(commonDefaults);\n        cleanupNestedSeriesDefaults(commonThemeDefaults);\n\n        for (var i = 0; i < seriesLength; i++) {\n            var seriesType = series[i].type || options.seriesDefaults.type;\n\n            var baseOptions = deepExtend(\n                { data: [] },\n                commonThemeDefaults,\n                themeSeriesDefaults[seriesType],\n                { tooltip: options.tooltip },\n                commonDefaults,\n                seriesDefaults[seriesType]\n            );\n\n            series[i]._defaults = baseOptions;\n            series[i] = deepExtend({}, baseOptions, series[i]);\n            series[i].data = series[i].data || [];\n        }\n    }\n\n    function cleanupNestedSeriesDefaults(seriesDefaults) {\n        delete seriesDefaults.bar;\n        delete seriesDefaults.column;\n        delete seriesDefaults.rangeColumn;\n        delete seriesDefaults.line;\n        delete seriesDefaults.verticalLine;\n        delete seriesDefaults.pie;\n        delete seriesDefaults.donut;\n        delete seriesDefaults.area;\n        delete seriesDefaults.verticalArea;\n        delete seriesDefaults.scatter;\n        delete seriesDefaults.scatterLine;\n        delete seriesDefaults.bubble;\n        delete seriesDefaults.candlestick;\n        delete seriesDefaults.ohlc;\n        delete seriesDefaults.boxPlot;\n        delete seriesDefaults.bullet;\n        delete seriesDefaults.verticalBullet;\n        delete seriesDefaults.polarArea;\n        delete seriesDefaults.polarLine;\n        delete seriesDefaults.radarArea;\n        delete seriesDefaults.radarLine;\n        delete seriesDefaults.waterfall;\n    }\n\n    function axisRanges(axes) {\n        var ranges = {};\n\n        for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i];\n            var axisName = axis.options.name;\n            if (axisName) {\n                ranges[axisName] = axis.range();\n            }\n        }\n\n        return ranges;\n    }\n\n    var DATA_FIELDS = [ 'data', 'categories' ];\n\n    function clearMissingValues(originalOptions, options) {\n        for (var field in options) {\n            if (!inArray(field, DATA_FIELDS) && dataviz.hasOwnProperty(options, field)) {\n                var fieldValue = options[field];\n                var originalValue = originalOptions[field];\n                if (defined(originalValue)) {\n                    var nullValue = fieldValue === null;\n                    if ((nullValue || !defined(fieldValue))) {\n                        delete originalOptions[field];\n                        if (nullValue) {\n                            delete options[field];\n                        }\n                    } else if (originalValue && isObject(fieldValue)) {\n                        if (isObject(originalValue)) {\n                            clearMissingValues(originalValue, fieldValue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function triggerPaneRender(panes) {\n        for (var idx = 0; idx < panes.length; idx++) {\n            panes[idx].notifyRender();\n        }\n    }\n\n    setDefaultOptions(Chart, {\n        renderAs: \"\",\n        chartArea: {},\n        legend: {\n            visible: true,\n            labels: {},\n            accessibility: {\n                highlight: {\n                    border: {\n                        opacity: 1,\n                        color: BLACK,\n                        width: 2\n                    }\n                }\n            }\n        },\n        categoryAxis: {},\n        seriesDefaults: {\n            type: COLUMN,\n            data: [],\n            highlight: {\n                visible: true\n            },\n            labels: {},\n            negativeValues: {\n                visible: false\n            },\n            accessibility: {\n                highlight: {\n                    border: {\n                        opacity: 1,\n                        width: 2\n                    },\n                    zIndex: 200\n                }\n            }\n        },\n        series: [],\n        seriesColors: null,\n        tooltip: {\n            visible: false\n        },\n        transitions: true,\n        valueAxis: {},\n        plotArea: {},\n        title: {},\n        xAxis: {},\n        yAxis: {},\n        panes: [ {} ],\n        pannable: false,\n        zoomable: false\n    });\n\n    kendo.deepExtend(kendo.dataviz, {\n        constants: constants,\n        Aggregates: Aggregates,\n        AreaChart: AreaChart,\n        AreaSegment: AreaSegment,\n        AxisGroupRangeTracker: AxisGroupRangeTracker,\n        Bar: Bar,\n        BarChart: BarChart,\n        BarLabel: BarLabel,\n        BoxPlotChart: BoxPlotChart,\n        BoxPlot: BoxPlot,\n        BubbleChart: BubbleChart,\n        Bullet: Bullet,\n        BulletChart: BulletChart,\n        CandlestickChart: CandlestickChart,\n        Candlestick: Candlestick,\n        CategoricalChart: CategoricalChart,\n        CategoricalErrorBar: CategoricalErrorBar,\n        CategoricalPlotArea: CategoricalPlotArea,\n        Chart: Chart,\n        ChartContainer: ChartContainer,\n        ClipAnimation: ClipAnimation,\n        ClusterLayout: ClusterLayout,\n        Crosshair: Crosshair,\n        CrosshairTooltip: CrosshairTooltip,\n        DefaultAggregates: DefaultAggregates,\n        DonutChart: DonutChart,\n        DonutPlotArea: DonutPlotArea,\n        DonutSegment: DonutSegment,\n        ErrorBarBase: ErrorBarBase,\n        ErrorRangeCalculator: ErrorRangeCalculator,\n        Highlight: Highlight,\n        SharedTooltip: SharedTooltip,\n        Legend: Legend,\n        LegendItem: LegendItem,\n        LegendLayout: LegendLayout,\n        LineChart: LineChart,\n        LinePoint: LinePoint,\n        LineSegment: LineSegment,\n        Pane: Pane,\n        PieAnimation: PieAnimation,\n        PieChart: PieChart,\n        PieChartMixin: PieChartMixin,\n        PiePlotArea: PiePlotArea,\n        PieSegment: PieSegment,\n        PlotAreaBase: PlotAreaBase,\n        PlotAreaEventsMixin: PlotAreaEventsMixin,\n        PlotAreaFactory: PlotAreaFactory,\n        PointEventsMixin: PointEventsMixin,\n        RangeBar: RangeBar,\n        RangeBarChart: RangeBarChart,\n        RangeAreaPoint: RangeAreaPoint,\n        RangeAreaChart: RangeAreaChart,\n        ScatterChart: ScatterChart,\n        ScatterErrorBar: ScatterErrorBar,\n        ScatterLineChart: ScatterLineChart,\n        Selection: Selection,\n        SeriesAggregator: SeriesAggregator,\n        SeriesBinder: SeriesBinder,\n        SplineSegment: SplineSegment,\n        SplineAreaSegment: SplineAreaSegment,\n        StackWrap: StackWrap,\n        Tooltip: Tooltip,\n        OHLCChart: OHLCChart,\n        OHLCPoint: OHLCPoint,\n        WaterfallChart: WaterfallChart,\n        WaterfallSegment: WaterfallSegment,\n        XYPlotArea: XYPlotArea,\n        MousewheelZoom: MousewheelZoom,\n        ZoomSelection: ZoomSelection,\n        Pannable: Pannable,\n        ChartAxis: ChartAxis,\n        ChartPane: ChartPane,\n        ChartPlotArea: ChartPlotArea,\n        findAxisByName: findAxisByName,\n        anyHasZIndex: anyHasZIndex,\n        appendIfNotNull: appendIfNotNull,\n        areNumbers: areNumbers,\n        bindSegments: bindSegments,\n        categoriesCount: categoriesCount,\n        countNumbers: countNumbers,\n        equalsIgnoreCase: equalsIgnoreCase,\n        evalOptions: evalOptions,\n        filterSeriesByType: filterSeriesByType,\n        parseDateCategory: parseDateCategory,\n        getField: getField,\n        hasGradientOverlay: hasGradientOverlay,\n        hasValue: hasValue,\n        isDateAxis: isDateAxis,\n        segmentVisible: segmentVisible,\n        singleItemOrArray: singleItemOrArray,\n        createOutOfRangePoints: createOutOfRangePoints\n    });\n\n    })(window.kendo.jQuery);\n\n    (function($, undefined$1) {\n\n        const kendo = window.kendo;\n        const dataviz = kendo.dataviz;\n        const Widget = kendo.ui.Widget;\n\n        const ChartBreadcrumb = Widget.extend({\n            init: function(element, options) {\n                Widget.fn.init.call(this, element, options);\n\n                if (!options.chart) {\n                    throw new Error('ChartBreadcrumb: No Chart instance supplied as `options.chart`');\n                }\n\n                this._attachChartEvents();\n                this._renderBreadcrumb();\n\n                kendo.notify(this, dataviz.ui);\n            },\n\n            events: [],\n\n            options: {\n                name: \"ChartBreadcrumb\",\n                rootItem: {\n                    type: 'rootitem',\n                    icon: 'home',\n                    text: 'Home',\n                    showIcon: true\n                }\n            },\n\n            destroy: function() {\n                if (this.breadcrumb) {\n                    this.breadcrumb.destroy();\n                    this.breadcrumb = null;\n                }\n\n                if (this.chart) {\n                    this.chart.unbind('drilldown', this._onChartDrilldown);\n                    this.chart.unbind('drilldownLevelChange', this._onChartDrilldownLevelChange);\n                    this.chart = null;\n                }\n\n                Widget.fn.destroy.call(this);\n            },\n\n            _attachChartEvents(deferred) {\n                const options = this.options;\n\n                if (typeof options.chart.resetDrilldownLevel === 'function') {\n                    this.chart = options.chart;\n                } else if (typeof options.chart === 'string') {\n                    this.chart = $(options.chart).getKendoChart() || $('#' + options.chart).getKendoChart();\n\n                    if (!this.chart && !deferred) {\n                        setTimeout(() => this._attachChartEvents(true));\n                        return;\n                    }\n                } else {\n                    throw new Error('ChartBreadcrumb: `options.chart` must be a Chart instance, element ID or a selector');\n                }\n\n                this._onChartDrilldown = this._onChartDrilldown.bind(this);\n                this.chart.bind('drilldown', this._onChartDrilldown);\n\n                this._onChartDrilldownLevelChange = this._onChartDrilldownLevelChange.bind(this);\n                this.chart.bind('drilldownLevelChange', this._onChartDrilldownLevelChange);\n            },\n\n            _renderBreadcrumb: function() {\n                const breadcrumbElement = $('<nav />');\n                this.element.append(breadcrumbElement);\n                this.breadcrumb = new kendo.ui.Breadcrumb(breadcrumbElement, {\n                    items: [this.options.rootItem]\n                });\n\n                this.breadcrumb.bind('click', e => this._onBreadcrumbClick(e));\n            },\n\n            _onBreadcrumbClick: function(e) {\n                if (!this.breadcrumb || !this.chart) {\n                    return;\n                }\n\n                let items = this.breadcrumb.items();\n                const level = items.findIndex((item) => item === e.item);\n\n                const chart = this.chart;\n                chart.resetDrilldownLevel(level);\n            },\n\n            _onChartDrilldown: function(e) {\n                if (!this.breadcrumb || e.isDefaultPrevented()) {\n                    return;\n                }\n\n                this.breadcrumb.items([\n                    ...this.breadcrumb.items(),\n                    { type: 'item', text: e.point.category }\n                ]);\n            },\n\n            _onChartDrilldownLevelChange: function(e) {\n                if (!this.breadcrumb) {\n                    return;\n                }\n\n                let items = this.breadcrumb.items();\n                items = items.slice(0, e.level + 1);\n                this.breadcrumb.items(items);\n            }\n        });\n\n        dataviz.ui.plugin(ChartBreadcrumb);\n\n    })(window.kendo.jQuery);\n\n    (function($, undefined$1) {\n\n        var NS = \".kendoChart\";\n        var kendo = window.kendo;\n        var Class = kendo.Class;\n        var outerWidth = kendo._outerWidth;\n        var outerHeight = kendo._outerHeight;\n        var dataviz = kendo.dataviz;\n        var constants = dataviz.constants;\n        var KendoChart = dataviz.Chart;\n        var SeriesBinder = dataviz.SeriesBinder;\n        var Widget = kendo.ui.Widget;\n        var DataSource = kendo.data.DataSource;\n        var deepExtend = kendo.deepExtend;\n        var defined = dataviz.defined;\n        var getField = dataviz.getField;\n        var InstanceObserver = dataviz.InstanceObserver;\n        var inArray = dataviz.inArray;\n        var services = dataviz.services;\n        var isArray = Array.isArray;\n        var extend = $.extend;\n        var template = kendo.template;\n        var encode = kendo.htmlEncode;\n\n        var MOUSELEAVE_NS = \"mouseleave\" + NS;\n        var AXIS_LABEL_CLICK = constants.AXIS_LABEL_CLICK;\n        var LEGEND_ITEM_CLICK = constants.LEGEND_ITEM_CLICK;\n        var LEGEND_ITEM_HOVER = constants.LEGEND_ITEM_HOVER;\n        var LEGEND_ITEM_LEAVE = constants.LEGEND_ITEM_LEAVE;\n        var SERIES_CLICK = constants.SERIES_CLICK;\n        var SERIES_HOVER = constants.SERIES_HOVER;\n        var SERIES_OVER = constants.SERIES_OVER;\n        var SERIES_LEAVE = constants.SERIES_LEAVE;\n        var PANE_RENDER = constants.PANE_RENDER;\n        var PLOT_AREA_CLICK = constants.PLOT_AREA_CLICK;\n        var PLOT_AREA_HOVER = constants.PLOT_AREA_HOVER;\n        var PLOT_AREA_LEAVE = constants.PLOT_AREA_LEAVE;\n        var DRAG = constants.DRAG;\n        var DRAG_END = constants.DRAG_END;\n        var DRAG_START = constants.DRAG_START;\n        var DRILLDOWN = constants.DRILLDOWN;\n        var DRILLDOWN_LEVEL_CHANGE = \"drilldownLevelChange\";\n        var ZOOM_START = constants.ZOOM_START;\n        var ZOOM = constants.ZOOM;\n        var ZOOM_END = constants.ZOOM_END;\n        var SELECT_START = constants.SELECT_START;\n        var SELECT = constants.SELECT;\n        var SELECT_END = constants.SELECT_END;\n        var RENDER = constants.RENDER;\n        var NOTE_CLICK = constants.NOTE_CLICK;\n        var NOTE_HOVER = constants.NOTE_HOVER;\n        var NOTE_LEAVE = constants.NOTE_LEAVE;\n        var DOCUMENT_ELEMENT = $(document.documentElement);\n\n        var CHANGE = \"change\";\n        var DATABOUND = \"dataBound\";\n        var LEAVE = \"leave\";\n        var MOUSEDOWN = \"down\";\n\n        var VALUE = constants.VALUE;\n        var PIE = constants.PIE;\n        var DONUT = constants.DONUT;\n        var FUNNEL = constants.FUNNEL;\n\n        var Observable = kendo.Observable;\n        var TOOLTIP_ANIMATION_DURATION = 150;\n        var TOOLTIP_SHOW_DELAY = 100;\n        var TOOLTIP_INVERSE = \"k-chart-tooltip-inverse\";\n        var SHARED_TOOLTIP_CLASS = \"k-chart-shared-tooltip\";\n        var RTL = \"rtl\";\n\n        services.DomEventsBuilder.register({\n            create: function(element, events) {\n                 return new kendo.UserEvents(element, deepExtend({\n                     global: true,\n                     multiTouch: true,\n                     fastTap: true\n                 }, events));\n            }\n        });\n\n        var ChartInstanceObserver = InstanceObserver.extend({\n            handlerMap: {\n                showTooltip: '_showTooltip',\n                hideTooltip: '_hideTooltip',\n                legendItemClick: '_onLegendItemClick',\n                render: '_onRender',\n                init: '_onInit',\n                drilldown: '_onDrilldown'\n            }\n        });\n\n        var Chart = Widget.extend({\n            init: function(element, userOptions) {\n                var dataSource;\n\n                kendo.destroy(element);\n\n                Widget.fn.init.call(this, element);\n\n                if (userOptions) {\n                    dataSource = userOptions.dataSource;\n                    delete userOptions.dataSource;\n                }\n\n                this.options = deepExtend({}, this.options, userOptions);\n\n                this.wrapper = this.element;\n                this._attachEvents();\n\n                if (userOptions) {\n                    userOptions.dataSource = dataSource;\n                }\n\n                this._seriesVisibility = new SeriesVisibilityState();\n\n                this.bind(this.events, this.options);\n                this._initDataSource(userOptions);\n\n                this._drilldownState = [];\n\n                kendo.notify(this, dataviz.ui);\n\n                if (this._showWatermarkOverlay) {\n                    this._showWatermarkOverlay(this.wrapper[0]);\n                }\n            },\n\n            events: [\n                DATABOUND,\n                DRILLDOWN,\n                DRILLDOWN_LEVEL_CHANGE,\n                SERIES_CLICK,\n                SERIES_HOVER,\n                SERIES_OVER,\n                SERIES_LEAVE,\n                AXIS_LABEL_CLICK,\n                LEGEND_ITEM_CLICK,\n                LEGEND_ITEM_HOVER,\n                LEGEND_ITEM_LEAVE,\n                PANE_RENDER,\n                PLOT_AREA_CLICK,\n                PLOT_AREA_HOVER,\n                PLOT_AREA_LEAVE,\n                DRAG_START,\n                DRAG,\n                DRAG_END,\n                ZOOM_START,\n                ZOOM,\n                ZOOM_END,\n                SELECT_START,\n                SELECT,\n                SELECT_END,\n                NOTE_CLICK,\n                NOTE_HOVER,\n                NOTE_LEAVE,\n                RENDER\n            ],\n\n            options: {\n                name: \"Chart\",\n                renderAs: \"\",\n                theme: \"sass\",\n                axisDefaults: {},\n                chartArea: {},\n                legend: {},\n                categoryAxis: {},\n                autoBind: true,\n                seriesDefaults: {},\n                series: [],\n                seriesColors: null,\n                tooltip: {},\n                transitions: true,\n                valueAxis: {},\n                plotArea: {},\n                title: {},\n                xAxis: {},\n                yAxis: {},\n                panes: [{}],\n                pannable: false,\n                zoomable: false\n            },\n\n            items: function() {\n                return $();\n            },\n\n            refresh: function() {\n                var chart = this;\n                var instance = chart._instance;\n                instance.applyDefaults(chart.options);\n                instance.applySeriesColors();\n\n                chart._bindSeries();\n                chart._bindCategories();\n\n                chart.trigger(DATABOUND);\n                chart._redraw();\n            },\n\n            getSize: function() {\n                return kendo.dimensions(this.element);\n            },\n\n            redraw: function(paneName) {\n                this._size = null;\n                this._instance.redraw(paneName);\n            },\n\n            setOptions: function(options) {\n                var chart = this,\n                    dataSource = options.dataSource;\n\n                delete options.dataSource;\n\n                Widget.fn._setEvents.call(chart, options);\n\n                this._instance.applyOptions(options, this._getThemeOptions(options));\n                this.options = this._instance.options;\n                this._tooltip.setOptions(this.options.tooltip);\n                this._seriesVisibility.setOptions(this.options);\n                this._sourceSeries = null;\n\n                if (dataSource) {\n                    chart.setDataSource(dataSource);\n                }\n\n                if (chart._hasDataSource) {\n                    chart._onDataChanged();\n                } else {\n                    chart._bindCategories();\n                    chart.redraw();\n                }\n\n                chart._instance.updateMouseMoveHandler();\n\n            },\n\n            setDataSource: function(dataSource) {\n                var chart = this;\n\n                chart.dataSource.unbind(CHANGE, chart._dataChangeHandler);\n                chart.dataSource = dataSource = DataSource.create(dataSource);\n                chart._hasDataSource = true;\n                chart._hasData = false;\n\n                dataSource.bind(CHANGE, chart._dataChangeHandler);\n\n                if (chart.options.autoBind) {\n                    dataSource.fetch();\n                }\n            },\n\n            destroy: function() {\n                var chart = this,\n                    dataSource = chart.dataSource;\n\n                chart.element.off(NS);\n\n                if (dataSource) {\n                    dataSource.unbind(CHANGE, chart._dataChangeHandler);\n                }\n\n                if (chart._instance) {\n                    chart._instance.destroy();\n                    delete this._instance;\n                }\n\n                if (this._tooltip) {\n                    this._tooltip.destroy();\n                    delete this._tooltip;\n                }\n\n                this._destroyCrosshairTooltips();\n\n                Widget.fn.destroy.call(chart);\n            },\n\n            findPaneByName: function(name) {\n                var panes = this._plotArea.panes;\n\n                for (var idx = 0; idx < panes.length; idx++) {\n                    if (panes[idx].options.name === name) {\n                        return new ChartPane(this, panes[idx]);\n                    }\n                }\n            },\n\n            findPaneByIndex: function(idx) {\n                var panes = this._plotArea.panes;\n                if (panes[idx]) {\n                    return new ChartPane(this, panes[idx]);\n                }\n            },\n\n            findSeries: function(callback) {\n                var plotArea = this._plotArea;\n                var series = plotArea.srcSeries || plotArea.series;\n                for (var idx = 0; idx < series.length; idx++) {\n                    if (callback(series[idx])) {\n                        return new ChartSeries(this, series[idx]);\n                    }\n                }\n            },\n\n            findSeriesByName: function(name) {\n                return this._createSeries({ name: name });\n            },\n\n            findSeriesByIndex: function(index) {\n                return this._createSeries({ index: index });\n            },\n\n            exportVisual: function(options) {\n                var instance = this._instance;\n                if (!instance) {\n                    return;\n                }\n\n                var visual;\n\n                //TO DO: support for setting any options. already available in kendo-charts\n                if (options && (options.width || options.height)) {\n                    var chartArea = instance.options.chartArea;\n                    var originalChartArea = instance._originalOptions.chartArea;\n\n                    deepExtend(chartArea, options);\n\n                    var model = instance._getModel();\n\n                    chartArea.width = originalChartArea.width;\n                    chartArea.height = originalChartArea.height;\n\n                    model.renderVisual();\n\n                    triggerPaneRender(model._plotArea.panes);\n\n                    visual = model.visual;\n                } else {\n                    visual = instance.exportVisual();\n                }\n\n                return visual;\n            },\n\n            resetDrilldownLevel(level) {\n                level = level || 0;\n                const state = this._drilldownState;\n                if (!state || level < 0 || level > state.length - 1) {\n                    return;\n                }\n\n                const args = {\n                    level,\n                    sender: this\n                };\n                this.trigger(DRILLDOWN_LEVEL_CHANGE, args);\n\n                this.options.series = this._drilldownState[level];\n                this._drilldownState = this._drilldownState.slice(0, level);\n\n                this._bindCategories();\n                this._redraw();\n            },\n\n            _createSeries: function(options) {\n                var seriesOptions = this._seriesOptions(options);\n                if (seriesOptions) {\n                    return new ChartSeries(this, seriesOptions);\n                }\n            },\n\n            _seriesOptions: function(options) {\n                var plotArea = this._plotArea;\n                var series = plotArea.srcSeries || plotArea.series;\n                var seriesOptions;\n\n                if (defined(options.index)) {\n                    seriesOptions = series[options.index];\n                } else if (defined(options.name)) {\n                    for (var idx = 0; idx < series.length; idx++) {\n                        if (series[idx].name === options.name) {\n                            seriesOptions = series[idx];\n                            break;\n                        }\n                    }\n                }\n\n                return seriesOptions;\n            },\n\n            _attachEvents: function() {\n                 this.element.on(MOUSELEAVE_NS, this._mouseleave.bind(this));\n            },\n\n            _mouseleave: function(e) {\n                var instance = this._instance;\n                var tooltip = this._tooltip;\n                var target = e.relatedTarget;\n\n                if (!(target && $(target).closest(tooltip.element).length) && instance && !instance.handlingTap) {\n                    instance.hideElements({\n                        keepTooltipOpen: !tooltip.options.autoHide\n                    });\n                }\n            },\n\n            _getThemeOptions: function(userOptions) {\n                var themeName = (userOptions || {}).theme;\n\n                if (themeName && dataviz.SASS_THEMES.indexOf(themeName.toLowerCase()) !== -1) {\n                    return dataviz.autoTheme().chart;\n                }\n\n                if (defined(themeName)) {\n                    var themes = dataviz.ui.themes || {};\n                    var theme = themes[themeName] || themes[themeName.toLowerCase()] || {};\n                    return theme.chart || {};\n                }\n            },\n\n            _initChart: function() {\n                this._createChart(this.options, this._getThemeOptions(this.options));\n                this.options = this._instance.options;\n                this._seriesVisibility.setOptions(this.options);\n            },\n\n            _createChart: function(options, themeOptions) {\n                this._instance = new KendoChart(this.element[0], options, themeOptions, {\n                    observer: new ChartInstanceObserver(this),\n                    sender: this,\n                    rtl: this._isRtl()\n                });\n            },\n\n            _onInit: function(e) {\n                this._instance = e.sender;\n            },\n\n            _initDataSource: function(userOptions) {\n                var chart = this,\n                    dataSource = (userOptions || {}).dataSource;\n\n                chart._dataChangeHandler = chart._onDataChanged.bind(chart);\n\n                chart.dataSource = DataSource\n                    .create(dataSource)\n                    .bind(\"change\", chart._dataChangeHandler);\n\n                chart._bindCategories();\n\n                if (dataSource) {\n                    chart._hasDataSource = true;\n                }\n\n                this._initChart();\n                this._initTooltip();\n\n                if (dataSource) {\n                    if (chart.options.autoBind) {\n                        chart.dataSource.fetch();\n                    }\n                }\n            },\n\n            _destroyCrosshairTooltips: function() {\n                var tooltips = this._crosshairTooltips;\n                if (tooltips) {\n                    for (var key in tooltips) {\n                        tooltips[key].destroy();\n                    }\n                }\n                this._crosshairTooltips = {};\n            },\n\n            _getCrosshairTooltip: function(name, index) {\n                var tooltips = this._crosshairTooltips = this._crosshairTooltips || {};\n                var key = name + index;\n                var tooltip = tooltips[key];\n                if (!tooltip) {\n                    tooltip = tooltips[key] = new CrosshairTooltip(this.element);\n                }\n                return tooltip;\n            },\n\n            _showTooltip: function(e) {\n                if (e.crosshair) {\n                    var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\n                    tooltip.show(e);\n                } else if (this._tooltip) {\n                    this._tooltip.show(e);\n                }\n            },\n\n            _hideTooltip: function(e) {\n                if (e.crosshair) {\n                     var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\n                     tooltip.hide();\n                } else if (this._tooltip) {\n                    this._tooltip.hide();\n                }\n            },\n\n            _onRender: function(e) {\n                this._destroyCrosshairTooltips();\n                this._copyMembers(e.sender);\n                if (!this._hasDataSource || this._hasData || !this.options.autoBind) {\n                    this.trigger(RENDER);\n                }\n            },\n\n            _copyMembers: function(instance) {\n                this.options = instance.options;\n                this._originalOptions = instance._originalOptions;\n                this.surface = instance.surface;\n                this._plotArea = instance._plotArea;\n                this._model = instance._model;\n                this._highlight = instance._highlight;\n                this._selections = instance._selections;\n                this._pannable = instance._pannable;\n                this._zoomSelection = instance._zoomSelection;\n                this._mousewheelZoom = instance._mousewheelZoom;\n            },\n\n            requiresHandlers: function(names) {\n               var events = this._events;\n               for (var idx = 0; idx < names.length; idx++) {\n                   if (defined(events[names[idx]])) {\n                       return true;\n                   }\n               }\n            },\n\n            _initTooltip: function() {\n                this._tooltip = this._createTooltip();\n\n                this._tooltip.bind(LEAVE, this._tooltipleave.bind(this));\n            },\n\n            _onLegendItemClick: function(e) {\n                if (!this.trigger(LEGEND_ITEM_CLICK, e)) {\n                    this._legendItemClick(e.seriesIndex, e.pointIndex);\n                }\n            },\n\n            _legendItemClick: function(seriesIndex, pointIndex) {\n                var chart = this._instance,\n                    plotArea = chart._plotArea,\n                    currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n\n                if (chart._hasInactiveOpacity() && chart._activeChartInstance) {\n                    chart._updateSeriesOpacity(null, true);\n                    chart._applySeriesOpacity(chart._activeChartInstance.children, null, true);\n                    chart._activeChartInstance = null;\n                }\n\n                if ($.inArray(currentSeries.type, [PIE, DONUT, FUNNEL]) >= 0) {\n                    var point = currentSeries.data[pointIndex];\n                    if (point && defined(point.visible)) {\n                        point.visible = !point.visible;\n                    } else {\n                        var pointVisibility = currentSeries.pointVisibility = currentSeries.pointVisibility || {};\n                        var visible = pointVisibility[pointIndex];\n                        pointVisibility[pointIndex] = defined(visible) ? !visible : false;\n                    }\n                } else {\n                    currentSeries.visible = !currentSeries.visible;\n                    this._seriesVisibility.save(currentSeries);\n                }\n\n                chart._noTransitionsRedraw();\n            },\n\n            _createTooltip: function() {\n                return new Tooltip(this.element, extend({}, this.options.tooltip, {\n                    rtl: this._isRtl()\n                }));\n            },\n\n            _tooltipleave: function() {\n                if (this._instance) {\n                    this._instance.hideElements();\n                }\n            },\n\n            _onDrilldown: function(e) {\n                const { series, value } = e;\n\n                if (series.drilldownSeriesFactory) {\n                    const result = series.drilldownSeriesFactory(value);\n\n                    if (!result) {\n                        return;\n                    } else if (result instanceof Promise) {\n                        result.then((resolved) => this._onDrilldownData(e, resolved));\n                    } else {\n                        this._onDrilldownData(e, result);\n                    }\n                } else if (typeof value === 'object') {\n                    this._onDrilldownData(e, value);\n                }\n            },\n\n            _onDrilldownData: function(e, data) {\n                const drilldownSeries = Object.assign({}, e.series, data);\n                const args = {\n                    point: e.point,\n                    series: e.series,\n                    drilldownSeries,\n                    sender: this\n                };\n\n                const prevented = this.trigger(DRILLDOWN, args);\n                if (!prevented) {\n                    this._drilldownState.push(this.options.series);\n\n                    this.options.series = [drilldownSeries];\n                    this._bindCategories();\n                    this._redraw();\n                }\n            },\n\n            _bindData: function(e) {\n                var chart = this,\n                    options = chart.options,\n                    series = chart._sourceSeries || options.series,\n                    seriesIx,\n                    seriesLength = series.length,\n                    data = chart.dataSource.view(),\n                    grouped = (chart.dataSource.group() || []).length > 0,\n                    processedSeries = [],\n                    seriesVisibility = this._seriesVisibility,\n                    currentSeries,\n                    groupedSeries;\n\n                seriesVisibility.read();\n\n                for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n                    currentSeries = series[seriesIx];\n\n                    if (chart._isBindable(currentSeries) && grouped) {\n                        groupedSeries = groupSeries(currentSeries, data);\n                        processedSeries = processedSeries.concat(groupedSeries);\n\n                        seriesVisibility.applyByGroup(groupedSeries, e);\n                    } else {\n                        currentSeries = extend({}, currentSeries);\n                        processedSeries.push(currentSeries);\n\n                        seriesVisibility.applyByIndex(currentSeries, e);\n                    }\n                }\n\n                chart._sourceSeries = series;\n                options.series = processedSeries;\n                this._instance.applySeriesColors();\n\n                chart._bindSeries();\n                chart._bindCategories();\n\n                this._hasData = true;\n            },\n\n            _onDataChanged: function(e) {\n                this._bindData(e);\n\n                this.trigger(DATABOUND);\n                if (this._instance && this._instance.fontLoaded) {\n                    this._redraw();\n                }\n            },\n\n            _bindSeries: function() {\n                var chart = this,\n                    data = chart.dataSource.view(),\n                    series = chart.options.series,\n                    seriesIx,\n                    seriesLength = series.length,\n                    currentSeries,\n                    groupIx,\n                    seriesData;\n\n                for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n                    currentSeries = series[seriesIx];\n\n                    if (chart._isBindable(currentSeries)) {\n                        groupIx = currentSeries._groupIx;\n                        seriesData = defined(groupIx) ? (data[groupIx] || {}).items : data;\n\n                        if (currentSeries.autoBind !== false) {\n                            currentSeries.data = seriesData;\n                        }\n                    }\n                }\n            },\n\n            _bindCategories: function() {\n                var chart = this,\n                    data = chart.dataSource.view() || [],\n                    grouped = (chart.dataSource.group() || []).length > 0,\n                    categoriesData = data,\n                    options = chart.options,\n                    definitions = [].concat(options.categoryAxis),\n                    axisIx,\n                    axis;\n\n                if (grouped) {\n                    if (data.length) {\n                        categoriesData = data[0].items;\n                    }\n                }\n\n                for (axisIx = 0; axisIx < definitions.length; axisIx++) {\n                    axis = definitions[axisIx];\n                    if (axis.autoBind !== false) {\n                        chart._bindCategoryAxis(axis, categoriesData, axisIx);\n                    }\n                }\n            },\n\n            _bindCategoryAxis: function(axis, data, axisIx) {\n                var count = (data || []).length,\n                    categoryIx,\n                    category,\n                    row;\n\n                if (axis.field) {\n                    axis.categories = [];\n                    for (categoryIx = 0; categoryIx < count; categoryIx++) {\n                        row = data[categoryIx];\n\n                        category = getField(axis.field, row);\n                        if (categoryIx === 0) {\n                            axis.categories = [category];\n                            axis.dataItems = [row];\n                        } else {\n                            axis.categories.push(category);\n                            axis.dataItems.push(row);\n                        }\n                    }\n                } else if (this._instance) {\n                    this._instance.bindCategoryAxisFromSeries(axis, axisIx);\n                }\n            },\n\n            _isBindable: function(series) {\n                var valueFields = SeriesBinder.current.valueFields(series),\n                    result = true,\n                    field, i;\n\n                for (i = 0; i < valueFields.length; i++) {\n                    field = valueFields[i];\n                    if (field === VALUE) {\n                        field = \"field\";\n                    } else {\n                        field = field + \"Field\";\n                    }\n\n                    if (!defined(series[field])) {\n                        result = false;\n                        break;\n                    }\n                }\n\n                return result;\n            },\n\n            _isRtl: function() {\n                return kendo.support.isRtl(this.element) && this.element.css(\"direction\") === RTL;\n            }\n        });\n\n        var proxyMembers = [\"getAxis\", \"findAxisByName\", \"plotArea\", \"toggleHighlight\", \"showTooltip\",\n            \"hideTooltip\", \"_resize\", \"_redraw\", \"_noTransitionsRedraw\", \"_legendItemHover\", \"_eventCoordinates\"];\n\n        function createProxyMember(name) {\n            Chart.fn[name] = function() {\n                var instance = this._instance;\n                if (instance) {\n                    return instance[name].apply(instance, arguments);\n                }\n            };\n        }\n\n        for (var idx = 0; idx < proxyMembers.length; idx++) {\n            createProxyMember(proxyMembers[idx]);\n        }\n\n        function groupSeries(series, data) {\n            var result = [],\n                nameTemplate,\n                legacyTemplate = series.groupNameTemplate,\n                groupIx,\n                dataLength = data.length,\n                seriesClone,\n                defaultNameTemplate = ({ group }) => `${defined(series.name) ? group.value + \": \" + series.name : group.value}`;\n\n            if (dataLength === 0) {\n                seriesClone = deepExtend({}, series);\n                seriesClone.visibleInLegend = false;\n                return [seriesClone];\n            }\n\n            if (defined(legacyTemplate)) {\n                kendo.logToConsole(\n                    \"'groupNameTemplate' is obsolete and will be removed in future versions. \" +\n                    \"Specify the group name template as 'series.name'\"\n                );\n\n                if (legacyTemplate) {\n                    nameTemplate = template(legacyTemplate);\n                }\n            } else {\n                nameTemplate = template(series.name || defaultNameTemplate);\n            }\n\n            for (groupIx = 0; groupIx < dataLength; groupIx++) {\n                seriesClone = deepExtend({}, series);\n\n                if (!kendo.isFunction(seriesClone.color)) {\n                    seriesClone.color = undefined$1;\n                }\n\n                seriesClone._groupIx = groupIx;\n                seriesClone._groupValue = data[groupIx].value;\n                result.push(seriesClone);\n\n                if (nameTemplate) {\n                    seriesClone.name = nameTemplate({\n                        series: seriesClone, group: data[groupIx]\n                    });\n                }\n            }\n\n            return result;\n        }\n\n        dataviz.ExportMixin.extend(Chart.fn);\n\n        if (kendo.PDFMixin) {\n            kendo.PDFMixin.extend(Chart.fn);\n        }\n\n        dataviz.ui.plugin(Chart);\n\n        var SeriesVisibilityState = Class.extend({\n            init: function() {\n                this.groups = {};\n                this.index = {};\n                this.options = {};\n            },\n\n            applyByGroup: function(series, e) {\n                if ((e && e.action) || this.options.persistSeriesVisibility) {\n                    for (var idx = 0; idx < series.length; idx++) {\n                        if (this.groups[series[idx]._groupValue] === false) {\n                            series[idx].visible = false;\n                        }\n                    }\n                } else {\n                    this.groups = {};\n                }\n            },\n\n            applyByIndex: function(series, e) {\n                if ((e && e.action) || this.options.persistSeriesVisibility) {\n                    if (this.index[series.index] === false) {\n                        series.visible = false;\n                    }\n                } else {\n                    this.index = {};\n                }\n            },\n\n            save: function(series) {\n                if (!series) {\n                    return;\n                }\n\n                if (this.options.persistSeriesVisibility) {\n                    this.options.series[series.index].visible = series.visible;\n                } else {\n                    this.saveState(series);\n                }\n            },\n\n            setOptions: function(options) {\n                this.options = options;\n                this.groups = {};\n                this.index = {};\n            },\n\n            read: function() {\n                var options = this.options;\n                if (options.persistSeriesVisibility) {\n                    var series = options.series;\n                    for (var idx = 0; idx < series.length; idx++) {\n                        this.saveState(series[idx]);\n                    }\n                }\n            },\n\n            saveState: function(series) {\n                if (defined(series._groupValue)) {\n                    this.groups[series._groupValue] = series.visible;\n                } else {\n                    this.index[series.index] = series.visible;\n                }\n            }\n        });\n\n        var geom = kendo.geometry;\n\n        function normalizeStyle(style) {\n            for (var field in style) {\n                if (style[field] === undefined$1) {\n                    style[field] = '';\n                }\n            }\n\n            return style;\n        }\n\n        var Tooltip = Observable.extend({\n            init: function(chartElement, options) {\n                var tooltip = this;\n\n                Observable.fn.init.call(tooltip);\n\n                this.setOptions(options);\n\n                tooltip.chartElement = chartElement;\n\n                tooltip.template = Tooltip.template;\n                if (!tooltip.template) {\n                    tooltip.template = Tooltip.template = ({ autoHide, rtl, font, border, opacity }) =>\n                        `<div class='k-tooltip ${autoHide ? \"k-tooltip-closable\" : \"\"} k-chart-tooltip ${rtl ? \"k-rtl\" : \"\"}' ` +\n                        `${kendo.attr(\"style-display\")}=\"none\" ${kendo.attr(\"style-position\")}=\"absolute\" ` +\n                        `${kendo.attr(\"style-font\")}=\"${font}\" ${kendo.attr(\"style-opacity\")}=\"${opacity}\" ` +\n                        `${border ? `${kendo.attr(\"style-border\")}=\"${border.width}px solid\" ` : \"\"}` +\n                        `>` +\n                        '<div class=\"k-tooltip-content\"></div>' +\n                        `${autoHide ? '' : '<div class=\"k-tooltip-button\">' + kendo.ui.icon($('<a href=\"#\" title=\"Close\"></a>'), { icon: \"x\" }) + '</div>'}` +\n                        \"</div>\";\n                }\n\n                tooltip.element = $(tooltip.template(tooltip.options));\n                kendo.applyStylesFromKendoAttributes(tooltip.element, [\"display\", \"position\", \"font\", \"border\", \"opacity\"]);\n\n                tooltip.move = tooltip.move.bind(tooltip);\n                tooltip._mouseleave = tooltip._mouseleave.bind(tooltip);\n\n                var mobileScrollerSelector = kendo.format(\"[{0}='content'],[{0}='scroller']\", kendo.attr(\"role\"));\n                tooltip._mobileScroller = chartElement.closest(mobileScrollerSelector).data(\"kendoMobileScroller\");\n                tooltip.downEvent = kendo.applyEventMap(MOUSEDOWN, kendo.guid());\n                tooltip._closeTooltipHandler = tooltip._closeTooltip.bind(tooltip);\n            },\n\n            destroy: function() {\n                var tooltip = this;\n\n                this._clearShowTimeout();\n                DOCUMENT_ELEMENT.off(tooltip.downEvent, tooltip._closeTooltipHandler);\n                if (this.element) {\n                    this.element.off(MOUSELEAVE_NS).remove();\n                    this.element = null;\n                }\n            },\n\n            setOptions: function(options) {\n                this.options = deepExtend({}, this.options, options);\n            },\n\n            options: {\n                opacity: 1,\n                animation: {\n                    duration: TOOLTIP_ANIMATION_DURATION\n                },\n                sharedTemplate: ({ colspan, categoryText, points, content, colorMarker, nameColumn }) =>\n                    \"<table>\" +\n                    `<th colspan='${colspan}'>${categoryText}</th>` +\n                        sharedTemplateIterator(points, colorMarker, nameColumn, content) +\n                    \"</table>\",\n                categoryFormat: \"{0:d}\",\n                autoHide: true\n            },\n\n            move: function() {\n                var tooltip = this,\n                    options = tooltip.options,\n                    element = tooltip.element,\n                    offset;\n\n                if (!tooltip.anchor || !tooltip.element) {\n                    return;\n                }\n\n                offset = tooltip._offset();\n                if (!tooltip.visible) {\n                    element.css({ top: offset.top, left: offset.left });\n                }\n\n                tooltip.visible = true;\n                tooltip._ensureElement(document.body);\n                element\n                    .stop(true, true)\n                    .show()\n                    .animate({\n                        left: offset.left,\n                        top: offset.top\n                    }, options.animation.duration);\n            },\n\n            _clearShowTimeout: function() {\n                if (this.showTimeout) {\n                    clearTimeout(this.showTimeout);\n                    this.showTimeout = null;\n                }\n            },\n\n            getAnchor: function(size) {\n                var anchor = this.anchor;\n                var point = anchor.point;\n                var align = anchor.align;\n                var x = point.left;\n                var y = point.top;\n                if (align.horizontal === \"center\") {\n                    x -= size.width / 2;\n                } else if (align.horizontal === \"right\") {\n                    x -= size.width;\n                }\n\n                if (align.vertical === \"center\") {\n                    y -= size.height / 2;\n                } else if (align.vertical === \"bottom\") {\n                    y -= size.height;\n                }\n\n                return {\n                    x: x,\n                    y: y\n                };\n            },\n\n            _offset: function() {\n                var tooltip = this,\n                    size = tooltip._measure(),\n                    anchor = tooltip.getAnchor(size),\n                    top = anchor.y,\n                    left = anchor.x,\n                    zoomLevel = kendo.support.zoomLevel(),\n                    viewport = $(window),\n                    scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0,\n                    scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || 0,\n                    movable = (this._mobileScroller || {}).movable;\n\n                if (!movable || movable.scale === 1) {\n                    top += tooltip._fit(top - scrollTop, size.height, outerHeight(viewport) / zoomLevel);\n                    left += tooltip._fit(left - scrollLeft, size.width, outerWidth(viewport) / zoomLevel);\n                } else {\n                    var transform = geom.transform().scale(movable.scale, movable.scale, [movable.x, movable.y]);\n                    var point = new geom.Point(left, top).transform(transform);\n                    left = point.x;\n                    top = point.y;\n                }\n\n                return {\n                    top: top,\n                    left: left\n                };\n            },\n\n            show: function(e) {\n                var tooltip = this;\n                var fakeContainer = $(\"<div></div>\");\n                this.anchor = e.anchor;\n                this.element.css(normalizeStyle(e.style));\n                this.element.toggleClass(TOOLTIP_INVERSE, !!e.className);\n                this.element.toggleClass(SHARED_TOOLTIP_CLASS, !!e.shared);\n\n                var content = e.shared ? this._sharedContent(e) : this._pointContent(e.point);\n                fakeContainer.html(content);\n                kendo.applyStylesFromKendoAttributes(fakeContainer, [\"background-color\"]);\n                this.element.find('.k-tooltip-content').empty().append(fakeContainer);\n\n                if (!tooltip.options.autoHide) {\n                    tooltip.element.off(\"click\" + NS).on(\"click\" + NS, \".k-tooltip-button\", tooltip._closeTooltipHandler);\n                    DOCUMENT_ELEMENT.off(tooltip.downEvent, tooltip._closeTooltipHandler)\n                        .on(tooltip.downEvent, tooltip._closeTooltipHandler);\n                }\n\n                this._clearShowTimeout();\n                this.showTimeout = setTimeout(this.move, TOOLTIP_SHOW_DELAY);\n            },\n\n            hide: function(forceHide) {\n                var tooltip = this;\n\n                if (!tooltip.options.autoHide && !forceHide) {\n                    return;\n                }\n\n                clearTimeout(tooltip.showTimeout);\n                tooltip._hideElement();\n\n                if (tooltip.visible) {\n                    tooltip.point = null;\n                    tooltip.visible = false;\n                    tooltip.index = null;\n                    DOCUMENT_ELEMENT.off(tooltip.downEvent, tooltip._closeTooltipHandler);\n                }\n            },\n\n            _closeTooltip: function(e) {\n                var target = $(e.target);\n\n                if (!target.is(\".k-chart-tooltip, .k-tooltip-content\")) {\n                    e.preventDefault();\n                    this.chartElement.data(\"kendoChart\")._instance.hideElements();\n                    this.hide(true);\n                }\n            },\n\n            _sharedContent: function(e) {\n                var points = e.points;\n                var that = this;\n\n                var nameColumn = dataviz.grep(points, function(point) {\n                    return defined(point.series.name);\n                }).length;\n\n                var colorMarker = e.series.length > 1;\n                var colspan = 1;\n                if (nameColumn) {\n                    colspan++;\n                }\n                if (colorMarker) {\n                    colspan++;\n                }\n\n                var template = kendo.template(this.options.sharedTemplate);\n                var content = template({\n                    points: points,\n                    category: e.category,\n                    categoryText: e.categoryText,\n                    content: this._pointContent.bind(that),\n                    colorMarker: colorMarker,\n                    nameColumn: nameColumn,\n                    colspan: colspan\n                });\n\n                return content;\n            },\n\n            _measure: function() {\n                this._ensureElement();\n\n                var size = {\n                    width: outerWidth(this.element),\n                    height: outerHeight(this.element)\n                };\n\n                return size;\n            },\n\n            _ensureElement: function() {\n                if (this.element) {\n                    this.element\n                        .appendTo(document.body)\n                        .on(MOUSELEAVE_NS, this._mouseleave);\n                }\n            },\n\n            _mouseleave: function(e) {\n                var target = e.relatedTarget;\n                var chart = this.chartElement[0];\n                if (target && target !== chart && !$.contains(chart, target)) {\n                    this.trigger(LEAVE);\n                }\n            },\n\n            _hideElement: function() {\n                var tooltip = this;\n                var element = this.element;\n                if (element) {\n                    element.fadeOut({\n                        always: function() {\n                            if (!tooltip.visible) {\n                                element.off(MOUSELEAVE_NS).remove();\n                            }\n                        }\n                    });\n                }\n            },\n\n            _pointContent: function(point) {\n                var tooltip = this,\n                    options = deepExtend({}, tooltip.options, point.options.tooltip),\n                    content, tooltipTemplate;\n\n                if (defined(point.value)) {\n                    content = point.value.toString();\n                }\n\n                if (options.template) {\n                    tooltipTemplate = template(options.template);\n                    content = tooltipTemplate({\n                        value: point.value,\n                        category: point.category,\n                        series: point.series,\n                        dataItem: point.dataItem,\n                        percentage: point.percentage,\n                        runningTotal: point.runningTotal,\n                        total: point.total,\n                        low: point.low,\n                        high: point.high,\n                        xLow: point.xLow,\n                        xHigh: point.xHigh,\n                        yLow: point.yLow,\n                        yHigh: point.yHigh\n                    });\n                } else if (options.format) {\n                    content = point.formatValue(options.format);\n                }\n\n                return content;\n            },\n\n            _fit: function(offset, size, viewPortSize) {\n                var output = 0;\n\n                if (offset + size > viewPortSize) {\n                    output = viewPortSize - (offset + size);\n                }\n\n                if (offset < 0) {\n                    output = -offset;\n                }\n\n                return output;\n            }\n        });\n\n        var CrosshairTooltip = Tooltip.extend({\n            init: function(chartElement, options) {\n                Tooltip.fn.init.call(this, chartElement, options);\n                this.element.addClass(\"k-chart-crosshair-tooltip\");\n            },\n\n            show: function(e) {\n                var element = this.element;\n\n                if (element) {\n                    this.anchor = e.anchor;\n                    this.element.css(e.style);\n                    this.element.html(this.content(e));\n\n                    this.move();\n                }\n            },\n\n            move: function() {\n                var tooltip = this,\n                    element = tooltip.element,\n                    offset = tooltip._offset();\n\n                tooltip._ensureElement();\n                element.css({ top: offset.top, left: offset.left }).show();\n            },\n\n            content: function(e) {\n                var content = e.value,\n                    options = e.crosshair.options.tooltip;\n\n                if (options.template) {\n                    content = template(options.template)({\n                        value: content\n                    });\n                }\n\n                return content;\n            },\n\n            hide: function() {\n                this.element.hide();\n            }\n        });\n\n        var ChartPane = Class.extend({\n            init: function(chart, pane) {\n                this._chart = chart;\n                this._pane = pane;\n                this.visual = pane.visual;\n                this.chartsVisual = pane.chartContainer.visual;\n                this.name = pane.options.name;\n            },\n\n            series: function() {\n                var chart = this._chart;\n                var seriesByPane = chart._plotArea.groupSeriesByPane();\n                var series = seriesByPane[this.name || \"default\"];\n\n                var result = [];\n                if (series) {\n                    for (var idx = 0; idx < series.length; idx++) {\n                        result.push(new ChartSeries(chart, series[idx]));\n                    }\n                }\n\n                return result;\n            }\n        });\n\n        var ChartSeries = Class.extend({\n            init: function(chart, options) {\n                this._chart = chart;\n                this._options = options;\n            },\n\n            points: function(filter) {\n                var points = this._points;\n                if (!points) {\n                    var series = this._seriesOptions();\n                    var plotArea = this._chart._plotArea;\n                    this._points = points = plotArea.pointsBySeriesIndex(series.index);\n                }\n                if (kendo.isFunction(filter)) {\n                    points = this._filterPoints(points, filter);\n                }\n\n\n                return points;\n            },\n\n            data: function(data) {\n                var series = this._seriesOptions();\n                if (data) {\n                    var chart = this._chart;\n                    var plotArea = chart._plotArea;\n\n                    series.data = data;\n\n                    if (series.categoryField) {\n                        var axis = plotArea.seriesCategoryAxis(series);\n                        var options = [].concat(chart.options.categoryAxis);\n\n                        chart._instance.bindCategoryAxisFromSeries(options[axis.axisIndex], axis.axisIndex);\n                    }\n\n                    chart._noTransitionsRedraw();\n                    this._clearFields();\n                }\n\n                return series.data;\n            },\n\n            findPoint: function(filter) {\n                var points = this.points();\n                for (var idx = 0; idx < points.length; idx++) {\n                    if (filter(points[idx])) {\n                        return points[idx];\n                    }\n                }\n            },\n\n            toggleHighlight: function(show, elements) {\n                if (!elements) {\n                    elements = this.points();\n                } else if (kendo.isFunction(elements)) {\n                    elements = this.points(elements);\n                } else {\n                    elements = isArray(elements) ? elements : [elements];\n                }\n\n                this._chart._instance.togglePointsHighlight(show, elements);\n            },\n\n            toggleVisibility: function(visible, filter) {\n                var chart = this._chart;\n                var seriesOptions = this._seriesOptions();\n                var hasFilter = kendo.isFunction(filter);\n                if (!hasFilter) {\n                    seriesOptions.visible = visible;\n                    chart._seriesVisibility.save(seriesOptions);\n                } else {\n                    if (inArray(seriesOptions.type, [PIE, DONUT, FUNNEL])) {\n                        var data = this._filterData(filter);\n                        for (var idx = 0; idx < data.length; idx++) {\n                            data[idx].visible = visible;\n                        }\n                    } else {\n                        seriesOptions.visible = function(data) {\n                            return filter(data.dataItem) ? visible : true;\n                        };\n                    }\n                }\n\n                chart._noTransitionsRedraw();\n\n                this._clearFields();\n            },\n\n            _filterData: function(filter) {\n                var data = this._seriesOptions().data;\n                var length = data.length;\n                var result = [];\n\n                for (var idx = 0; idx < length; idx++) {\n                    if (filter(data[idx])) {\n                        result.push(data[idx]);\n                    }\n                }\n                return result;\n            },\n\n            _filterPoints: function(points, filter) {\n                var result = [];\n                var length = points.length;\n                for (var idx = 0; idx < length; idx++) {\n                    if (filter(points[idx])) {\n                        result.push(points[idx]);\n                    }\n                }\n                return result;\n            },\n\n            _seriesOptions: function() {\n                var series = this._series;\n                if (!series) {\n                    series = this._series = this._chart._seriesOptions(this._options);\n                }\n                return series;\n            },\n\n            _clearFields: function() {\n                delete this._points;\n                delete this._series;\n            }\n        });\n\n        function triggerPaneRender(panes) {\n            for (var idx = 0; idx < panes.length; idx++) {\n                panes[idx].notifyRender();\n            }\n        }\n\n        function sharedTemplateIterator(points, colorMarker, nameColumn, content) {\n            var result = \"\";\n\n            for (var i = 0; i < points.length; i++) {\n                var point = points[i];\n                result += \"<tr>\";\n\n                if (colorMarker) {\n                    result += `<td><span class='k-chart-shared-tooltip-marker' ${kendo.attr(\"style-background-color\")}=\"${encode(point.series.color)}\"></span></td>`;\n                }\n\n                if (nameColumn) {\n                    result += `<td> ${point.series.name ? point.series.name + \":\" : \"&nbsp;\"}</td>`;\n                }\n\n                result += `<td>${content(point)}</td>`;\n                result += \"</tr>\";\n            }\n\n            return result;\n        }\n\n        dataviz.Tooltip = Tooltip;\n        dataviz.CrosshairTooltip = CrosshairTooltip;\n        dataviz.ChartInstanceObserver = ChartInstanceObserver;\n        dataviz.ChartPane = ChartPane;\n        dataviz.ChartSeries = ChartSeries;\n\n    })(window.kendo.jQuery);\n\n    var __meta__ = {\n        id: \"dataviz.chart\",\n        name: \"Chart\",\n        category: \"dataviz\",\n        description: \"The Chart widget uses modern browser technologies to render high-quality data visualizations in the browser.\",\n        depends: [ \"data\", \"userevents\", \"drawing\", \"dataviz.core\", \"dataviz.themes\" ],\n        features: [{\n            id: \"dataviz.chart-pdf-export\",\n            name: \"PDF export\",\n            description: \"Export Chart as PDF\",\n            depends: [ \"pdf\" ]\n        }]\n    };\n\n    var kendo$1 = kendo;\n\n    return kendo$1;\n\n}));\n"]}