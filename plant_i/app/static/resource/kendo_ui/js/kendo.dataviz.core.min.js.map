{"version":3,"sources":["raw-js/kendo.dataviz.core.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendodataviz","core","js","this","$","dataviz","services","draw","window","kendo","drawing","util","Path","Group","Class","support","geometry","Rect","Circle","geometryTransform","transform","Segment","deepExtend","isFunction","__common_getter_js","getter","ARC","AXIS_LABEL_CLICK","BLACK","BOTTOM","CENTER","CIRCLE","CROSS","DATE","DEFAULT_FONT","DEFAULT_PRECISION","FORMAT_REGEX","HEIGHT","INSIDE","LEFT","MAX_VALUE","Number","MIN_VALUE","NONE","NOTE_CLICK","NOTE_HOVER","NOTE_LEAVE","OBJECT","OUTSIDE","RIGHT","ROUNDED_RECT","STRING","TOP","TRIANGLE","WHITE","WIDTH","X","Y","constants","ARROW_UP","ARROW_DOWN","ARROW_LEFT","ARROW_RIGHT","TAB","ARIA_ACTIVE_DESCENDANT","COORD_PRECISION","DEFAULT_HEIGHT","DEFAULT_WIDTH","END","ENTER","ESCAPE","HIGHLIGHT_ZINDEX","INHERIT","START","SQUARE","RECT","VALUE","DEFAULT_SERIES_OPACITY","POINTER","HORIZONTAL","VERTICAL","isArray","value","Array","addClass","element","classes","classArray","idx","length","className","indexOf","SPACE_REGEX","removeClass","replace","alignPathToPixel","path","offset","options","stroke","defined","width","i","segments","anchor","round","translate","clockwise","angle1","angle2","x","y","isNumber","isNaN","isString","isObject","styleValue","SIZE_STYLES_REGEX","isSizeField","field","test","getSpacing","defaultSpacing","spacing","top","right","bottom","left","current","compile","template","TemplateService","extend","getTemplate","content","grep","array","callback","result","push","register","userImplementation","HashMap","_map","Map","inArray","prototype","get","key","set","TRIGGER","InstanceObserver","init","observer","handlers","handlerMap","trigger","name","args","isDefaultPrevented","callObserver","fnName","len","arguments","apply","requiresHandlers","names","isPlainObject","Object","toString","call","map","browser","ref","append","bindEvents","deg","elementOffset","elementSize","eventCoordinates","eventElement","hashKey","last","limitValue","objectKey","rad","unbindEvents","valueOrDefault","FontLoader","setDefaultOptions","type","proto","fetchFonts","fonts","state","depth","document","keys","forEach","loadFonts","promises","font","load","e","logToConsole","Promise","all","then","preloadFonts","KI_PREFFIX","KSVG_PREFFIX","HTMLBaseIcon","wrapper","addClasses","html","outerHTML","size","themeColor","flip","iconClass","stylingOptions","HTMLFontIcon","fn","currentIconClass","split","find","startsWith","icon","_className","HTMLSvgIcon","innerHTML","iconNameMatch","match","toUpperCase","svgIcons","setAttribute","svgElement","createElementNS","viewBox","appendChild","ICON_TYPES","svg","sparseArrayLimits","arr","min","max","isFinite","Math","undefined","Matrix","matrixRegexp","transformMatrix","getComputedStyle","unit","matrixString","members","parseFloat","Function","bind","concat","parseMatrix","autoTextColor","color","Color","isDark","DELETED","LegacySet","values","_index","_values","slice","filter","item","has","add","delete","index","clear","defineProperties","SetWrapper","_set","Set","from","Matrix$1","height","data","clone","m","row","col","line","each","f","includeEmpty","val","el","transpose","n","a","j","multiply","b","s","va","vb","inverse","augment","loop","k","imax","start","end","pos","v","argmax","tmp","returned","i$1","j$1","k$1","i$2","j$2","ret","STRING$1","FUNCTION","preventDefault","_defaultPrevented","Observable$$1","Class$$1","_events","__proto__","create","constructor","destroy","unbind","event","one","original","handler","that","eventNames","handlersIsFunction","eventName","first","eventName$1","unshift","eventArgs","events","sender","splice","_setEvents","this$1$1","autoMajorUnit","diff","abs","scale","pow","floor","log","relativeValue","Point","equals","point","rotate","center","degrees","theta","cosT","cos","sinT","sin","cx","cy","distanceTo","dx","dy","sqrt","onCircle","angle","radius","radians","Box","x1","y1","x2","y2","box","move","wrap","targetBox","wrapPoint","arrayPoint","snapTo","axis","alignTo","targetCenter","shrink","dw","dh","expand","pad","padding","unpad","containsPoint","points","getHash","join","overlaps","rotation","r1","rotatePoint","r2","r3","r4","toRect","hasSize","align","alignment","c1","c2","sizeFunc","Ring","innerRadius","startAngle","middle","setRadius","newRadius","radianAngle","ax","ay","adjacentBox","distance","sector","midAndle","midPoint","hw","hh","sa","ca","p","endAngle","vector","startPoint","startVector","endPoint","endVector","dist","getBBox","angles","allAngles","sort","numericComparer","startAngleIndex","endAngleIndex","Sector","ShapeBuilder","createRing","arc","Arc","radiusX","radiusY","fromArc","close","innerEnd","pointAt","lineTo","ChartElement","children","initUserOptions","reflow","currentChild","animation","getRoot","parent","getSender","service","getService","chartService","translateChildren","childrenCount","arguments$1","renderVisual","visible","createVisual","addVisual","renderChildren","createAnimation","renderComplete","visual","chartElement","appendVisual","zIndex","Animation","childVisual","noclip","clipRoot","stackRoot","stackVisual","isStackRoot","visuals","sibling","insert","traverse","child","closest","matched","hasHighlight","highlight","createHighlight","toggleHighlight","show","opacity","customVisual","_highlight","highlightOptions","fill","highlightVisualArgs","series","dataItem","category","percentage","runningTotal","total","toggleFocusHighlight","accessibility","focusHighlight","_focusHighlight","highlightColor","background","focusHighlightOptions","border","createFocusHighlight","createGradientOverlay","gradientOptions","overlay","createGradient","closed","elements","supportsPointInactiveOpacity","BoxElement","margin","shrinkToFit","hasSetSize","borderWidth","reflowPaddingBox","vAlign","paddingBox","contentBox","hasBox","fromRect","visualStyle","dashType","cursor","ShapeElement","pointData","getElement","halfWidth","halfHeight","style","fromPoints","MultiPath","moveTo","rect","borderRadius","setCornerRadius","createElement","visualOptions","accessibilityOptions","role","ariaLabel","ariaRoleDescription","ariaChecked","RADIAL","GRADIENTS","glass","stops","sharpBevel","roundedBevel","roundedGlass","supportVML","sharpGlass","bubbleShadow","boxDiff","r","c","d","g","h","boxes","RootElement","rootOptions","parseInt","gradients","currentBox","createBackground","drawingGradient","hashCode","gradient","LinearGradient","usedSpace","currentStops","currentStop","innerRadialStops","RadialGradient","cleanGradients","_observers","FloatElement","_initDirection","vertical","groupAxis","elementAxis","groupSizeField","elementSizeField","groupSpacing","elementSpacing","vSpacing","reflowChildren","ref$1","groupOptions","groups","groupsSize","maxGroupElementsSize","groupsCount","groupsStart","alignStart","groupStart","groupIdx","group","groupElements","elementStart","groupElementsCount","elementSize$$1","groupElementStart","groupSize","elementBox","maxSize","groupElementsSize","DrawingText","Text","measureText","baseline","paintOrder","topLeft","rectToBox","origin","bottomRight","ROWS_SPLIT_REGEX","TextBox","_initContainer","_autoReflow","rows","String","floatElement","textOptions","container","rowIdx","text","trim","visualFn","_boxReflow","visualBox","visualContext","clippedBBox","normalBox","rotatedBox","rotationTransform","context","getDefaultVisual","boxCenter","Title","_textBox","position","collapseVerticalMargins","items","prevBox","buildTitle","defaultOptions","title","titleOptions","orderTitles","titles","reverse","AxisLabel","format","culture","click","widget","alignRotation","bbox","matrix","rotationMatrix","rotationOrigin","alignAxis","distanceAxis","axisAnchor","transformCopy","topRight","bottomLeft","alignEnd","distanceLeft","distanceRight","alignCenter","Note","fields","render","hide","label","childAlias","noteTemplate","auto","aliasFor","marker","wrapperBox","lineStart","linePoints","createLine","defaultVisual","over","out","current$1","parseDate","Date","firstDay","IntlService","implementation","FORMAT_REPLACE_REGEX","FormatService","intlService","_intlService","formatString","intl","localeAuto","locale","placeholderFormat","substring","current$2","ChartService","chart","rtl","Boolean","notify","isPannable","pannable","lock","DomEventsBuilder","createAxisTick","tickOptions","tickX","tickY","tick","createAxisGridLine","gridLine","lineEnd","Axis","labels","majorTickSize","minorTickSize","minorTicks","minorTickType","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","labelsRange","skip","labelsCount","normalizeLabelRotation","labelOptions","step","clearLabels","autoRotateLabels","range","labelContext","count","createAxisLabel","clearTitle","lineBox","mirror","axisX","axisY","lineWidth","visualSize","notes","parseNoteValue","note","createPlotBands","gridLinesVisual","gridLines","_gridLines","createTicks","lineGroup","majorUnit","tickLineOptions","tickPositions","skipUnit","getMajorTickPositions","getMinorTickPositions","minorUnit","_alignLines","_lineGroup","getActualTickSize","tickSize","_backgroundPath","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","slotX","slotY","getSlot","to","createPlotBandLabel","bandRect","textbox","labelTemplate","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","sizeFn","titleSize","space","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","labelsBetweenTicks","tickIx","firstTickPosition","nextTickPosition","positionStart","positionEnd","positionLabel","labelBox","labelOffset","labelX","labelY","autoRotateLabelAngle","slotWidth","limit","labelAngle","idx$1","slot","shouldRenderNote","noteSlot","secondAxis","axisLabelText","tmpl","defaultText","maxLabelOffset","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","lineDir","lineInfo","lineSize","axisDir","axisOrigin","pointOffset","scaleToDelta","rawScale","justified","prepareUserOptions","axisCrossingValue","MILLISECONDS","SECONDS","MINUTES","HOURS","DAYS","WEEKS","MONTHS","YEARS","TIME_PER_SECOND","TIME_PER_MINUTE","TIME_PER_HOUR","TIME_PER_DAY","TIME_PER_WEEK","TIME_PER_MONTH","TIME_PER_YEAR","TIME_PER_UNIT","years","months","weeks","days","hours","minutes","seconds","milliseconds","absoluteDateDiff","getTime","getTimezoneOffset","addTicks","date","ticks","toDate","startOfWeek","weekStartDay","daysToSubtract","day","getDay","adjustDST","getHours","setHours","addDuration","dateValue","getFullYear","getMonth","getDate","roundedDate","setMinutes","tzDiff","addHours","getSeconds","setSeconds","getMilliseconds","setMilliseconds","floorDate","ceilDate","dateComparer","dateDiff","toTime","dateEquals","timeIndex","baseUnit","dateIndex","baseUnitStep","startDate","duration","parseDates","dates","CategoryAxis","_ticks","categoriesHash","copy","categories","srcCategories","definedMin","definedMax","ceil","rangeIndices","totalRange","roundedRange","_seriesMax","scaleOptions","hideOutOfRangeLabels","valueAxis","firstLabel","getTicks","labelTicks","tickIndices","stepSize","indices","getTickPositions","positions","cache","hash","_hash","hasMinor","filterOutOfRangePositions","inRange","startIndex","endIndex","slotBox","singleSlot","p1","p2","limitSlot","limittedSlot","categoryIndex","pointCategoryIndex","startValue","getCategory","totalIndex","categoryAt","categoriesCount","translateRange","delta","scaleRange","limitedRangeIndices","minDelta","maxDelta","zoomRange","totalMin","totalMax","dataItems","hideOutOfRangeNotes","pan","pointsRange","diffStart","diffEnd","rangeMin","rangeMax","_categoriesMap","currentRangeIndices","totalCount","totalLimit","totalRangeIndices","indexCategories","map$$1","COORDINATE_LIMIT","DateLabelFormats","ZERO_THRESHOLD","BASE_UNITS","FIT","categoryRange","clearCache","_range","EmptyDateRange","displayIndices","displayRange","valueIndex","valuesCount","dateAt","DateRange","roundToBaseUnit","lowerEnd","roundToTotalStep","expandEnd","justifyEnd","valueStart","displayStart","next","valueEnd","displayEnd","_indices","minIdx","maxIdx","upper","roundedStep","autoBaseUnit","startUnit","startStep","unitSteps","nextStep","categoryLimits","span","autoBaseUnitSteps","maxDateGroups","autoUnit","autoUnitIx","units","totalUnits","shift","initUnit","toLowerCase","lastCategory","minDiff","categoryIx","defaultBaseUnit","DateCategoryAxis","dataRange","_parsed","panning","userSetBaseUnit","userSetBaseUnitStep","maxDivisions","safeOptions","forecast","_forecast","before","after","divisionOptions","dataRangeOptions","divisionRange","rangeLabels","last$$1","isEmpty","totalLimits","panRange","datesRange","indicesRange","fit","autoBaseUnitStep","maxDiff","rangeDiff","baseUnitIndex","stepIndex","createRangeLabels","arrangeRangeLabels","position$1","autoRotateRangeLabels","hideOverlappingLabels","firstRangeLabel","clip","lastRangeLabel","rangeLabel","unitFormat","dateFormats","createLabel","rotateLabel","dateRange","limitCoordinate","MIN_VALUE_RANGE$1","NumericAxis","autoOptions","narrowRange","autoMin","narrow","axisMin","autoAxisMin","autoMax","axisMax","autoAxisMax","roundToMajorUnit","remainderClose","autoAxisOptions","totalOptions","totalAxisOptions","userOptions","userSetMin","userSetMax","clearNullValues","userSetLimits","axisOptions","totalMajorUnit","getDivisions","stepValue","divisions","skipStep","getValue","endValue","isValidRange","divisor","ratio","remainder","DateValueAxis","timeUnits","baseUnitTime","userMajorUnit","actualUnits","unitsToAdd","head","tail","applyDefaults","axisCrossingValues","dir","limittedRange","MIN_VALUE_RANGE$2","LogarithmicAxis","base","logMaxRemainder","autoAxisMax$1","autoAxisMin$1","throwNegativeValuesError","initRange","logMin","logMax","floorMax","traverseMajorTicksPositions","tickPosition","traverseMinorTicksPositions","power","minorOptions","_minorIntervalOptions","minorStep","info","Error","GridLinesMixin","majorAngles","minorAngles","skipMajor","majorGridLineAngles","renderMajorGridLines","minorGridLineAngles","renderMinorGridLines","renderGridLines","radiusCallback","circle","gridLineAngles","skipAngles","divs","intervals","altAxisVisible","alpha","intervalAngle","RadarCategoryAxis","reflowLabels","measureBox","skipOption","stepOption","divCount","divAngle","majorIntervals","minorIntervals","interval","minorAngle","minorRadius","band","plotBandSlot","ring","totalDivs","slotAngle","fromValue","slotStart","PolarAxis","instanceOptions","atan2","PI","RadarNumericAxisMixin","polarAxis","bandStyle","shape","plotBandPoints","innerPoints","outerPoints","innerCircle","outerCircle","radarMajorGridLinePositions","radarMinorGridLinePositions","tickRadius","angleIx","angularDistance","gamma","beta","axisType","RadarNumericAxis","minorSkipStep","RadarLogarithmicAxis","CurveProcessor","process","dataPoints","removeDuplicates","initialControlPoint","lastControlPoint","p0","pop","tangent","controlOut","firstControlPoint","secondControlPoint","controlPoints","tangent$1","cp0","controlPoints$1","cp1","controlPoints$2","tangent$2","invertAxis","lineFunction","calculateFunction","isLine","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","numberSign","oldXField","restrictControlPoint","cp","p3","t1","t2","xValue","yValue","controlPoint","Gradients","convertableToNumber","cycleUp","cycleDown","cycleIndex","elementStyles","styles","stylesArray","field$1","getAriaTemplate","ariaTemplate","ariaContent","hasClasses","classNames","interpolateValue","progress","mousewheelDelta","wheelDelta","webkit","devicePixelRatio","detail","renderIcon","iconElement","iconOptions","HTMLElement","predicate","elementScale","parentElement","parentMatrix","multiplyCopy","createHashSet","supported","defaultErrorHandler","error","INSERT","DELETE","BACKSPACE","ESC","UP","DOWN","HOME","SPACEBAR","PAGEUP","PAGEDOWN","F2","F10","F12","NUMPAD_PLUS","NUMPAD_MINUS","NUMPAD_DOT","hasOwnProperty","obj","property","Observable","lteDateIndex","sortedDates","low","high","currentDate","jQuery","SASS_THEMES","ExportMixin","skipLegacy","exportVisual","exportSVG","exportImage","exportPDF","imageDataURL","Surface","exportGroup","canvas","css","display","appendTo","body","surface","image","_rootElement","toDataURL","remove","calendars","standard","Point2D","Box2D","mwDelta","originalEvent"],"mappings":"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","file":"kendo.dataviz.core.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('kendo.core.js'), require('kendo.drawing.js')) :\n    typeof define === 'function' && define.amd ? define(['kendo.core', 'kendo.drawing'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.kendodataviz = global.kendodataviz || {}, global.kendodataviz.core = global.kendodataviz.core || {}, global.kendodataviz.core.js = factory()));\n})(this, (function () {\n    /***********************************************************************\n     * WARNING: this file is auto-generated.  If you change it directly,\n     * your modifications will eventually be lost.  The source code is in\n     * `kendo-charts` repository, you should make your changes there and\n     * run `src-modules/sync.sh` in this repository.\n     */\n\n    (function($) {\n    /* eslint-disable space-before-blocks, space-before-function-paren, curly, object-curly-spacing */\n\n    window.kendo.dataviz = window.kendo.dataviz || {};\n    var drawing = kendo.drawing;\n    var util = drawing.util;\n    var Path = drawing.Path;\n    var Group = drawing.Group;\n    var Class = kendo.Class;\n    var support = kendo.support;\n    var geometry = kendo.geometry;\n    var Rect = geometry.Rect;\n    var Circle = geometry.Circle;\n    var geometryTransform = geometry.transform;\n    var Segment = geometry.Segment;\n    var dataviz = kendo.dataviz;\n\n    var deepExtend = kendo.deepExtend;\n    var isFunction = kendo.isFunction;\n    var __common_getter_js = kendo.getter;\n\n    var ARC = \"arc\";\n    var ARROW_UP = \"ArrowUp\";\n    var ARROW_DOWN = \"ArrowDown\";\n    var ARROW_LEFT = \"ArrowLeft\";\n    var ARROW_RIGHT = \"ArrowRight\";\n    var TAB = \"Tab\";\n    var ARIA_ACTIVE_DESCENDANT = \"aria-activedescendant\";\n    var AXIS_LABEL_CLICK = \"axisLabelClick\";\n    var BLACK = \"#000\";\n    var BOTTOM = \"bottom\";\n    var CENTER = \"center\";\n    var CIRCLE = \"circle\";\n    var COORD_PRECISION = 3;\n    var CROSS = \"cross\";\n    var DATE = \"date\";\n    var DEFAULT_FONT = \"12px sans-serif\";\n    var DEFAULT_HEIGHT = 400;\n    var DEFAULT_PRECISION = 10;\n    var DEFAULT_WIDTH = 600;\n    var END = \"end\";\n    var ENTER = \"Enter\";\n    var ESCAPE = \"Escape\";\n    var FORMAT_REGEX = /\\{\\d+:?/;\n    var HEIGHT = \"height\";\n    var HIGHLIGHT_ZINDEX = 100;\n    var INSIDE = \"inside\";\n    var INHERIT = \"inherit\";\n    var LEFT = \"left\";\n    var MAX_VALUE = Number.MAX_VALUE;\n    var MIN_VALUE = -Number.MAX_VALUE;\n    var NONE = \"none\";\n    var NOTE_CLICK = \"noteClick\";\n    var NOTE_HOVER = \"noteHover\";\n    var NOTE_LEAVE = \"noteLeave\";\n    var OBJECT = \"object\";\n    var OUTSIDE = \"outside\";\n    var RIGHT = \"right\";\n    var ROUNDED_RECT = \"roundedRect\";\n    var START = \"start\";\n    var STRING = \"string\";\n    var TOP = \"top\";\n    var TRIANGLE = \"triangle\";\n    var SQUARE = \"square\";\n    var RECT = \"rect\";\n    var VALUE = \"value\";\n    var WHITE = \"#fff\";\n    var WIDTH = \"width\";\n    var X = \"x\";\n    var Y = \"y\";\n    var DEFAULT_SERIES_OPACITY = 1;\n    var POINTER = \"pointer\";\n    var HORIZONTAL = \"horizontal\";\n    var VERTICAL = \"vertical\";\n\n    var constants = {\n    \tARC: ARC,\n    \tARROW_UP: ARROW_UP,\n    \tARROW_DOWN: ARROW_DOWN,\n    \tARROW_LEFT: ARROW_LEFT,\n    \tARROW_RIGHT: ARROW_RIGHT,\n    \tTAB: TAB,\n    \tARIA_ACTIVE_DESCENDANT: ARIA_ACTIVE_DESCENDANT,\n    \tAXIS_LABEL_CLICK: AXIS_LABEL_CLICK,\n    \tBLACK: BLACK,\n    \tBOTTOM: BOTTOM,\n    \tCENTER: CENTER,\n    \tCIRCLE: CIRCLE,\n    \tCOORD_PRECISION: COORD_PRECISION,\n    \tCROSS: CROSS,\n    \tDATE: DATE,\n    \tDEFAULT_FONT: DEFAULT_FONT,\n    \tDEFAULT_HEIGHT: DEFAULT_HEIGHT,\n    \tDEFAULT_PRECISION: DEFAULT_PRECISION,\n    \tDEFAULT_WIDTH: DEFAULT_WIDTH,\n    \tEND: END,\n    \tENTER: ENTER,\n    \tESCAPE: ESCAPE,\n    \tFORMAT_REGEX: FORMAT_REGEX,\n    \tHEIGHT: HEIGHT,\n    \tHIGHLIGHT_ZINDEX: HIGHLIGHT_ZINDEX,\n    \tINSIDE: INSIDE,\n    \tINHERIT: INHERIT,\n    \tLEFT: LEFT,\n    \tMAX_VALUE: MAX_VALUE,\n    \tMIN_VALUE: MIN_VALUE,\n    \tNONE: NONE,\n    \tNOTE_CLICK: NOTE_CLICK,\n    \tNOTE_HOVER: NOTE_HOVER,\n    \tNOTE_LEAVE: NOTE_LEAVE,\n    \tOBJECT: OBJECT,\n    \tOUTSIDE: OUTSIDE,\n    \tRIGHT: RIGHT,\n    \tROUNDED_RECT: ROUNDED_RECT,\n    \tSTART: START,\n    \tSTRING: STRING,\n    \tTOP: TOP,\n    \tTRIANGLE: TRIANGLE,\n    \tSQUARE: SQUARE,\n    \tRECT: RECT,\n    \tVALUE: VALUE,\n    \tWHITE: WHITE,\n    \tWIDTH: WIDTH,\n    \tX: X,\n    \tY: Y,\n    \tDEFAULT_SERIES_OPACITY: DEFAULT_SERIES_OPACITY,\n    \tPOINTER: POINTER,\n    \tHORIZONTAL: HORIZONTAL,\n    \tVERTICAL: VERTICAL\n    };\n\n    function isArray(value) {\n        return Array.isArray(value);\n    }\n\n    function addClass(element, classes) {\n        var classArray = isArray(classes) ? classes : [ classes ];\n\n        for (var idx = 0; idx < classArray.length; idx++) {\n            var className = classArray[idx];\n            if (element.className.indexOf(className) === -1) {\n                element.className += \" \" + className;\n            }\n        }\n    }\n\n    var SPACE_REGEX = /\\s+/g;\n\n    function removeClass(element, className) {\n        if (element && element.className) {\n            element.className = element.className.replace(className, \"\").replace(SPACE_REGEX, \" \");\n        }\n    }\n\n    function alignPathToPixel(path) {\n        var offset = 0.5;\n        if (path.options.stroke && kendo.drawing.util.defined(path.options.stroke.width)) {\n            if (path.options.stroke.width % 2 === 0) {\n                offset = 0;\n            }\n        }\n\n        for (var i = 0; i < path.segments.length; i++) {\n            path.segments[i].anchor().round(0).translate(offset, offset);\n        }\n\n        return path;\n    }\n\n    function clockwise(angle1, angle2) {\n        // True if angle2 is clockwise of angle1\n        // assuming angles grow in clock-wise direction\n        // (as in the pie and radar charts)\n        return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\n    }\n\n    function isNumber(value) {\n        return typeof value === \"number\" && !isNaN(value);\n    }\n\n    function isString(value) {\n        return typeof value === STRING;\n    }\n\n    function convertableToNumber(value) {\n        return isNumber(value) || (isString(value) && isFinite(value));\n    }\n\n    function cycleUp(index, count) {\n        return (index + 1) % count;\n    }\n\n    function cycleDown(index, count) {\n        var result = index - 1;\n\n        return result < 0 ? count - 1 : result;\n    }\n\n    function cycleIndex(index, length) {\n        if (length === 1 || (index % length) === 0) {\n            return 0;\n        }\n\n        if (index < 0) {\n            return length + (index % length);\n        } else if (index >= length) {\n            return index % length;\n        }\n\n        return index;\n    }\n\n    function isObject(value) {\n        return typeof value === \"object\";\n    }\n\n    function styleValue(value) {\n        if (isNumber(value)) {\n            return value + \"px\";\n        }\n        return value;\n    }\n\n    var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\n\n    function isSizeField(field) {\n        return SIZE_STYLES_REGEX.test(field);\n    }\n\n    function elementStyles(element, styles) {\n        var stylesArray = isString(styles) ? [ styles ] : styles;\n\n        if (isArray(stylesArray)) {\n            var result = {};\n            var style = window.getComputedStyle(element);\n\n            for (var idx = 0; idx < stylesArray.length; idx++) {\n                var field = stylesArray[idx];\n                result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\n            }\n\n            return result;\n        } else if (isObject(styles)) {\n            for (var field$1 in styles) {\n                element.style[field$1] = styleValue(styles[field$1]);\n            }\n        }\n    }\n\n    function getSpacing(value, defaultSpacing) {\n        if (defaultSpacing === void 0) { defaultSpacing = 0; }\n\n        var spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n\n        if (typeof(value) === \"number\") {\n            spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\n        } else {\n            spacing[TOP] = value[TOP] || defaultSpacing;\n            spacing[RIGHT] = value[RIGHT] || defaultSpacing;\n            spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\n            spacing[LEFT] = value[LEFT] || defaultSpacing;\n        }\n\n        return spacing;\n    }\n\n    var current = {\n        compile: function(template) {\n            return template;\n        }\n    };\n\n    var TemplateService = Class.extend({\n\n    });\n\n    TemplateService.register = function(userImplementation) {\n        current = userImplementation;\n    };\n\n    TemplateService.compile = function(template, options) {\n        return current.compile(template, options);\n    };\n\n    function getTemplate(options) {\n        if (options === void 0) { options = {}; }\n\n        var template;\n        if (options.template) {\n            options.template = template = TemplateService.compile(options.template);\n        } else if (isFunction(options.content)) {\n            template = options.content;\n        }\n\n        return template;\n    }\n\n    function getTemplate$1(options) {\n        if (options === void 0) { options = {}; }\n\n        var ariaTemplate;\n        if (options.ariaTemplate) {\n            options.ariaTemplate = ariaTemplate = TemplateService.compile(options.ariaTemplate);\n        } else if (isFunction(options.ariaContent)) {\n            ariaTemplate = options.ariaContent;\n        }\n\n        return ariaTemplate;\n    }\n\n    function grep(array, callback) {\n        var length = array.length;\n        var result = [];\n        for (var idx = 0; idx < length; idx++) {\n            if (callback(array[idx])) {\n                result .push(array[idx]);\n            }\n        }\n\n        return result;\n    }\n\n    function hasClasses(element, classNames) {\n        if (element.className) {\n            var names = classNames.split(\" \");\n            for (var idx = 0; idx < names.length; idx++) {\n                if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // TODO: Remove and replace with Map/WeakMap.\n    var HashMap = function HashMap() {\n        this._map = new Map();\n    };\n\n    HashMap.prototype.get = function get (key) {\n        return this._map.get(key);\n    };\n\n    HashMap.prototype.set = function set (key, value) {\n        this._map.set(key, value);\n    };\n\n    function inArray(value, array) {\n        if (array) {\n            return array.indexOf(value) !== -1;\n        }\n    }\n\n    function interpolateValue(start, end, progress) {\n        return kendo.drawing.util.round(start + (end - start) * progress, COORD_PRECISION);\n    }\n\n    var TRIGGER = 'trigger';\n\n    var InstanceObserver = Class.extend({\n        init: function(observer, handlers) {\n            this.observer = observer;\n            this.handlerMap = deepExtend({}, this.handlerMap, handlers);\n        },\n\n        trigger: function(name, args) {\n            var ref = this;\n            var observer = ref.observer;\n            var handlerMap = ref.handlerMap;\n            var isDefaultPrevented;\n            if (handlerMap[name]) {\n                isDefaultPrevented = this.callObserver(handlerMap[name], args);\n            } else if (observer[TRIGGER]) {\n                isDefaultPrevented = this.callObserver(TRIGGER, name, args);\n            }\n\n            return isDefaultPrevented;\n        },\n\n        callObserver: function(fnName) {\n            var args = [], len = arguments.length - 1;\n            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n            return this.observer[fnName].apply(this.observer, args);\n        },\n\n        requiresHandlers: function(names) {\n            var this$1$1 = this;\n\n            if (this.observer.requiresHandlers) {\n                return this.observer.requiresHandlers(names);\n            }\n\n            for (var idx = 0; idx < names.length; idx++) {\n                if (this$1$1.handlerMap[names[idx]]) {\n                    return true;\n                }\n            }\n        }\n    });\n\n    function isPlainObject(value) {\n        return Object.prototype.toString.call(value) === \"[object Object]\";\n    }\n\n    function map(array, callback) {\n        var length = array.length;\n        var result = [];\n        for (var idx = 0; idx < length; idx++) {\n            var value = callback(array[idx]);\n            if (kendo.drawing.util.defined(value)) {\n                result.push(value);\n            }\n        }\n        return result;\n    }\n\n    var browser = support.browser || {};\n\n    function mousewheelDelta(e) {\n        var delta = 0;\n\n        if (e.wheelDelta) {\n            delta = -e.wheelDelta / 120;\n\n            if (browser.webkit) {\n                // Webkit browsers scale the delta by twice the device resolution.\n                // Possibly related to https://bugs.webkit.org/show_bug.cgi?id=196339\n                //\n                // Low device resolutions (e.g. zoom-out to 30%) also behave strangely.\n                delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));\n            }\n        } else if (e.detail) {\n            delta = e.detail / 3;\n        }\n\n        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n\n        return delta;\n    }\n\n    var ref = kendo.drawing.util;\n    var append = ref.append;\n    var bindEvents = ref.bindEvents;\n    var defined = ref.defined;\n    var deg = ref.deg;\n    var elementOffset = ref.elementOffset;\n    var elementSize = ref.elementSize;\n    var eventCoordinates = ref.eventCoordinates;\n    var eventElement = ref.eventElement;\n    var hashKey = ref.hashKey;\n    var last = ref.last;\n    var limitValue = ref.limitValue;\n    var objectKey = ref.objectKey;\n    var rad = ref.rad;\n    var round = ref.round;\n    var unbindEvents = ref.unbindEvents;\n    var valueOrDefault = ref.valueOrDefault;\n\n    var FontLoader = Class.extend({\n\n    });\n\n    FontLoader.fetchFonts = function(options, fonts, state) {\n        if (state === void 0) { state = { depth: 0 }; }\n\n        var MAX_DEPTH = 5;\n\n        if (!options || state.depth > MAX_DEPTH || !document.fonts) {\n            return;\n        }\n\n        Object.keys(options).forEach(function(key) {\n            var value = options[key];\n            if (key === \"dataSource\" || key[0] === \"$\" || !value) {\n                return;\n            }\n\n            if (key === \"font\") {\n                fonts.push(value);\n            } else if (typeof value === \"object\") {\n                state.depth++;\n                FontLoader.fetchFonts(value, fonts, state);\n                state.depth--;\n            }\n        });\n    };\n\n    FontLoader.loadFonts = function(fonts, callback) {\n        var promises = [];\n\n        if (fonts.length > 0 && document.fonts) {\n            try {\n                promises = fonts.map(function(font) {\n                    return document.fonts.load(font);\n                });\n            } catch (e) {\n                // Silence font-loading errors\n                kendo.logToConsole(e);\n            }\n\n            Promise.all(promises).then(callback, callback);\n        } else {\n            callback();\n        }\n    };\n\n    FontLoader.preloadFonts = function(options, callback) {\n        var fonts = [];\n        FontLoader.fetchFonts(options, fonts);\n\n        FontLoader.loadFonts(fonts, callback);\n    };\n\n    function setDefaultOptions(type, options) {\n        var proto = type.prototype;\n        if (proto.options) {\n            proto.options = deepExtend({}, proto.options, options);\n        } else {\n            proto.options = options;\n        }\n    }\n\n    var KICON = 'k-icon';\n    var KI_PREFFIX = 'k-i-';\n    var KFONTICON = 'k-font-icon';\n    var KSVGICON = 'k-svg-icon';\n    var KSVG_PREFFIX = 'k-svg-i-';\n\n    var HTMLBaseIcon = Class.extend({\n        init: function(element, options) {\n            this.element = element;\n            this.options = deepExtend({}, this.options, options);\n\n            this.wrapper();\n        },\n\n        wrapper: function() {\n            this.addClasses();\n        },\n\n        addClasses: function() {\n        },\n\n        html: function() {\n            return this.element.outerHTML;\n        }\n    });\n\n    setDefaultOptions(HTMLBaseIcon, {\n        name: '',\n        size: 'none',\n        themeColor: 'none',\n        flip: 'default',\n        iconClass: '',\n        stylingOptions: [ 'size', 'themeColor', 'fill' ]\n    });\n\n    var HTMLFontIcon = HTMLBaseIcon.extend({\n        init: function(element, options) {\n            HTMLBaseIcon.fn.init.call(this, element, options);\n        },\n\n        wrapper: function() {\n            // Find if there is an existing k-i- class appended to the element.\n            var currentIconClass = this.element.className.split(\" \").find(function (x) { return x.startsWith(KI_PREFFIX); });\n            var className = this.options.icon ? (\"\" + (this.options.icon.startsWith(KI_PREFFIX) ? \"\" : KI_PREFFIX) + (this.options.icon)) : \"\";\n\n            this._className = className;\n\n            addClass(this.element, KICON);\n            addClass(this.element, KFONTICON);\n            removeClass(this.element, currentIconClass); // Remove any existing icons.\n            addClass(this.element, className);\n            addClass(this.element, this.options.iconClass || '');\n\n            HTMLBaseIcon.fn.wrapper.call(this);\n        }\n    });\n\n    setDefaultOptions(HTMLFontIcon, {\n        name: 'HTMLFontIcon',\n        icon: null\n    });\n\n    var HTMLSvgIcon = HTMLBaseIcon.extend({\n        init: function(element, options) {\n            // Ensure that the inner contents of the wrapping span element are always removed for re-rendering purposes.\n            element.innerHTML = \"\";\n\n            HTMLBaseIcon.fn.init.call(this, element, options);\n        },\n\n        wrapper: function() {\n            var icon = this.options.icon;\n            var iconClass = this.options.iconClass;\n            var currentIconClass = this.element.className.split(\" \").find(function (x) { return x.startsWith(KSVG_PREFFIX); });\n\n            if (!icon && iconClass) {\n                // match k-i-(some-icon-name)\n                var regex = /k-i-(\\w+(?:-\\w+)*)/;\n                var iconNameMatch = iconClass.match(regex);\n                if (iconNameMatch) {\n                    icon = iconNameMatch[1];\n                    iconClass = iconClass.replace(iconNameMatch[0], \"\");\n                }\n            }\n\n            if (isString(icon)) {\n                icon = icon.replace(\"k-i-\", \"\").replace(/-./g, function (x) { return x[1].toUpperCase(); });\n                icon = this.options.svgIcons[icon] || this.options.svgIcons[(icon + \"Icon\")];\n            }\n\n            var className = icon && icon.name ? (\"\" + KSVG_PREFFIX + (icon.name)) : \"\";\n            this._className = className;\n\n            addClass(this.element, KSVGICON);\n            removeClass(this.element, currentIconClass);\n            addClass(this.element, className);\n            addClass(this.element, iconClass || \"\");\n            this.element.setAttribute(\"aria-hidden\", \"true\");\n\n            if (icon && isPlainObject(icon)) {\n                var svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n                svgElement.setAttribute(\"viewBox\", icon.viewBox || \"\");\n                svgElement.setAttribute(\"focusable\", \"false\");\n                svgElement.innerHTML = icon.content || \"\";\n\n                this.element.appendChild(svgElement);\n            }\n\n            HTMLBaseIcon.fn.wrapper.call(this);\n        }\n    });\n\n    setDefaultOptions(HTMLSvgIcon, {\n        name: 'HTMLSvgIcon',\n        icon: null,\n        svgIcons: {}\n    });\n\n    var ICON_TYPES = {\n        'svg': HTMLSvgIcon,\n        'font': HTMLFontIcon\n    };\n\n    function renderIcon(iconElement, iconOptions) {\n        var element = iconElement;\n        var options = iconOptions;\n\n        if (!element\n            || (isObject(element) && !(element instanceof HTMLElement))\n            || isString(element)) {\n            options = element;\n            element = document.createElement(\"span\");\n        }\n\n        if (isString(options)) {\n            options = {\n                icon: options\n            };\n        }\n\n        if (!options.type) {\n            options.type = 'svg';\n        }\n\n        if (!ICON_TYPES[options.type]) {\n            return null;\n        }\n\n        return (new ICON_TYPES[options.type](element, options).html());\n    }\n\n    function sparseArrayLimits(arr) {\n        var min = MAX_VALUE;\n        var max = MIN_VALUE;\n\n        for (var idx = 0, length = arr.length; idx < length; idx++) {\n            var value = arr[idx];\n            if (value !== null && isFinite(value)) {\n                min = Math.min(min, value);\n                max = Math.max(max, value);\n            }\n        }\n\n        return {\n            min: min === MAX_VALUE ? undefined : min,\n            max: max === MIN_VALUE ? undefined : max\n        };\n    }\n\n    function find(array, predicate) {\n        for (var i = 0; i < array.length; i++) {\n            var item = array[i];\n            if (predicate(item, i, array)) {\n                return item;\n            }\n        }\n    }\n\n    var Matrix = geometry.Matrix;\n    var matrixRegexp = /matrix\\((.*)\\)/;\n\n    function parseMatrix(matrixString) {\n        var match = matrixString.match(matrixRegexp);\n        if (match === null || match.length !== 2) {\n            return Matrix.unit();\n        }\n\n        var members = match[1].split(',').map(function (x) { return parseFloat(x); });\n        return new (Function.prototype.bind.apply( Matrix, [ null ].concat( members) ));\n    }\n\n    function transformMatrix(element) {\n        var transform = getComputedStyle(element).transform;\n\n        if (transform === 'none') {\n            return Matrix.unit();\n        }\n\n        return parseMatrix(transform);\n    }\n\n    function elementScale(element) {\n        if (!element) {\n            return Matrix.unit();\n        }\n\n        var matrix = transformMatrix(element);\n        var parent = element.parentElement;\n        while (parent) {\n            var parentMatrix = transformMatrix(parent);\n            matrix = matrix.multiplyCopy(parentMatrix);\n            parent = parent.parentElement;\n        }\n\n        matrix.b = matrix.c = matrix.e = matrix.f = 0;\n        return matrix;\n    }\n\n    function autoTextColor(color) {\n        var isDark = new kendo.Color(color).isDark();\n        if (isDark) {\n            return WHITE;\n        }\n\n        return BLACK;\n    }\n\n    var DELETED = {};\n\n    var LegacySet = Class.extend({\n        init: function(values) {\n            var this$1$1 = this;\n\n            this._index = {};\n            this._values = values ? values.slice(0) : [];\n\n            for (var i = 0; i < this._values.length; i++) {\n                this$1$1._index[this$1$1._values[i]] = i;\n            }\n        },\n\n        values: function() {\n            return this._values.filter(function (item) { return item !== DELETED; });\n        },\n\n        has: function(value) {\n            return this._index[value] !== undefined;\n        },\n\n        add: function(value) {\n            if (!this.has(value)) {\n                this._index[value] = this._values.length;\n                this._values.push(value);\n            }\n        },\n\n        delete: function(value) {\n            var index = this._index[value];\n            if (index !== undefined) {\n                this._values[index] = DELETED;\n                delete this._index[value];\n            }\n        },\n\n        clear: function() {\n            this._index = {};\n            this._values = [];\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(LegacySet.fn, {\n            size: {\n                get: function() {\n                    return this._values.length;\n                }\n            }\n        });\n    }\n\n    var SetWrapper = Class.extend({\n        init: function(values) {\n            this._set = new Set(values);\n        },\n\n        values: function() {\n            return Array.from(this._set);\n        },\n\n        has: function(value) {\n            return this._set.has(value);\n        },\n\n        add: function(value) {\n            this._set.add(value);\n        },\n\n        delete: function(value) {\n            this._set.delete(value);\n        },\n\n        clear: function() {\n            this._set.clear();\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(SetWrapper.fn, {\n            size: {\n                get: function() {\n                    return this._set.size;\n                }\n            }\n        });\n    }\n\n    // TODO: Drop LegacySet when removing support for IE10\n    var supportsSet = function () {\n        var supported = false;\n\n        if (typeof Set === 'function') {\n            var set = new Set([1]);\n            supported = set.has(1);\n        }\n\n        return supported;\n    };\n\n    function createHashSet(values) {\n        if (supportsSet()) {\n            return new SetWrapper(values);\n        }\n\n        return new LegacySet(values);\n    }\n\n    function defaultErrorHandler(error) {\n        throw error;\n    }\n\n    var keys = {\n        INSERT: 45,\n        DELETE: 46,\n        BACKSPACE: 8,\n        TAB: 9,\n        ENTER: 13,\n        ESC: 27,\n        LEFT: 37,\n        UP: 38,\n        RIGHT: 39,\n        DOWN: 40,\n        END: 35,\n        HOME: 36,\n        SPACEBAR: 32,\n        PAGEUP: 33,\n        PAGEDOWN: 34,\n        F2: 113,\n        F10: 121,\n        F12: 123,\n        NUMPAD_PLUS: 107,\n        NUMPAD_MINUS: 109,\n        NUMPAD_DOT: 110\n    };\n\n    function hasOwnProperty(obj, property) {\n        return Object.prototype.hasOwnProperty.call(obj, property);\n    }\n\n    // Based on the implementation from kendo-spreadsheet-common/src/calc.js\n    var Matrix$1 = Class.extend({\n        init: function() {\n            this.height = 0;\n            this.width = 0;\n            this.data = [];\n        },\n\n        clone: function() {\n            var m = new Matrix$1();\n            m.height = this.height;\n            m.width = this.width;\n            m.data = this.data.map(function (row) { return row.slice(); });\n            return m;\n        },\n\n        get: function(row, col) {\n            var line = this.data[row];\n            var val = line ? line[col] : null;\n            return val;\n        },\n\n        set: function(row, col, data) {\n            var line = this.data[row];\n            if (line == null) {\n                line = this.data[row] = [];\n            }\n            line[col] = data;\n            if (row >= this.height) {\n                this.height = row + 1;\n            }\n            if (col >= this.width) {\n                this.width = col + 1;\n            }\n        },\n\n        each: function(f, includeEmpty) {\n            var this$1$1 = this;\n\n            for (var row = 0; row < this.height; ++row) {\n                for (var col = 0; col < this.width; ++col) {\n                    var val = this$1$1.get(row, col);\n                    if (includeEmpty || val != null) {\n                        val = f(val, row, col);\n                        if (val !== undefined) {\n                            return val;\n                        }\n                    }\n                }\n            }\n        },\n\n        map: function(f, includeEmpty) {\n            var m = new Matrix$1();\n            this.each(function(el, row, col) {\n                m.set(row, col, f(el, row, col));\n            }, includeEmpty);\n            return m;\n        },\n\n        transpose: function() {\n            var m = new Matrix$1();\n            this.each(function(el, row, col) {\n                m.set(col, row, el);\n            });\n            return m;\n        },\n\n        unit: function(n) {\n            this.width = this.height = n;\n            var a = this.data = new Array(n);\n            for (var i = n; --i >= 0;) {\n                var row = a[i] = new Array(n);\n                for (var j = n; --j >= 0;) {\n                    row[j] = i === j ? 1 : 0;\n                }\n            }\n            return this;\n        },\n\n        multiply: function(b) {\n            var a = this;\n            var m = new Matrix$1();\n            for (var row = 0; row < a.height; ++row) {\n                for (var col = 0; col < b.width; ++col) {\n                    var s = 0;\n                    for (var i = 0; i < a.width; ++i) {\n                        var va = a.get(row, i);\n                        var vb = b.get(i, col);\n                        if (typeof va === \"number\" && typeof vb === \"number\") {\n                            s += va * vb;\n                        }\n                    }\n                    m.set(row, col, s);\n                }\n            }\n            return m;\n        },\n\n        inverse: function() {\n            var n = this.width;\n            var m = this.augment(new Matrix$1().unit(n));\n            var a = m.data;\n\n            // Gaussian elimination\n            // https://en.wikipedia.org/wiki/Gaussian_elimination#Finding_the_inverse_of_a_matrix\n\n            // 1. Get zeros below main diagonal\n            var loop = function ( k ) {\n                var imax = argmax(k, n, function(i) { return a[i][k]; });\n                if (!a[imax][k]) {\n                    return { v: null }; // singular matrix\n                }\n                if (k !== imax) {\n                    var tmp = a[k];\n                    a[k] = a[imax];\n                    a[imax] = tmp;\n                }\n                for (var i = k + 1; i < n; ++i) {\n                    for (var j = k + 1; j < 2 * n; ++j) {\n                        a[i][j] -= a[k][j] * a[i][k] / a[k][k];\n                    }\n                    a[i][k] = 0;\n                }\n            };\n\n            for (var k = 0; k < n; ++k) {\n                var returned = loop( k );\n\n                if ( returned ) return returned.v;\n            }\n\n            // 2. Get 1-s on main diagonal, dividing by pivot\n            for (var i$1 = 0; i$1 < n; ++i$1) {\n                for (var f = a[i$1][i$1], j$1 = 0; j$1 < 2 * n; ++j$1) {\n                    a[i$1][j$1] /= f;\n                }\n            }\n\n            // 3. Get zeros above main diagonal.  Actually, we only care to compute the right side\n            // here (that will be the inverse), so in the inner loop below we go while j >= n,\n            // instead of j >= k.\n            for (var k$1 = n; --k$1 >= 0;) {\n                for (var i$2 = k$1; --i$2 >= 0;) {\n                    if (a[i$2][k$1]) {\n                        for (var j$2 = 2 * n; --j$2 >= n;) {\n                            a[i$2][j$2] -= a[k$1][j$2] * a[i$2][k$1];\n                        }\n                    }\n                }\n            }\n\n            return m.slice(0, n, n, n);\n        },\n\n        augment: function(m) {\n            var ret = this.clone();\n            var n = ret.width;\n            m.each(function(val, row, col) {\n                ret.set(row, col + n, val);\n            });\n            return ret;\n        },\n\n        slice: function(row, col, height, width) {\n            var this$1$1 = this;\n\n            var m = new Matrix$1();\n            for (var i = 0; i < height; ++i) {\n                for (var j = 0; j < width; ++j) {\n                    m.set(i, j, this$1$1.get(row + i, col + j));\n                }\n            }\n            return m;\n        }\n    });\n\n    function argmax(start, end, f) {\n        var max = f(start), pos = start;\n        for (var i = start + 1; i < end; i++) {\n            var v = f(start);\n            if (v > max) {\n                max = v;\n                pos = start;\n            }\n        }\n        return pos;\n    }\n\n    var STRING$1 = \"string\";\n    var FUNCTION = \"function\";\n\n    var preventDefault = function() {\n        this._defaultPrevented = true;\n    };\n\n    var isDefaultPrevented = function() {\n        return this._defaultPrevented === true;\n    };\n\n    var Observable$$1 = (function (Class$$1) {\n        function Observable$$1() {\n            Class$$1.call(this);\n            this._events = {};\n        }\n\n        if ( Class$$1 ) Observable$$1.__proto__ = Class$$1;\n        Observable$$1.prototype = Object.create( Class$$1 && Class$$1.prototype );\n        Observable$$1.prototype.constructor = Observable$$1;\n\n        Observable$$1.prototype.destroy = function destroy () {\n            this.unbind();\n        };\n\n        Observable$$1.prototype.bind = function bind (event, handlers, one) {\n            var that = this,\n                idx,\n                eventNames = typeof event === STRING$1 ? [event] : event || [],\n                length,\n                original,\n                handler,\n                handlersIsFunction = typeof handlers === FUNCTION,\n                events;\n\n            if (handlers === undefined) {\n                for (idx in event) {\n                    that.bind(idx, event[idx]);\n                }\n\n                return that;\n            }\n\n            /* eslint-disable no-loop-func */\n            var loop = function ( ) {\n                var eventName = eventNames[idx];\n\n                handler = handlersIsFunction ? handlers : handlers[eventName];\n\n                if (handler) {\n                    if (one) {\n                        original = handler;\n                        handler = function() {\n                            that.unbind(eventName, handler);\n                            original.apply(that, arguments);\n                        };\n\n                        handler.original = original;\n                    }\n\n                    events = that._events[eventName] = that._events[eventName] || [];\n                    events.push(handler);\n                }\n            };\n\n            for (idx = 0, length = eventNames.length; idx < length; idx++) loop( );\n            /* eslint-enable no-loop-func */\n\n            return that;\n        };\n\n        Observable$$1.prototype.one = function one (eventNames, handlers) {\n            return this.bind(eventNames, handlers, true);\n        };\n\n        Observable$$1.prototype.first = function first (eventName, handlers) {\n            var that = this,\n                idx,\n                eventNames = typeof eventName === STRING$1 ? [eventName] : eventName,\n                length,\n                handler,\n                handlersIsFunction = typeof handlers === FUNCTION,\n                events;\n\n            for (idx = 0, length = eventNames.length; idx < length; idx++) {\n                var eventName$1 = eventNames[idx];\n\n                handler = handlersIsFunction ? handlers : handlers[eventName$1];\n\n                if (handler) {\n                    events = that._events[eventName$1] = that._events[eventName$1] || [];\n                    events.unshift(handler);\n                }\n            }\n\n            return that;\n        };\n\n        Observable$$1.prototype.trigger = function trigger (eventName, eventArgs) {\n            var that = this,\n                events = that._events[eventName],\n                idx,\n                length;\n\n            if (events) {\n                var e = eventArgs || {};\n\n                e.sender = that;\n\n                e._defaultPrevented = false;\n\n                e.preventDefault = preventDefault;\n\n                e.isDefaultPrevented = isDefaultPrevented;\n\n                events = events.slice();\n\n                for (idx = 0, length = events.length; idx < length; idx++) {\n                    events[idx].call(that, e);\n                }\n\n                return e._defaultPrevented === true;\n            }\n\n            return false;\n        };\n\n        Observable$$1.prototype.unbind = function unbind (eventName, handler) {\n            var that = this,\n                events = that._events[eventName],\n                idx;\n\n            if (eventName === undefined) {\n                that._events = {};\n            } else if (events) {\n                if (handler) {\n                    for (idx = events.length - 1; idx >= 0; idx--) {\n                        if (events[idx] === handler || events[idx].original === handler) {\n                            events.splice(idx, 1);\n                        }\n                    }\n                } else {\n                    that._events[eventName] = [];\n                }\n            }\n\n            return that;\n        };\n\n        Observable$$1.prototype._setEvents = function _setEvents (options) {\n            var this$1$1 = this;\n\n            var length = (this.events || []).length;\n\n            for (var idx = 0; idx < length; idx ++) {\n                var e = this$1$1.events[idx];\n\n                if (this$1$1.options[e] && options[e]) {\n                    this$1$1.unbind(e, this$1$1.options[e]);\n\n                    if (this$1$1._events && this$1$1._events[e]) {\n                        delete this$1$1._events[e];\n                    }\n                }\n            }\n\n            this.bind(this.events, options);\n        };\n\n        return Observable$$1;\n    }(Class));\n\n    function autoMajorUnit(min, max) {\n        var diff = round(max - min, DEFAULT_PRECISION - 1);\n\n        if (diff === 0) {\n            if (max === 0) {\n                return 0.1;\n            }\n\n            diff = Math.abs(max);\n        }\n\n        var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\n        var relativeValue = round((diff / scale), DEFAULT_PRECISION);\n        var scaleMultiplier = 1;\n\n        if (relativeValue < 1.904762) {\n            scaleMultiplier = 0.2;\n        } else if (relativeValue < 4.761904) {\n            scaleMultiplier = 0.5;\n        } else if (relativeValue < 9.523809) {\n            scaleMultiplier = 1;\n        } else {\n            scaleMultiplier = 2;\n        }\n\n        return round(scale * scaleMultiplier, DEFAULT_PRECISION);\n    }\n\n    var Point = Class.extend({\n        init: function(x, y) {\n\n            this.x = x || 0;\n            this.y = y || 0;\n        },\n\n        clone: function() {\n            return new Point(this.x, this.y);\n        },\n\n        equals: function(point) {\n            return point && this.x === point.x && this.y === point.y;\n        },\n\n        rotate: function(center, degrees) {\n            var theta = rad(degrees);\n            var cosT = Math.cos(theta);\n            var sinT = Math.sin(theta);\n            var cx = center.x;\n            var cy = center.y;\n            var ref = this;\n            var x = ref.x;\n            var y = ref.y;\n\n            this.x = round(\n                cx + (x - cx) * cosT + (y - cy) * sinT,\n                COORD_PRECISION\n            );\n\n            this.y = round(\n                cy + (y - cy) * cosT - (x - cx) * sinT,\n                COORD_PRECISION\n            );\n\n            return this;\n        },\n\n        multiply: function(a) {\n\n            this.x *= a;\n            this.y *= a;\n\n            return this;\n        },\n\n        distanceTo: function(point) {\n            var dx = this.x - point.x;\n            var dy = this.y - point.y;\n\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n    });\n\n    Point.onCircle = function(center, angle, radius) {\n        var radians = rad(angle);\n\n        return new Point(\n            center.x - radius * Math.cos(radians),\n            center.y - radius * Math.sin(radians)\n        );\n    };\n\n    var Box = Class.extend({\n        init: function(x1, y1, x2, y2) {\n\n            this.x1 = x1 || 0;\n            this.y1 = y1 || 0;\n            this.x2 = x2 || 0;\n            this.y2 = y2 || 0;\n        },\n\n        equals: function(box) {\n            return this.x1 === box.x1 && this.x2 === box.x2 &&\n                this.y1 === box.y1 && this.y2 === box.y2;\n        },\n\n        width: function() {\n            return this.x2 - this.x1;\n        },\n\n        height: function() {\n            return this.y2 - this.y1;\n        },\n\n        translate: function(dx, dy) {\n            this.x1 += dx;\n            this.x2 += dx;\n            this.y1 += dy;\n            this.y2 += dy;\n\n            return this;\n        },\n\n        move: function(x, y) {\n            var height = this.height();\n            var width = this.width();\n\n            if (defined(x)) {\n                this.x1 = x;\n                this.x2 = this.x1 + width;\n            }\n\n            if (defined(y)) {\n                this.y1 = y;\n                this.y2 = this.y1 + height;\n            }\n\n            return this;\n        },\n\n        wrap: function(targetBox) {\n            this.x1 = Math.min(this.x1, targetBox.x1);\n            this.y1 = Math.min(this.y1, targetBox.y1);\n            this.x2 = Math.max(this.x2, targetBox.x2);\n            this.y2 = Math.max(this.y2, targetBox.y2);\n\n            return this;\n        },\n\n        wrapPoint: function(point) {\n            var arrayPoint = isArray(point);\n            var x = arrayPoint ? point[0] : point.x;\n            var y = arrayPoint ? point[1] : point.y;\n            this.wrap(new Box(x, y, x, y));\n\n            return this;\n        },\n\n        snapTo: function(targetBox, axis) {\n\n            if (axis === X || !axis) {\n                this.x1 = targetBox.x1;\n                this.x2 = targetBox.x2;\n            }\n\n            if (axis === Y || !axis) {\n                this.y1 = targetBox.y1;\n                this.y2 = targetBox.y2;\n            }\n\n            return this;\n        },\n\n        alignTo: function(targetBox, anchor) {\n            var height = this.height();\n            var width = this.width();\n            var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\n            var offset = axis === Y ? height : width;\n\n            if (anchor === CENTER) {\n                var targetCenter = targetBox.center();\n                var center = this.center();\n\n                this.x1 += targetCenter.x - center.x;\n                this.y1 += targetCenter.y - center.y;\n            } else if (anchor === TOP || anchor === LEFT) {\n                this[axis + 1] = targetBox[axis + 1] - offset;\n            } else {\n                this[axis + 1] = targetBox[axis + 2];\n            }\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n\n            return this;\n        },\n\n        shrink: function(dw, dh) {\n\n            this.x2 -= dw;\n            this.y2 -= dh;\n\n            return this;\n        },\n\n        expand: function(dw, dh) {\n            this.shrink(-dw, -dh);\n            return this;\n        },\n\n        pad: function(padding) {\n            var spacing = getSpacing(padding);\n\n            this.x1 -= spacing.left;\n            this.x2 += spacing.right;\n            this.y1 -= spacing.top;\n            this.y2 += spacing.bottom;\n\n            return this;\n        },\n\n        unpad: function(padding) {\n            var spacing = getSpacing(padding);\n\n            spacing.left = -spacing.left;\n            spacing.top = -spacing.top;\n            spacing.right = -spacing.right;\n            spacing.bottom = -spacing.bottom;\n\n            return this.pad(spacing);\n        },\n\n        clone: function() {\n            return new Box(this.x1, this.y1, this.x2, this.y2);\n        },\n\n        center: function() {\n            return new Point(\n                this.x1 + this.width() / 2,\n                this.y1 + this.height() / 2\n            );\n        },\n\n        containsPoint: function(point) {\n\n            return point.x >= this.x1 && point.x <= this.x2 &&\n                   point.y >= this.y1 && point.y <= this.y2;\n        },\n\n        points: function() {\n            return [\n                new Point(this.x1, this.y1),\n                new Point(this.x2, this.y1),\n                new Point(this.x2, this.y2),\n                new Point(this.x1, this.y2)\n            ];\n        },\n\n        getHash: function() {\n            return [ this.x1, this.y1, this.x2, this.y2 ].join(\",\");\n        },\n\n        overlaps: function(box) {\n            return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\n        },\n\n        rotate: function(rotation) {\n            var width = this.width();\n            var height = this.height();\n            var ref = this.center();\n            var cx = ref.x;\n            var cy = ref.y;\n\n            var r1 = rotatePoint(0, 0, cx, cy, rotation);\n            var r2 = rotatePoint(width, 0, cx, cy, rotation);\n            var r3 = rotatePoint(width, height, cx, cy, rotation);\n            var r4 = rotatePoint(0, height, cx, cy, rotation);\n\n            width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\n            height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\n\n            this.x2 = this.x1 + width;\n            this.y2 = this.y1 + height;\n\n            return this;\n        },\n\n        toRect: function() {\n            return new Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\n        },\n\n        hasSize: function() {\n            return this.width() !== 0 && this.height() !== 0;\n        },\n\n        align: function(targetBox, axis, alignment) {\n            var c1 = axis + 1;\n            var c2 = axis + 2;\n            var sizeFunc = axis === X ? WIDTH : HEIGHT;\n            var size = this[sizeFunc]();\n\n            if (inArray(alignment, [ LEFT, TOP ])) {\n                this[c1] = targetBox[c1];\n                this[c2] = this[c1] + size;\n            } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\n                this[c2] = targetBox[c2];\n                this[c1] = this[c2] - size;\n            } else if (alignment === CENTER) {\n                this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\n                this[c2] = this[c1] + size;\n            }\n        }\n    });\n\n    function rotatePoint(x, y, cx, cy, angle) {\n        var theta = rad(angle);\n\n        return new Point(\n            cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\n            cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\n        );\n    }\n\n    var Ring = Class.extend({\n        init: function(center, innerRadius, radius, startAngle, angle) {\n\n            this.center = center;\n            this.innerRadius = innerRadius;\n            this.radius = radius;\n            this.startAngle = startAngle;\n            this.angle = angle;\n        },\n\n        clone: function() {\n            return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n        },\n\n        middle: function() {\n            return this.startAngle + this.angle / 2;\n        },\n\n        setRadius: function(newRadius, innerRadius) {\n            if (innerRadius) {\n                this.innerRadius = newRadius;\n            } else {\n                this.radius = newRadius;\n            }\n\n            return this;\n        },\n\n        point: function(angle, innerRadius) {\n            var radianAngle = rad(angle);\n            var ax = Math.cos(radianAngle);\n            var ay = Math.sin(radianAngle);\n            var radius = innerRadius ? this.innerRadius : this.radius;\n            var x = round(this.center.x - (ax * radius), COORD_PRECISION);\n            var y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n            return new Point(x, y);\n        },\n\n        adjacentBox: function(distance, width, height) {\n            var sector = this.clone().expand(distance);\n            var midAndle = sector.middle();\n            var midPoint = sector.point(midAndle);\n            var hw = width / 2;\n            var hh = height / 2;\n            var sa = Math.sin(rad(midAndle));\n            var ca = Math.cos(rad(midAndle));\n            var x = midPoint.x - hw;\n            var y = midPoint.y - hh;\n\n            if (Math.abs(sa) < 0.9) {\n                x += hw * -ca / Math.abs(ca);\n            }\n\n            if (Math.abs(ca) < 0.9) {\n                y += hh * -sa / Math.abs(sa);\n            }\n\n            return new Box(x, y, x + width, y + height);\n        },\n\n        containsPoint: function(p) {\n            var center = this.center;\n            var innerRadius = this.innerRadius;\n            var radius = this.radius;\n            var startAngle = this.startAngle;\n            var endAngle = this.startAngle + this.angle;\n            var dx = p.x - center.x;\n            var dy = p.y - center.y;\n            var vector = new Point(dx, dy);\n            var startPoint = this.point(startAngle);\n            var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n            var endPoint = this.point(endAngle);\n            var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n            var dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n            return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n                   !clockwise(endVector, vector) &&\n                   dist >= innerRadius * innerRadius && dist <= radius * radius;\n        },\n\n        getBBox: function() {\n            var this$1$1 = this;\n\n            var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n            var startAngle = round(this.startAngle % 360);\n            var endAngle = round((startAngle + this.angle) % 360);\n            var innerRadius = this.innerRadius;\n            var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n            var startAngleIndex = allAngles.indexOf(startAngle);\n            var endAngleIndex = allAngles.indexOf(endAngle);\n            var angles;\n\n            if (startAngle === endAngle) {\n                angles = allAngles;\n            } else {\n                if (startAngleIndex < endAngleIndex) {\n                    angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n                } else {\n                    angles = [].concat(\n                        allAngles.slice(0, endAngleIndex + 1),\n                        allAngles.slice(startAngleIndex, allAngles.length)\n                    );\n                }\n            }\n\n            for (var i = 0; i < angles.length; i++) {\n                var point = this$1$1.point(angles[i]);\n                box.wrapPoint(point);\n                box.wrapPoint(point, innerRadius);\n            }\n\n            if (!innerRadius) {\n                box.wrapPoint(this.center);\n            }\n\n            return box;\n        },\n\n        expand: function(value) {\n            this.radius += value;\n            return this;\n        }\n    });\n\n    function numericComparer(a, b) {\n        return a - b;\n    }\n\n    var Sector = Ring.extend({\n        init: function(center, radius, startAngle, angle) {\n            Ring.fn.init.call(this, center, 0, radius, startAngle, angle);\n        },\n\n        expand: function(value) {\n            return Ring.fn.expand.call(this, value);\n        },\n\n        clone: function() {\n            return new Sector(this.center, this.radius, this.startAngle, this.angle);\n        },\n\n        setRadius: function(newRadius) {\n            this.radius = newRadius;\n\n            return this;\n        }\n    });\n\n    var DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\n\n    var ShapeBuilder = Class.extend({\n        createRing: function(sector, options) {\n            var startAngle = sector.startAngle + 180;\n            var endAngle = sector.angle + startAngle;\n\n            //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\n            if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {\n                endAngle += DIRECTION_ANGLE;\n            }\n\n            var center = new geometry.Point(sector.center.x, sector.center.y);\n            var radius = Math.max(sector.radius, 0);\n            var innerRadius = Math.max(sector.innerRadius, 0);\n            var arc = new geometry.Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radius,\n                radiusY: radius\n            });\n            var path = Path.fromArc(arc, options).close();\n\n            if (innerRadius) {\n                arc.radiusX = arc.radiusY = innerRadius;\n                var innerEnd = arc.pointAt(endAngle);\n                path.lineTo(innerEnd.x, innerEnd.y);\n                path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\n            } else {\n                path.lineTo(center.x, center.y);\n            }\n\n            return path;\n        }\n    });\n\n    ShapeBuilder.current = new ShapeBuilder();\n\n    var ChartElement = Class.extend({\n        init: function(options) {\n\n            this.children = [];\n\n            this.options = deepExtend({}, this.options, this.initUserOptions(options));\n        },\n\n        initUserOptions: function(options) {\n            return options;\n        },\n\n        reflow: function(targetBox) {\n            var children = this.children;\n            var box;\n\n            for (var i = 0; i < children.length; i++) {\n                var currentChild = children[i];\n                currentChild.reflow(targetBox);\n\n                box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\n            }\n\n            this.box = box || targetBox;\n        },\n\n        destroy: function() {\n            var children = this.children;\n\n            if (this.animation) {\n                this.animation.destroy();\n            }\n\n            for (var i = 0; i < children.length; i++) {\n                children[i].destroy();\n            }\n        },\n\n        getRoot: function() {\n            var parent = this.parent;\n\n            return parent ? parent.getRoot() : null;\n        },\n\n        getSender: function() {\n            var service = this.getService();\n            if (service) {\n                return service.sender;\n            }\n        },\n\n        getService: function() {\n            var element = this;\n            while (element) {\n                if (element.chartService) {\n                    return element.chartService;\n                }\n                element = element.parent;\n            }\n        },\n\n        translateChildren: function(dx, dy) {\n            var children = this.children;\n            var childrenCount = children.length;\n\n            for (var i = 0; i < childrenCount; i++) {\n                children[i].box.translate(dx, dy);\n            }\n        },\n\n        append: function() {\n            var arguments$1 = arguments;\n            var this$1$1 = this;\n\n            for (var i = 0; i < arguments.length; i++) {\n                var item = arguments$1[i];\n                this$1$1.children.push(item);\n                item.parent = this$1$1;\n            }\n        },\n\n        renderVisual: function() {\n            if (this.options.visible === false) {\n                return;\n            }\n\n            this.createVisual();\n\n            this.addVisual();\n\n            this.renderChildren();\n\n            this.createAnimation();\n            this.renderComplete();\n        },\n\n        addVisual: function() {\n            if (this.visual) {\n                this.visual.chartElement = this;\n\n                if (this.parent) {\n                    this.parent.appendVisual(this.visual);\n                }\n            }\n        },\n\n        renderChildren: function() {\n            var children = this.children;\n            var length = children.length;\n            for (var i = 0; i < length; i++) {\n                children[i].renderVisual();\n            }\n        },\n\n        createVisual: function() {\n            this.visual = new Group({\n                zIndex: this.options.zIndex,\n                visible: valueOrDefault(this.options.visible, true)\n            });\n        },\n\n        createAnimation: function() {\n            if (this.visual && this.options.animation) {\n                this.animation = drawing.Animation.create(\n                    this.visual, this.options.animation\n                );\n            }\n        },\n\n        appendVisual: function(childVisual) {\n            if (!childVisual.chartElement) {\n                childVisual.chartElement = this;\n            }\n\n            if (childVisual.options.noclip) {\n                this.clipRoot().visual.append(childVisual);\n            } else if (defined(childVisual.options.zIndex)) {\n                this.stackRoot().stackVisual(childVisual);\n            } else if (this.isStackRoot) {\n                this.stackVisual(childVisual);\n            } else if (this.visual) {\n                this.visual.append(childVisual);\n            } else {\n                // Allow chart elements without visuals to\n                // pass through child visuals\n                this.parent.appendVisual(childVisual);\n            }\n        },\n\n        clipRoot: function() {\n            if (this.parent) {\n                return this.parent.clipRoot();\n            }\n\n            return this;\n        },\n\n        stackRoot: function() {\n            if (this.parent) {\n                return this.parent.stackRoot();\n            }\n\n            return this;\n        },\n\n        stackVisual: function(childVisual) {\n            var zIndex = childVisual.options.zIndex || 0;\n            var visuals = this.visual.children;\n            var length = visuals.length;\n            var pos;\n\n            for (pos = 0; pos < length; pos++) {\n                var sibling = visuals[pos];\n                var here = valueOrDefault(sibling.options.zIndex, 0);\n                if (here > zIndex) {\n                    break;\n                }\n            }\n\n            this.visual.insert(pos, childVisual);\n        },\n\n        traverse: function(callback) {\n            var children = this.children;\n            var length = children.length;\n\n            for (var i = 0; i < length; i++) {\n                var child = children[i];\n\n                callback(child);\n                if (child.traverse) {\n                    child.traverse(callback);\n                }\n            }\n        },\n\n        closest: function(match) {\n            var element = this;\n            var matched = false;\n\n            while (element && !matched) {\n                matched = match(element);\n\n                if (!matched) {\n                    element = element.parent;\n                }\n            }\n\n            if (matched) {\n                return element;\n            }\n        },\n\n        renderComplete: function() {},\n\n        hasHighlight: function() {\n            var options = (this.options || {}).highlight;\n            return !(!this.createHighlight || (options && options.visible === false) || this.visible === false);\n        },\n\n        toggleHighlight: function(show, opacity) {\n            var this$1$1 = this;\n\n            var options = (this.options || {}).highlight || {};\n            var customVisual = options.visual;\n            var highlight = this._highlight;\n\n            if (!highlight) {\n                var highlightOptions = {\n                    fill: {\n                        color: WHITE,\n                        opacity: opacity || 0.2\n                    },\n                    stroke: {\n                        color: WHITE,\n                        width: 1,\n                        opacity: opacity || 0.2\n                    }\n                };\n\n                if (customVisual) {\n                    highlight = this._highlight = customVisual(\n                        $.extend(this.highlightVisualArgs(), {\n                            createVisual: function () { return this$1$1.createHighlight(highlightOptions); },\n                            sender: this.getSender(),\n                            series: this.series,\n                            dataItem: this.dataItem,\n                            category: this.category,\n                            value: this.value,\n                            percentage: this.percentage,\n                            runningTotal: this.runningTotal,\n                            total: this.total\n                        })\n                    );\n\n                    if (!highlight) {\n                        return;\n                    }\n                } else {\n                    highlight = this._highlight = this.createHighlight(highlightOptions);\n                }\n\n                if (!defined(highlight.options.zIndex)) {\n                    highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\n                }\n\n                this.appendVisual(highlight);\n            }\n\n            highlight.visible(show);\n        },\n\n        toggleFocusHighlight: function(show) {\n            var options = ((this.options || {}).accessibility || {}).highlight || {};\n            var focusHighlight = this._focusHighlight;\n\n            if (!show && !focusHighlight) {\n                return;\n            }\n\n            if (!focusHighlight) {\n                var rootBackground = this.getRoot().options.background;\n                var highlightColor = autoTextColor(rootBackground);\n                var focusHighlightOptions = {\n                    fill: {\n                        opacity: options.opacity,\n                        color: options.color\n                    },\n                    stroke: $.extend({}, {color: highlightColor}, options.border),\n                    zIndex: options.zIndex\n                };\n\n                focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);\n\n                this.appendVisual(focusHighlight);\n            }\n\n            focusHighlight.visible(show);\n        },\n\n        createGradientOverlay: function(element, options, gradientOptions) {\n            var overlay = new Path($.extend({\n                stroke: {\n                    color: \"none\"\n                },\n                fill: this.createGradient(gradientOptions),\n                closed: element.options.closed\n            }, options));\n\n            overlay.segments.elements(element.segments.elements());\n\n            return overlay;\n        },\n\n        createGradient: function(options) {\n            if (this.parent) {\n                return this.parent.createGradient(options);\n            }\n        },\n\n        supportsPointInactiveOpacity: function() {\n            return true;\n        }\n    });\n\n    ChartElement.prototype.options = { };\n\n    var BoxElement = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.options.margin = getSpacing(this.options.margin);\n            this.options.padding = getSpacing(this.options.padding);\n        },\n\n        reflow: function(targetBox) {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var width = options.width;\n            var height = options.height;\n            var shrinkToFit = options.shrinkToFit;\n            var hasSetSize = width && height;\n            var margin = options.margin;\n            var padding = options.padding;\n            var borderWidth = options.border.width;\n            var box;\n\n            var reflowPaddingBox = function () {\n                this$1$1.align(targetBox, X, options.align);\n                this$1$1.align(targetBox, Y, options.vAlign);\n                this$1$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\n            };\n\n            var contentBox = targetBox.clone();\n            if (hasSetSize) {\n                contentBox.x2 = contentBox.x1 + width;\n                contentBox.y2 = contentBox.y1 + height;\n            }\n\n            if (shrinkToFit) {\n                contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\n            }\n\n            ChartElement.fn.reflow.call(this, contentBox);\n\n            if (hasSetSize) {\n                box = this.box = new Box(0, 0, width, height);\n            } else {\n                box = this.box;\n            }\n\n            if (shrinkToFit && hasSetSize) {\n                reflowPaddingBox();\n                contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\n            } else {\n                contentBox = this.contentBox = box.clone();\n                box.pad(padding).pad(borderWidth).pad(margin);\n                reflowPaddingBox();\n            }\n\n            this.translateChildren(\n                box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\n                box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\n            );\n\n            var children = this.children;\n            for (var i = 0; i < children.length; i++) {\n                var item = children[i];\n                item.reflow(item.box);\n            }\n        },\n\n        align: function(targetBox, axis, alignment) {\n            this.box.align(targetBox, axis, alignment);\n        },\n\n        hasBox: function() {\n            var options = this.options;\n            return options.border.width || options.background;\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            var options = this.options;\n            if (options.visible && this.hasBox()) {\n                this.visual.append(Path.fromRect(\n                    this.paddingBox.toRect(),\n                    this.visualStyle()\n                ));\n            }\n        },\n\n        visualStyle: function() {\n            var options = this.options;\n            var border = options.border || {};\n\n            return {\n                stroke: {\n                    width: border.width,\n                    color: border.color,\n                    opacity: valueOrDefault(border.opacity, options.opacity),\n                    dashType: border.dashType\n                },\n                fill: {\n                    color: options.background,\n                    opacity: options.opacity\n                },\n                cursor: options.cursor\n            };\n        }\n    });\n\n    setDefaultOptions(BoxElement, {\n        align: LEFT,\n        vAlign: TOP,\n        margin: {},\n        padding: {},\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        background: \"\",\n        shrinkToFit: false,\n        width: 0,\n        height: 0,\n        visible: true\n    });\n\n    function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {\n        if (accessibilityOptions) {\n            visual.options.className = accessibilityOptions.className;\n            visual.options.role = accessibilityOptions.role;\n            visual.options.ariaLabel = accessibilityOptions.ariaLabel;\n            visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;\n            visual.options.ariaChecked = accessibilityOptions.ariaChecked;\n        }\n    }\n\n    var ShapeElement = BoxElement.extend({\n        init: function(options, pointData) {\n            BoxElement.fn.init.call(this, options);\n\n            this.pointData = pointData;\n        },\n\n        getElement: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.paddingBox;\n            var type = options.type;\n            var rotation = options.rotation;\n            var center = box.center();\n            var halfWidth = box.width() / 2;\n            var halfHeight = box.height() / 2;\n\n            if (!options.visible || !this.hasBox()) {\n                return null;\n            }\n\n            var style = this.visualStyle();\n            var element;\n\n            if (type === CIRCLE) {\n                element = new drawing.Circle(\n                    new Circle([\n                        round(box.x1 + halfWidth, COORD_PRECISION),\n                        round(box.y1 + halfHeight, COORD_PRECISION)\n                    ], Math.min(halfWidth, halfHeight)),\n                    style\n                );\n            } else if (type === TRIANGLE) {\n                element = Path.fromPoints([\n                    [ box.x1 + halfWidth, box.y1 ],\n                    [ box.x1, box.y2 ],\n                    [ box.x2, box.y2 ]\n                ], style).close();\n            } else if (type === CROSS) {\n                element = new drawing.MultiPath(style);\n\n                element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\n                element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\n            } else {\n                var rect = box.toRect();\n                if (type === ROUNDED_RECT) {\n                    var borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);\n                    rect.setCornerRadius(borderRadius);\n                }\n\n                element = Path.fromRect(rect, style);\n            }\n\n            if (rotation) {\n                element.transform(geometryTransform()\n                    .rotate(-rotation, [ center.x, center.y ])\n                );\n            }\n\n            element.options.zIndex = options.zIndex;\n\n            return element;\n        },\n\n        createElement: function() {\n            var this$1$1 = this;\n\n            var customVisual = this.options.visual;\n            var pointData = this.pointData || {};\n            var visual;\n\n            if (customVisual) {\n                visual = customVisual({\n                    value: pointData.value,\n                    dataItem: pointData.dataItem,\n                    sender: this.getSender(),\n                    series: pointData.series,\n                    category: pointData.category,\n                    rect: this.paddingBox.toRect(),\n                    options: this.visualOptions(),\n                    createVisual: function () { return this$1$1.getElement(); }\n                });\n            } else {\n                visual = this.getElement();\n            }\n\n            return visual;\n        },\n\n        visualOptions: function() {\n            var options = this.options;\n            return {\n                background: options.background,\n                border: options.border,\n                margin: options.margin,\n                padding: options.padding,\n                type: options.type,\n                size: options.width,\n                visible: options.visible\n            };\n        },\n\n        createVisual: function() {\n            this.visual = this.createElement();\n\n            addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);\n        }\n    });\n\n    setDefaultOptions(ShapeElement, {\n        type: CIRCLE,\n        align: CENTER,\n        vAlign: CENTER\n    });\n\n    var LINEAR = \"linear\";\n    var RADIAL = \"radial\";\n\n    var GRADIENTS = {\n        glass: {\n            type: LINEAR,\n            rotation: 0,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0\n            }, {\n                offset: 0.25,\n                color: WHITE,\n                opacity: 0.3\n            }, {\n                offset: 1,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        sharpBevel: {\n            type: RADIAL,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0.55\n            }, {\n                offset: 0.65,\n                color: WHITE,\n                opacity: 0\n            }, {\n                offset: 0.95,\n                color: WHITE,\n                opacity: 0.25\n            } ]\n        },\n        roundedBevel: {\n            type: RADIAL,\n            stops: [ {\n                offset: 0.33,\n                color: WHITE,\n                opacity: 0.06\n            }, {\n                offset: 0.83,\n                color: WHITE,\n                opacity: 0.2\n            }, {\n                offset: 0.95,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        roundedGlass: {\n            type: RADIAL,\n            supportVML: false,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0\n            }, {\n                offset: 0.5,\n                color: WHITE,\n                opacity: 0.3\n            }, {\n                offset: 0.99,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        sharpGlass: {\n            type: RADIAL,\n            supportVML: false,\n            stops: [ {\n                offset: 0,\n                color: WHITE,\n                opacity: 0.2\n            }, {\n                offset: 0.15,\n                color: WHITE,\n                opacity: 0.15\n            }, {\n                offset: 0.17,\n                color: WHITE,\n                opacity: 0.35\n            }, {\n                offset: 0.85,\n                color: WHITE,\n                opacity: 0.05\n            }, {\n                offset: 0.87,\n                color: WHITE,\n                opacity: 0.15\n            }, {\n                offset: 0.99,\n                color: WHITE,\n                opacity: 0\n            } ]\n        },\n        bubbleShadow: {\n            type: RADIAL,\n            center: [ 0.5, 0.5 ],\n            radius: 0.5\n        }\n    };\n\n    function boxDiff(r, s) {\n        if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\n            return s;\n        }\n\n        var a = Math.min(r.x1, s.x1);\n        var b = Math.max(r.x1, s.x1);\n        var c = Math.min(r.x2, s.x2);\n        var d = Math.max(r.x2, s.x2);\n        var e = Math.min(r.y1, s.y1);\n        var f = Math.max(r.y1, s.y1);\n        var g = Math.min(r.y2, s.y2);\n        var h = Math.max(r.y2, s.y2);\n        var boxes = [];\n\n        // X = intersection, 0-7 = possible difference areas\n        // h +-+-+-+\n        // . |5|6|7|\n        // g +-+-+-+\n        // . |3|X|4|\n        // f +-+-+-+\n        // . |0|1|2|\n        // e +-+-+-+\n        // . a b c d\n\n        // we'll always have rectangles 1, 3, 4 and 6\n        boxes[0] = new Box(b, e, c, f);\n        boxes[1] = new Box(a, f, b, g);\n        boxes[2] = new Box(c, f, d, g);\n        boxes[3] = new Box(b, g, c, h);\n\n        // decide which corners\n        if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) { // corners 0 and 7\n            boxes[4] = new Box(a, e, b, f);\n            boxes[5] = new Box(c, g, d, h);\n        } else { // corners 2 and 5\n            boxes[4] = new Box(c, e, d, f);\n            boxes[5] = new Box(a, g, b, h);\n        }\n\n        return grep(boxes, function(box) {\n            return box.height() > 0 && box.width() > 0;\n        })[0];\n    }\n\n    var RootElement = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            var rootOptions = this.options;\n            rootOptions.width = parseInt(rootOptions.width, 10);\n            rootOptions.height = parseInt(rootOptions.height, 10);\n\n            this.gradients = {};\n        },\n\n        reflow: function() {\n            var ref = this;\n            var options = ref.options;\n            var children = ref.children;\n            var currentBox = new Box(0, 0, options.width, options.height);\n\n            this.box = currentBox.unpad(options.margin);\n\n            for (var i = 0; i < children.length; i++) {\n                children[i].reflow(currentBox);\n                currentBox = boxDiff(currentBox, children[i].box) || new Box();\n            }\n        },\n\n        createVisual: function() {\n            this.visual = new Group();\n            this.createBackground();\n        },\n\n        createBackground: function() {\n            var options = this.options;\n            var border = options.border || {};\n            var box = this.box.clone().pad(options.margin).unpad(border.width);\n\n            var background = Path.fromRect(box.toRect(), {\n                stroke: {\n                    color: border.width ? border.color : \"\",\n                    width: border.width,\n                    dashType: border.dashType\n                },\n                fill: {\n                    color: options.background,\n                    opacity: options.opacity\n                },\n                zIndex: -10\n            });\n\n            this.visual.append(background);\n        },\n\n        getRoot: function() {\n            return this;\n        },\n\n        createGradient: function(options) {\n            var gradients = this.gradients;\n            var hashCode = objectKey(options);\n            var gradient = GRADIENTS[options.gradient];\n            var drawingGradient;\n\n            if (gradients[hashCode]) {\n                drawingGradient = gradients[hashCode];\n            } else {\n                var gradientOptions = $.extend({}, gradient, options);\n                if (gradient.type === \"linear\") {\n                    drawingGradient = new drawing.LinearGradient(gradientOptions);\n                } else {\n                    if (options.innerRadius) {\n                        gradientOptions.stops = innerRadialStops(gradientOptions);\n                    }\n                    drawingGradient = new drawing.RadialGradient(gradientOptions);\n                    drawingGradient.supportVML = gradient.supportVML !== false;\n                }\n                gradients[hashCode] = drawingGradient;\n            }\n\n            return drawingGradient;\n        },\n\n        cleanGradients: function() {\n            var gradients = this.gradients;\n            for (var hashCode in gradients) {\n                gradients[hashCode]._observers = [];//add clear observers method in drawing ObserversMixin\n            }\n        },\n\n        size: function() {\n            var options = this.options;\n            return new Box(0, 0, options.width, options.height);\n        }\n    });\n\n    setDefaultOptions(RootElement, {\n        width: DEFAULT_WIDTH,\n        height: DEFAULT_HEIGHT,\n        background: WHITE,\n        border: {\n            color: BLACK,\n            width: 0\n        },\n        margin: getSpacing(5),\n        zIndex: -2\n    });\n\n    function innerRadialStops(options) {\n        var stops = options.stops;\n        var usedSpace = ((options.innerRadius / options.radius) * 100);\n        var length = stops.length;\n        var currentStops = [];\n\n        for (var i = 0; i < length; i++) {\n            var currentStop = $.extend({}, stops[i]);\n            currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\n            currentStops.push(currentStop);\n        }\n\n        return currentStops;\n    }\n\n    var FloatElement = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n            this._initDirection();\n        },\n\n        _initDirection: function() {\n            var options = this.options;\n            if (options.vertical) {\n                this.groupAxis = X;\n                this.elementAxis = Y;\n                this.groupSizeField = WIDTH;\n                this.elementSizeField = HEIGHT;\n                this.groupSpacing = options.spacing;\n                this.elementSpacing = options.vSpacing;\n            } else {\n                this.groupAxis = Y;\n                this.elementAxis = X;\n                this.groupSizeField = HEIGHT;\n                this.elementSizeField = WIDTH;\n                this.groupSpacing = options.vSpacing;\n                this.elementSpacing = options.spacing;\n            }\n        },\n\n        reflow: function(targetBox) {\n            this.box = targetBox.clone();\n            this.reflowChildren();\n        },\n\n        reflowChildren: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var box = ref.box;\n            var elementAxis = ref.elementAxis;\n            var groupAxis = ref.groupAxis;\n            var elementSizeField = ref.elementSizeField;\n            var groupSizeField = ref.groupSizeField;\n            var ref$1 = this.groupOptions();\n            var groups = ref$1.groups;\n            var groupsSize = ref$1.groupsSize;\n            var maxGroupElementsSize = ref$1.maxGroupElementsSize;\n            var groupsCount = groups.length;\n            var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\n\n            if (groupsCount) {\n                var groupStart = groupsStart;\n\n                for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\n                    var group = groups[groupIdx];\n                    var groupElements = group.groupElements;\n                    var elementStart = box[elementAxis + 1];\n                    var groupElementsCount = groupElements.length;\n\n                    for (var idx = 0; idx < groupElementsCount; idx++) {\n                        var element = groupElements[idx];\n                        var elementSize$$1 = this$1$1.elementSize(element);\n                        var groupElementStart = groupStart + this$1$1.alignStart(elementSize$$1[groupSizeField], group.groupSize);\n\n                        var elementBox = new Box();\n                        elementBox[groupAxis + 1] = groupElementStart;\n                        elementBox[groupAxis + 2] = groupElementStart + elementSize$$1[groupSizeField];\n                        elementBox[elementAxis + 1] = elementStart;\n                        elementBox[elementAxis + 2] = elementStart + elementSize$$1[elementSizeField];\n\n                        element.reflow(elementBox);\n\n                        elementStart += elementSize$$1[elementSizeField] + this$1$1.elementSpacing;\n                    }\n                    groupStart += group.groupSize + this$1$1.groupSpacing;\n                }\n                box[groupAxis + 1] = groupsStart;\n                box[groupAxis + 2] = groupsStart + groupsSize;\n                box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\n            }\n        },\n\n        alignStart: function(size, maxSize) {\n            var start = 0;\n            var align = this.options.align;\n            if (align === RIGHT || align === BOTTOM) {\n                start = maxSize - size;\n            } else if (align === CENTER) {\n                start = (maxSize - size) / 2;\n            }\n            return start;\n        },\n\n        groupOptions: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var box = ref.box;\n            var children = ref.children;\n            var elementSizeField = ref.elementSizeField;\n            var groupSizeField = ref.groupSizeField;\n            var elementSpacing = ref.elementSpacing;\n            var groupSpacing = ref.groupSpacing;\n            var maxSize = round(box[elementSizeField]());\n            var childrenCount = children.length;\n            var groups = [];\n\n            var groupSize = 0;\n            var groupElementsSize = 0;\n            var groupsSize = 0;\n            var maxGroupElementsSize = 0;\n            var groupElements = [];\n\n            for (var idx = 0; idx < childrenCount; idx++) {\n                var element = children[idx];\n                if (!element.box) {\n                    element.reflow(box);\n                }\n\n                var elementSize$$1 = this$1$1.elementSize(element);\n                if (this$1$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize$$1[elementSizeField]) > maxSize) {\n                    groups.push({\n                        groupElements: groupElements,\n                        groupSize: groupSize,\n                        groupElementsSize: groupElementsSize\n                    });\n                    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n                    groupsSize += groupSpacing + groupSize;\n                    groupSize = 0;\n                    groupElementsSize = 0;\n                    groupElements = [];\n                }\n                groupSize = Math.max(groupSize, elementSize$$1[groupSizeField]);\n                if (groupElementsSize > 0) {\n                    groupElementsSize += elementSpacing;\n                }\n                groupElementsSize += elementSize$$1[elementSizeField];\n                groupElements.push(element);\n            }\n\n            groups.push({\n                groupElements: groupElements,\n                groupSize: groupSize,\n                groupElementsSize: groupElementsSize\n            });\n            maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\n            groupsSize += groupSize;\n\n            return {\n                groups: groups,\n                groupsSize: groupsSize,\n                maxGroupElementsSize: maxGroupElementsSize\n            };\n        },\n\n        elementSize: function(element) {\n            return {\n                width: element.box.width(),\n                height: element.box.height()\n            };\n        },\n\n        createVisual: function() {}\n    });\n\n    setDefaultOptions(FloatElement, {\n        vertical: true,\n        wrap: true,\n        vSpacing: 0,\n        spacing: 0\n    });\n\n    var DrawingText = drawing.Text;\n\n    var Text = ChartElement.extend({\n        init: function(content, options) {\n            ChartElement.fn.init.call(this, options);\n\n            this.content = content;\n\n            // Calculate size\n            this.reflow(new Box());\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options;\n            var size = options.size = util.measureText(this.content, { font: options.font });\n\n            this.baseline = size.baseline;\n\n            this.box = new Box(targetBox.x1, targetBox.y1,\n                targetBox.x1 + size.width, targetBox.y1 + size.height);\n        },\n\n        createVisual: function() {\n            var ref = this.options;\n            var font = ref.font;\n            var color = ref.color;\n            var opacity = ref.opacity;\n            var cursor = ref.cursor;\n            var stroke = ref.stroke;\n            var paintOrder = ref.paintOrder;\n\n            this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\n                font: font,\n                fill: { color: color, opacity: opacity },\n                cursor: cursor,\n                stroke: stroke,\n                paintOrder: paintOrder\n            });\n        }\n    });\n\n    setDefaultOptions(Text, {\n        font: DEFAULT_FONT,\n        color: BLACK\n    });\n\n    function rectToBox(rect) {\n        var origin = rect.origin;\n        var bottomRight = rect.bottomRight();\n\n        return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);\n    }\n\n    var ROWS_SPLIT_REGEX = /\\n/m;\n\n    var TextBox = BoxElement.extend({\n        init: function(content, options, data) {\n            BoxElement.fn.init.call(this, options);\n            this.content = content;\n            this.data = data;\n\n            this._initContainer();\n            if (this.options._autoReflow !== false) {\n                this.reflow(new Box());\n            }\n        },\n\n        _initContainer: function() {\n            var options = this.options;\n            var rows = String(this.content).split(ROWS_SPLIT_REGEX);\n            var floatElement = new FloatElement({ vertical: true, align: options.align, wrap: false });\n            var textOptions = deepExtend({ }, options, { opacity: 1, animation: null });\n\n            this.container = floatElement;\n            this.append(floatElement);\n\n            for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\n                var text = new Text(rows[rowIdx].trim(), textOptions);\n                floatElement.append(text);\n            }\n        },\n\n        reflow: function(targetBox) {\n            var options = this.options;\n            var visualFn = options.visual;\n            this.container.options.align = options.align;\n\n            if (visualFn && !this._boxReflow) {\n                var visualBox = targetBox;\n                if (!visualBox.hasSize()) {\n                    this._boxReflow = true;\n                    this.reflow(visualBox);\n                    this._boxReflow = false;\n                    visualBox = this.box;\n                }\n                var visual = this.visual = visualFn(this.visualContext(visualBox));\n\n                if (visual) {\n                    visualBox = rectToBox(visual.clippedBBox() || new Rect());\n\n                    visual.options.zIndex = options.zIndex;\n                }\n\n                this.box = this.contentBox = this.paddingBox = visualBox;\n            } else {\n                BoxElement.fn.reflow.call(this, targetBox);\n\n                if (options.rotation) {\n                    var margin = getSpacing(options.margin);\n                    var box = this.box.unpad(margin);\n\n                    this.targetBox = targetBox;\n                    this.normalBox = box.clone();\n\n                    box = this.rotate();\n                    box.translate(margin.left - margin.right, margin.top - margin.bottom);\n\n                    this.rotatedBox = box.clone();\n\n                    box.pad(margin);\n                }\n            }\n        },\n\n        createVisual: function() {\n            var options = this.options;\n\n            this.visual = new Group({\n                transform: this.rotationTransform(),\n                zIndex: options.zIndex,\n                noclip: options.noclip\n            });\n\n            if (this.hasBox()) {\n                var box = Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\n                this.visual.append(box);\n            }\n        },\n\n        renderVisual: function() {\n            if (!this.options.visible) {\n                return;\n            }\n\n            if (this.options.visual) {\n                var visual = this.visual;\n                if (visual && !defined(visual.options.noclip)) {\n                    visual.options.noclip = this.options.noclip;\n                }\n                this.addVisual();\n                this.createAnimation();\n            } else {\n                BoxElement.fn.renderVisual.call(this);\n            }\n        },\n\n        visualContext: function(targetBox) {\n            var this$1$1 = this;\n\n            var context = {\n                text: this.content,\n                rect: targetBox.toRect(),\n                sender: this.getSender(),\n                options: this.options,\n                createVisual: function () {\n                    this$1$1._boxReflow = true;\n                    this$1$1.reflow(targetBox);\n                    this$1$1._boxReflow = false;\n                    return this$1$1.getDefaultVisual();\n                }\n            };\n            if (this.data) {\n                $.extend(context, this.data);\n            }\n\n            return context;\n        },\n\n        getDefaultVisual: function() {\n            this.createVisual();\n            this.renderChildren();\n            var visual = this.visual;\n            delete this.visual;\n            return visual;\n        },\n\n        rotate: function() {\n            var options = this.options;\n            this.box.rotate(options.rotation);\n            this.align(this.targetBox, X, options.align);\n            this.align(this.targetBox, Y, options.vAlign);\n            return this.box;\n        },\n\n        rotationTransform: function() {\n            var rotation = this.options.rotation;\n            if (!rotation) {\n                return null;\n            }\n\n            var ref = this.normalBox.center();\n            var cx = ref.x;\n            var cy = ref.y;\n            var boxCenter = this.rotatedBox.center();\n\n            return geometryTransform()\n                .translate(boxCenter.x - cx, boxCenter.y - cy)\n                .rotate(rotation, [ cx, cy ]);\n        }\n    });\n\n    var Title = ChartElement.extend({\n        init: function(options) {\n            ChartElement.fn.init.call(this, options);\n\n            this._textBox = new TextBox(this.options.text, $.extend({}, this.options, {\n                vAlign: this.options.position\n            }));\n\n            this.append(this._textBox);\n        },\n\n        reflow: function(targetBox) {\n            ChartElement.fn.reflow.call(this, targetBox);\n            this.box.snapTo(targetBox, X);\n        }\n    });\n\n    Title.buildTitle = function(options, defaultOptions) {\n        var titleOptions = options;\n\n        if (typeof options === \"string\") {\n            titleOptions = { text: options };\n        }\n\n        titleOptions = $.extend({ visible: true }, defaultOptions, titleOptions);\n\n        var title;\n        if (titleOptions && titleOptions.visible && titleOptions.text) {\n            title = new Title(titleOptions);\n        }\n\n        return title;\n    };\n\n    Title.orderTitles = function(titles) {\n        var items = [].concat(titles);\n        var top = items.filter(function (item) { return item && item.options.position !== BOTTOM; });\n        var bottom = items.filter(function (item) { return item && item.options.position === BOTTOM; });\n\n        collapseVerticalMargins(top);\n        collapseVerticalMargins(bottom);\n\n        bottom.reverse();\n        return top.concat(bottom);\n    };\n\n    function collapseVerticalMargins(items) {\n        for (var i = 1; i < items.length; i++) {\n            var box = items[i]._textBox;\n            var prevBox = items[i - 1]._textBox;\n            prevBox.options.margin = $.extend(getSpacing(prevBox.options.margin), { bottom: 0 });\n            box.options.margin = $.extend(getSpacing(box.options.margin), { top: 0 });\n        }\n    }\n\n    setDefaultOptions(Title, {\n        color: BLACK,\n        position: TOP,\n        align: CENTER,\n        margin: getSpacing(5),\n        padding: getSpacing(5)\n    });\n\n    var AxisLabel = TextBox.extend({\n        init: function(value, text, index, dataItem, options) {\n            TextBox.fn.init.call(this, text, options);\n\n            this.text = text;\n            this.value = value;\n            this.index = index;\n            this.dataItem = dataItem;\n            this.reflow(new Box());\n        },\n\n        visualContext: function(targetBox) {\n            var context = TextBox.fn.visualContext.call(this, targetBox);\n\n            context.value = this.value;\n            context.dataItem = this.dataItem;\n            context.format = this.options.format;\n            context.culture = this.options.culture;\n\n            return context;\n        },\n\n        click: function(widget, e) {\n\n            widget.trigger(AXIS_LABEL_CLICK, {\n                element: eventElement(e),\n                value: this.value,\n                text: this.text,\n                index: this.index,\n                dataItem: this.dataItem,\n                axis: this.parent.options\n            });\n        },\n\n        rotate: function() {\n            if (this.options.alignRotation !== CENTER) {\n                var box = this.normalBox.toRect();\n                var transform = this.rotationTransform();\n\n                this.box = rectToBox(box.bbox(transform.matrix()));\n            } else {\n                TextBox.fn.rotate.call(this);\n            }\n\n            return this.box;\n        },\n\n        rotationTransform: function() {\n            var options = this.options;\n            var rotation = options.rotation;\n            if (!rotation) {\n                return null;\n            }\n\n            if (options.alignRotation === CENTER) {\n                return TextBox.fn.rotationTransform.call(this);\n            }\n\n            var rotationMatrix = geometryTransform().rotate(rotation).matrix();\n            var box = this.normalBox.toRect();\n            var rect = this.targetBox.toRect();\n\n            var rotationOrigin = options.rotationOrigin || TOP;\n            var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\n            var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\n            var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\n\n            var topLeft = box.topLeft().transformCopy(rotationMatrix);\n            var topRight = box.topRight().transformCopy(rotationMatrix);\n            var bottomRight = box.bottomRight().transformCopy(rotationMatrix);\n            var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\n            var rotatedBox = Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\n\n            var translate = {};\n            translate[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];\n\n            var distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n            var distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\n\n            var alignStart, alignEnd;\n\n            if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\n                alignStart = topLeft;\n                alignEnd = topRight;\n            } else if (distanceRight < distanceLeft) {\n                alignStart = topRight;\n                alignEnd = bottomRight;\n            } else {\n                alignStart = topLeft;\n                alignEnd = bottomLeft;\n            }\n\n            var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\n            translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\n\n            return geometryTransform()\n                .translate(translate.x, translate.y)\n                .rotate(rotation);\n        }\n    });\n\n    setDefaultOptions(AxisLabel, {\n        _autoReflow: false\n    });\n\n    var DEFAULT_ICON_SIZE = 7;\n    var DEFAULT_LABEL_COLOR = \"#fff\";\n\n    var Note = BoxElement.extend({\n        init: function(fields, options, chartService) {\n            BoxElement.fn.init.call(this, options);\n\n            this.fields = fields;\n            this.chartService = chartService;\n\n            this.render();\n        },\n\n        hide: function() {\n            this.options.visible = false;\n        },\n\n        show: function() {\n            this.options.visible = true;\n        },\n\n        render: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n\n            if (options.visible) {\n                var label = options.label;\n                var icon = options.icon;\n                var box = new Box();\n                var childAlias = function () { return this$1$1; };\n                var size = icon.size;\n                var text = this.fields.text;\n                var width, height;\n\n                if (defined(label) && label.visible) {\n                    var noteTemplate = getTemplate(label);\n                    if (noteTemplate) {\n                        text = noteTemplate(this.fields);\n                    } else if (label.format) {\n                        text = this.chartService.format.auto(label.format, text);\n                    }\n\n                    if (!label.color) {\n                        label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n                    }\n\n                    this.label = new TextBox(text, deepExtend({}, label));\n                    this.label.aliasFor = childAlias;\n\n                    if (label.position === INSIDE && !defined(size)) {\n                        if (icon.type === CIRCLE) {\n                            size = Math.max(this.label.box.width(), this.label.box.height());\n                        } else {\n                            width = this.label.box.width();\n                            height = this.label.box.height();\n                        }\n                        box.wrap(this.label.box);\n                    }\n                }\n\n                icon.width = width || size || DEFAULT_ICON_SIZE;\n                icon.height = height || size || DEFAULT_ICON_SIZE;\n\n                var marker = new ShapeElement(deepExtend({}, icon));\n                marker.aliasFor = childAlias;\n\n                this.marker = marker;\n                this.append(marker);\n\n                if (this.label) {\n                    this.append(this.label);\n                }\n\n                marker.reflow(new Box());\n                this.wrapperBox = box.wrap(marker.box);\n            }\n        },\n\n        reflow: function(targetBox) {\n            var ref = this;\n            var options = ref.options;\n            var label = ref.label;\n            var marker = ref.marker;\n            var wrapperBox = ref.wrapperBox;\n            var center = targetBox.center();\n            var length = options.line.length;\n            var position = options.position;\n\n            // TODO: Review\n            if (options.visible) {\n                var lineStart, box, contentBox;\n\n                if (inArray(position, [ LEFT, RIGHT ])) {\n                    if (position === LEFT) {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n                        if (options.line.visible) {\n                            lineStart = [ targetBox.x1, center.y ];\n                            this.linePoints = [\n                                lineStart,\n                                [ contentBox.x2, center.y ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    } else {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n                        if (options.line.visible) {\n                            lineStart = [ targetBox.x2, center.y ];\n                            this.linePoints = [\n                                lineStart,\n                                [ contentBox.x1, center.y ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    }\n                } else {\n                    if (position === BOTTOM) {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n                        if (options.line.visible) {\n                            lineStart = [ center.x, targetBox.y2 ];\n                            this.linePoints = [\n                                lineStart,\n                                [ center.x, contentBox.y1 ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    } else {\n                        contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n                        if (options.line.visible) {\n                            lineStart = [ center.x, targetBox.y1 ];\n                            this.linePoints = [\n                                lineStart,\n                                [ center.x, contentBox.y2 ]\n                            ];\n                            box = contentBox.clone().wrapPoint(lineStart);\n                        }\n                    }\n                }\n\n                if (marker) {\n                    marker.reflow(contentBox);\n                }\n\n                if (label) {\n                    label.reflow(contentBox);\n                    if (marker) {\n                        if (options.label.position === OUTSIDE) {\n                            label.box.alignTo(marker.box, position);\n                        }\n                        label.reflow(label.box);\n                    }\n                }\n\n                this.contentBox = contentBox;\n                this.targetBox = targetBox;\n                this.box = box || contentBox;\n            }\n        },\n\n        createVisual: function() {\n            BoxElement.fn.createVisual.call(this);\n            this.visual.options.noclip = this.options.noclip;\n\n            if (this.options.visible) {\n                this.createLine();\n            }\n        },\n\n        renderVisual: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var customVisual = options.visual;\n            if (options.visible && customVisual) {\n                this.visual = customVisual($.extend(this.fields, {\n                    sender: this.getSender(),\n                    rect: this.targetBox.toRect(),\n                    options: {\n                        background: options.background,\n                        border: options.background,\n                        icon: options.icon,\n                        label: options.label,\n                        line: options.line,\n                        position: options.position,\n                        visible: options.visible\n                    },\n                    createVisual: function () {\n                        this$1$1.createVisual();\n                        this$1$1.renderChildren();\n                        var defaultVisual = this$1$1.visual;\n                        delete this$1$1.visual;\n                        return defaultVisual;\n                    }\n                }));\n                this.addVisual();\n            } else {\n                BoxElement.fn.renderVisual.call(this);\n            }\n        },\n\n        createLine: function() {\n            var options = this.options.line;\n\n            if (this.linePoints) {\n                var path = Path.fromPoints(this.linePoints, {\n                    stroke: {\n                        color: options.color,\n                        width: options.width,\n                        dashType: options.dashType\n                    }\n                });\n\n                alignPathToPixel(path);\n                this.visual.append(path);\n            }\n        },\n\n        click: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(NOTE_CLICK, args)) {\n                e.preventDefault();\n            }\n        },\n\n        over: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            if (!widget.trigger(NOTE_HOVER, args)) {\n                e.preventDefault();\n            }\n        },\n\n        out: function(widget, e) {\n            var args = this.eventArgs(e);\n\n            widget.trigger(NOTE_LEAVE, args);\n        },\n\n        eventArgs: function(e) {\n            var options = this.options;\n\n            return $.extend(this.fields, {\n                element: eventElement(e),\n                text: defined(options.label) ? options.label.text : \"\",\n                visual: this.visual\n            });\n        }\n    });\n\n    setDefaultOptions(Note, {\n        icon: {\n            visible: true,\n            type: CIRCLE\n        },\n        label: {\n            position: INSIDE,\n            visible: true,\n            align: CENTER,\n            vAlign: CENTER\n        },\n        line: {\n            visible: true\n        },\n        visible: true,\n        position: TOP,\n        zIndex: 2\n    });\n\n    var defaultImplementation = {\n        format: function (format, value) { return value; },\n\n        toString: function (value) { return value; },\n\n        parseDate: function (value) { return new Date(value); },\n\n        firstDay: function () { return 0; }\n    };\n\n    var current$1 = defaultImplementation;\n\n    var IntlService = Class.extend({\n\n    });\n\n    IntlService.register = function(userImplementation) {\n        current$1 = userImplementation;\n    };\n\n    if (Object.defineProperties) {\n        Object.defineProperties(IntlService, {\n            implementation: {\n                get: function() {\n                    return current$1;\n                }\n            }\n        });\n    }\n\n    // eslint-disable-next-line no-useless-escape\n    var FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\n\n    var FormatService = Class.extend({\n        init: function(intlService) {\n            this._intlService = intlService;\n        },\n\n        auto: function(formatString) {\n            var values = [], len = arguments.length - 1;\n            while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\n\n            var intl = this.intl;\n\n            if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n                return intl.format.apply(intl, [ formatString ].concat( values ));\n            }\n\n            return intl.toString(values[0], formatString);\n        },\n\n        localeAuto: function(formatString, values, locale) {\n            var intl = this.intl;\n            var result;\n\n            if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\n                result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {\n                    var value = values[parseInt(index, 10)];\n\n                    return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\", locale);\n                });\n            } else {\n                result = intl.toString(values[0], formatString, locale);\n            }\n\n            return result;\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(FormatService.fn, {\n            intl: {\n                get: function() {\n                    return this._intlService || IntlService.implementation;\n                },\n                set: function(value) {\n                    this._intlService = value;\n                }\n            }\n        });\n    }\n\n    var ChartService = Class.extend({\n        init: function(chart, context) {\n            if (context === void 0) { context = {}; }\n\n            this._intlService = context.intlService;\n            this.sender = context.sender || chart;\n            this.format = new FormatService(context.intlService);\n            this.chart = chart;\n            this.rtl = Boolean(context.rtl);\n        },\n\n        notify: function(name, args) {\n            if (this.chart) {\n                this.chart.trigger(name, args);\n            }\n        },\n\n        isPannable: function(axis) {\n            var pannable = ((this.chart || {}).options || {}).pannable;\n            return pannable && pannable.lock !== axis;\n        }\n    });\n\n    if (Object.defineProperties) {\n        Object.defineProperties(ChartService.fn, {\n            intl: {\n                get: function() {\n                    return this._intlService || IntlService.implementation;\n                },\n                set: function(value) {\n                    this._intlService = value;\n                    this.format.intl = value;\n                }\n            }\n        });\n    }\n\n    var current$2;\n\n    var DomEventsBuilder = Class.extend({\n\n    });\n\n    DomEventsBuilder.register = function(userImplementation) {\n        current$2 = userImplementation;\n    };\n\n    DomEventsBuilder.create = function(element, events) {\n        if (current$2) {\n            return current$2.create(element, events);\n        }\n    };\n\n    var services = {\n    \tChartService: ChartService,\n    \tDomEventsBuilder: DomEventsBuilder,\n    \tFormatService: FormatService,\n    \tIntlService: IntlService,\n    \tTemplateService: TemplateService\n    };\n\n    function createAxisTick(options, tickOptions) {\n        var tickX = options.tickX;\n        var tickY = options.tickY;\n        var position = options.position;\n\n        var tick = new Path({\n            stroke: {\n                width: tickOptions.width,\n                color: tickOptions.color\n            }\n        });\n\n        if (options.vertical) {\n            tick.moveTo(tickX, position)\n                .lineTo(tickX + tickOptions.size, position);\n        } else {\n            tick.moveTo(position, tickY)\n                .lineTo(position, tickY + tickOptions.size);\n        }\n\n        alignPathToPixel(tick);\n\n        return tick;\n    }\n\n    function createAxisGridLine(options, gridLine) {\n        var lineStart = options.lineStart;\n        var lineEnd = options.lineEnd;\n        var position = options.position;\n\n        var line = new Path({\n            stroke: {\n                width: gridLine.width,\n                color: gridLine.color,\n                dashType: gridLine.dashType\n            }\n        });\n\n        if (options.vertical) {\n            line.moveTo(lineStart, position)\n                .lineTo(lineEnd, position);\n        } else {\n            line.moveTo(position, lineStart)\n                .lineTo(position, lineEnd);\n        }\n\n        alignPathToPixel(line);\n\n        return line;\n    }\n\n    var Axis = ChartElement.extend({\n        init: function(options, chartService) {\n            if (chartService === void 0) { chartService = new ChartService(); }\n\n            ChartElement.fn.init.call(this, options);\n\n            this.chartService = chartService;\n\n            if (!this.options.visible) {\n                this.options = deepExtend({}, this.options, {\n                    labels: {\n                        visible: false\n                    },\n                    line: {\n                        visible: false\n                    },\n                    margin: 0,\n                    majorTickSize: 0,\n                    minorTickSize: 0\n                });\n            }\n\n            this.options.minorTicks = deepExtend({}, {\n                color: this.options.line.color,\n                width: this.options.line.width,\n                visible: this.options.minorTickType !== NONE\n            }, this.options.minorTicks, {\n                size: this.options.minorTickSize,\n                align: this.options.minorTickType\n            });\n\n            this.options.majorTicks = deepExtend({}, {\n                color: this.options.line.color,\n                width: this.options.line.width,\n                visible: this.options.majorTickType !== NONE\n            }, this.options.majorTicks, {\n                size: this.options.majorTickSize,\n                align: this.options.majorTickType\n            });\n\n            this.initFields();\n\n            if (!this.options._deferLabels) {\n                this.createLabels();\n            }\n\n            this.createTitle();\n            this.createNotes();\n        },\n\n        initFields: function() {\n        },\n\n        labelsRange: function() {\n            return {\n                min: this.options.labels.skip,\n                max: this.labelsCount()\n            };\n        },\n\n        normalizeLabelRotation: function(labelOptions) {\n            var rotation = labelOptions.rotation;\n\n            if (isObject(rotation)) {\n                labelOptions.alignRotation = rotation.align;\n                labelOptions.rotation = rotation.angle;\n            }\n        },\n\n        createLabels: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var align = options.vertical ? RIGHT : CENTER;\n            var labelOptions = deepExtend({ }, options.labels, {\n                align: align,\n                zIndex: options.zIndex\n            });\n            var step = Math.max(1, labelOptions.step);\n\n            this.clearLabels();\n\n            if (labelOptions.visible) {\n                this.normalizeLabelRotation(labelOptions);\n                if (labelOptions.rotation === \"auto\") {\n                    labelOptions.rotation = 0;\n                    options.autoRotateLabels = true;\n                }\n\n                var range = this.labelsRange();\n                for (var idx = range.min; idx < range.max; idx += step) {\n                    var labelContext = { index: idx, count: range.max };\n                    var label = this$1$1.createAxisLabel(idx, labelOptions, labelContext);\n                    if (label) {\n                        this$1$1.append(label);\n                        this$1$1.labels.push(label);\n                    }\n                }\n            }\n        },\n\n        clearLabels: function() {\n            this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\n            this.labels = [];\n        },\n\n        clearTitle: function() {\n            var this$1$1 = this;\n\n            if (this.title) {\n                this.children = grep(this.children, function (child) { return child !== this$1$1.title; });\n                this.title = undefined;\n            }\n        },\n\n        clear: function() {\n            this.clearLabels();\n            this.clearTitle();\n        },\n\n        lineBox: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var axisX = mirror ? box.x1 : box.x2;\n            var axisY = mirror ? box.y2 : box.y1;\n            var lineWidth = options.line.width || 0;\n\n            return vertical ?\n                new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n                new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n        },\n\n        createTitle: function() {\n            var options = this.options;\n            var titleOptions = deepExtend({\n                rotation: options.vertical ? -90 : 0,\n                text: \"\",\n                zIndex: 1,\n                visualSize: true\n            }, options.title);\n\n            if (titleOptions.visible && titleOptions.text) {\n                var title = new TextBox(titleOptions.text, titleOptions);\n                this.append(title);\n                this.title = title;\n            }\n        },\n\n        createNotes: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var notes = options.notes;\n            var items = notes.data || [];\n\n            this.notes = [];\n\n            for (var i = 0; i < items.length; i++) {\n                var item = deepExtend({}, notes, items[i]);\n                item.value = this$1$1.parseNoteValue(item.value);\n\n                var note = new Note({\n                    value: item.value,\n                    text: item.label.text,\n                    dataItem: item\n                }, item, this$1$1.chartService);\n\n                if (note.options.visible) {\n                    if (defined(note.options.position)) {\n                        if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                            note.options.position = options.reverse ? LEFT : RIGHT;\n                        } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                            note.options.position = options.reverse ? BOTTOM : TOP;\n                        }\n                    } else {\n                        if (options.vertical) {\n                            note.options.position = options.reverse ? LEFT : RIGHT;\n                        } else {\n                            note.options.position = options.reverse ? BOTTOM : TOP;\n                        }\n                    }\n                    this$1$1.append(note);\n                    this$1$1.notes.push(note);\n                }\n            }\n        },\n\n        parseNoteValue: function(value) {\n            return value;\n        },\n\n        renderVisual: function() {\n            ChartElement.fn.renderVisual.call(this);\n\n            this.createPlotBands();\n        },\n\n        createVisual: function() {\n            ChartElement.fn.createVisual.call(this);\n\n            this.createBackground();\n            this.createLine();\n        },\n\n        gridLinesVisual: function() {\n            var gridLines = this._gridLines;\n            if (!gridLines) {\n                gridLines = this._gridLines = new Group({\n                    zIndex: -2\n                });\n                this.appendVisual(this._gridLines);\n            }\n\n            return gridLines;\n        },\n\n        createTicks: function(lineGroup) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var mirror = options.labels.mirror;\n            var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n            var tickLineOptions = {\n                // TODO\n                // _alignLines: options._alignLines,\n                vertical: options.vertical\n            };\n\n            function render(tickPositions, tickOptions, skipUnit) {\n                var count = tickPositions.length;\n                var step = Math.max(1, tickOptions.step);\n\n                if (tickOptions.visible) {\n                    for (var i = tickOptions.skip; i < count; i += step) {\n                        if (defined(skipUnit) && (i % skipUnit === 0)) {\n                            continue;\n                        }\n\n                        tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                        tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                        tickLineOptions.position = tickPositions[i];\n\n                        lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                    }\n                }\n            }\n\n            render(this.getMajorTickPositions(), options.majorTicks);\n            render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n        },\n\n        createLine: function() {\n            var options = this.options;\n            var line = options.line;\n            var lineBox = this.lineBox();\n\n            if (line.width > 0 && line.visible) {\n                var path = new Path({\n                    stroke: {\n                        width: line.width,\n                        color: line.color,\n                        dashType: line.dashType\n                    }\n\n                    /* TODO\n                    zIndex: line.zIndex,\n                    */\n                });\n\n                path.moveTo(lineBox.x1, lineBox.y1)\n                    .lineTo(lineBox.x2, lineBox.y2);\n\n                if (options._alignLines) {\n                    alignPathToPixel(path);\n                }\n\n                var group = this._lineGroup = new Group();\n                group.append(path);\n\n                this.visual.append(group);\n                this.createTicks(group);\n            }\n        },\n\n        getActualTickSize: function() {\n            var options = this.options;\n            var tickSize = 0;\n\n            if (options.majorTicks.visible && options.minorTicks.visible) {\n                tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n            } else if (options.majorTicks.visible) {\n                tickSize = options.majorTicks.size;\n            } else if (options.minorTicks.visible) {\n                tickSize = options.minorTicks.size;\n            }\n\n            return tickSize;\n        },\n\n        createBackground: function() {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var background = options.background;\n\n            if (background) {\n                this._backgroundPath = Path.fromRect(box.toRect(), {\n                    fill: {\n                        color: background\n                    },\n                    stroke: null\n                });\n\n                this.visual.append(this._backgroundPath);\n            }\n        },\n\n        createPlotBands: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var plotBands = options.plotBands || [];\n            var vertical = options.vertical;\n            var plotArea = this.plotArea;\n\n            if (plotBands.length === 0) {\n                return;\n            }\n\n            var group = this._plotbandGroup = new Group({\n                zIndex: -1\n            });\n\n            var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1$1.options.vertical; })[0];\n\n            for (var idx = 0; idx < plotBands.length; idx++) {\n                var item = plotBands[idx];\n                var slotX = (void 0), slotY = (void 0);\n                var labelOptions = item.label;\n                var label = (void 0);\n\n                if (vertical) {\n                    slotX = (altAxis || plotArea.axisX).lineBox();\n                    slotY = this$1$1.getSlot(item.from, item.to, true);\n                } else {\n                    slotX = this$1$1.getSlot(item.from, item.to, true);\n                    slotY = (altAxis || plotArea.axisY).lineBox();\n                }\n\n                if (labelOptions) {\n                    labelOptions.vAlign = labelOptions.position || LEFT;\n                    label = this$1$1.createPlotBandLabel(\n                        labelOptions,\n                        item,\n                        new Box(\n                            slotX.x1,\n                            slotY.y1,\n                            slotX.x2,\n                            slotY.y2\n                        )\n\n                    );\n                }\n\n                if (slotX.width() !== 0 && slotY.height() !== 0) {\n                    var bandRect = new Rect(\n                        [ slotX.x1, slotY.y1 ],\n                        [ slotX.width(), slotY.height() ]\n                    );\n\n                    var path = Path.fromRect(bandRect, {\n                        fill: {\n                            color: item.color,\n                            opacity: item.opacity\n                        },\n                        stroke: null\n                    });\n\n                    group.append(path);\n                    if (label) {\n                        group.append(label);\n                    }\n                }\n            }\n\n            this.appendVisual(group);\n        },\n\n        createPlotBandLabel: function(label, item, box) {\n\n            if (label.visible === false) {\n                return null;\n            }\n\n            var text = label.text;\n            var textbox;\n\n            if (defined(label) && label.visible) {\n                var labelTemplate = getTemplate(label);\n                if (labelTemplate) {\n                    text = labelTemplate({ text: text, item: item });\n                } else if (label.format) {\n                    text = this.chartService.format.auto(label.format, text);\n                }\n\n                if (!label.color) {\n                    label.color = this.options.labels.color;\n                }\n            }\n\n            textbox = new TextBox(text, label);\n            textbox.reflow(box);\n            textbox.renderVisual();\n\n            return textbox.visual;\n        },\n\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var minorUnit = options.minorUnit;\n            var vertical = options.vertical;\n            var axisLineVisible = altAxis.options.line.visible;\n            var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n            var lineBox = altAxis.lineBox();\n            var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n            var lineOptions = {\n                lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n                lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n                vertical: vertical\n            };\n            var majorTicks = [];\n\n            var container = this.gridLinesVisual();\n\n            function render(tickPositions, gridLine, skipUnit) {\n                var count = tickPositions.length;\n                var step = Math.max(1, gridLine.step);\n\n                if (gridLine.visible) {\n                    for (var i = gridLine.skip; i < count; i += step) {\n                        var pos = round(tickPositions[i]);\n                        if (!inArray(pos, majorTicks)) {\n                            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                                lineOptions.position = pos;\n                                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                                majorTicks.push(pos);\n                            }\n                        }\n                    }\n                }\n            }\n\n            render(this.getMajorTickPositions(), majorGridLines);\n            render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n            return container.children;\n        },\n\n        reflow: function(box) {\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var title = ref.title;\n            var vertical = options.vertical;\n            var count = labels.length;\n            var sizeFn = vertical ? WIDTH : HEIGHT;\n            var titleSize = title ? title.box[sizeFn]() : 0;\n            var space = this.getActualTickSize() + options.margin + titleSize;\n            var rootBox = (this.getRoot() || {}).box || box;\n            var boxSize = rootBox[sizeFn]();\n            var maxLabelSize = 0;\n\n            for (var i = 0; i < count; i++) {\n                var labelSize = labels[i].box[sizeFn]();\n                if (labelSize + space <= boxSize) {\n                    maxLabelSize = Math.max(maxLabelSize, labelSize);\n                }\n            }\n\n            if (vertical) {\n                this.box = new Box(\n                    box.x1, box.y1,\n                    box.x1 + maxLabelSize + space, box.y2\n                );\n            } else {\n                this.box = new Box(\n                    box.x1, box.y1,\n                    box.x2, box.y1 + maxLabelSize + space\n                );\n            }\n\n            this.arrangeTitle();\n            this.arrangeLabels();\n            this.arrangeNotes();\n        },\n\n        getLabelsTickPositions: function() {\n            return this.getMajorTickPositions();\n        },\n\n        labelTickIndex: function(label) {\n            return label.index;\n        },\n\n        arrangeLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var labelsBetweenTicks = this.labelsBetweenTicks();\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var tickPositions = this.getLabelsTickPositions();\n\n            for (var idx = 0; idx < labels.length; idx++) {\n                var label = labels[idx];\n                var tickIx = this$1$1.labelTickIndex(label);\n                var labelSize = vertical ? label.box.height() : label.box.width();\n                var firstTickPosition = tickPositions[tickIx];\n                var nextTickPosition = tickPositions[tickIx + 1];\n                var positionStart = (void 0), positionEnd = (void 0);\n\n                if (vertical) {\n                    if (labelsBetweenTicks) {\n                        var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                        positionStart = middle - (labelSize / 2);\n                    } else {\n                        positionStart = firstTickPosition - (labelSize / 2);\n                    }\n\n                    positionEnd = positionStart;\n                } else {\n                    if (labelsBetweenTicks) {\n                        positionStart = firstTickPosition;\n                        positionEnd = nextTickPosition;\n                    } else {\n                        positionStart = firstTickPosition - (labelSize / 2);\n                        positionEnd = positionStart + labelSize;\n                    }\n                }\n\n                this$1$1.positionLabel(label, mirror, positionStart, positionEnd);\n            }\n        },\n\n        positionLabel: function(label, mirror, positionStart, positionEnd) {\n            if (positionEnd === void 0) { positionEnd = positionStart; }\n\n            var options = this.options;\n            var vertical = options.vertical;\n            var lineBox = this.lineBox();\n            var labelOffset = this.getActualTickSize() + options.margin;\n            var labelBox;\n\n            if (vertical) {\n                var labelX = lineBox.x2;\n\n                if (mirror) {\n                    labelX += labelOffset;\n                    label.options.rotationOrigin = LEFT;\n                } else {\n                    labelX -= labelOffset + label.box.width();\n                    label.options.rotationOrigin = RIGHT;\n                }\n\n                labelBox = label.box.move(labelX, positionStart);\n            } else {\n                var labelY = lineBox.y1;\n\n                if (mirror) {\n                    labelY -= labelOffset + label.box.height();\n                    label.options.rotationOrigin = BOTTOM;\n                } else {\n                    labelY += labelOffset;\n                    label.options.rotationOrigin = TOP;\n                }\n\n                labelBox = new Box(\n                    positionStart, labelY,\n                    positionEnd, labelY + label.box.height()\n                );\n            }\n\n            label.reflow(labelBox);\n        },\n\n        autoRotateLabelAngle: function(labelBox, slotWidth) {\n            if (labelBox.width() < slotWidth) {\n                return 0;\n            }\n\n            if (labelBox.height() > slotWidth) {\n                return -90;\n            }\n\n            return -45;\n        },\n\n        autoRotateLabels: function() {\n            var this$1$1 = this;\n\n            if (!this.options.autoRotateLabels || this.options.vertical) {\n                return false;\n            }\n\n            var tickPositions = this.getMajorTickPositions();\n            var labels = this.labels;\n            var limit = Math.min(labels.length, tickPositions.length - 1);\n            var angle = 0;\n\n            for (var idx = 0; idx < limit; idx++) {\n                var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n                var labelBox = labels[idx].box;\n                var labelAngle = this$1$1.autoRotateLabelAngle(labelBox, width);\n\n                if (labelAngle !== 0) {\n                    angle = labelAngle;\n                }\n\n                if (angle === -90) {\n                    break;\n                }\n            }\n\n            if (angle !== 0) {\n                for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n                    labels[idx$1].options.rotation = angle;\n                    labels[idx$1].reflow(new Box());\n                }\n\n                return true;\n            }\n        },\n\n        arrangeTitle: function() {\n            var ref = this;\n            var options = ref.options;\n            var title = ref.title;\n            var mirror = options.labels.mirror;\n            var vertical = options.vertical;\n\n            if (title) {\n                if (vertical) {\n                    title.options.align = mirror ? RIGHT : LEFT;\n                    title.options.vAlign = title.options.position;\n                } else {\n                    title.options.align = title.options.position;\n                    title.options.vAlign = mirror ? TOP : BOTTOM;\n                }\n\n                title.reflow(this.box);\n            }\n        },\n\n        arrangeNotes: function() {\n            var this$1$1 = this;\n\n            for (var idx = 0; idx < this.notes.length; idx++) {\n                var item = this$1$1.notes[idx];\n                var value = item.options.value;\n                var slot = (void 0);\n\n                if (defined(value)) {\n                    if (this$1$1.shouldRenderNote(value)) {\n                        item.show();\n                    } else {\n                        item.hide();\n                    }\n\n                    slot = this$1$1.noteSlot(value);\n                } else {\n                    item.hide();\n                }\n\n                item.reflow(slot || this$1$1.lineBox());\n            }\n        },\n\n        noteSlot: function(value) {\n            return this.getSlot(value);\n        },\n\n        alignTo: function(secondAxis) {\n            var lineBox = secondAxis.lineBox();\n            var vertical = this.options.vertical;\n            var pos = vertical ? Y : X;\n\n            this.box.snapTo(lineBox, pos);\n            if (vertical) {\n                this.box.shrink(0, this.lineBox().height() - lineBox.height());\n            } else {\n                this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n            }\n            this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n            this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n        },\n\n        axisLabelText: function(value, options, context) {\n            var this$1$1 = this;\n\n            var text;\n            var tmpl = getTemplate(options);\n            var defaultText = function () {\n                if (!options.format) {\n                    return value;\n                }\n\n                return this$1$1.chartService.format.localeAuto(\n                    options.format, [ value ], options.culture\n                );\n            };\n\n            if (tmpl) {\n                var templateContext = $.extend({}, context, {\n                    get text() { return defaultText(); },\n                    value: value,\n                    format: options.format,\n                    culture: options.culture\n                });\n\n                text = tmpl(templateContext);\n            } else {\n                text = defaultText();\n            }\n\n            return text;\n        },\n\n        slot: function(from , to, limit) {\n            var slot = this.getSlot(from, to, limit);\n            if (slot) {\n                return slot.toRect();\n            }\n        },\n\n        contentBox: function() {\n            var box = this.box.clone();\n            var labels = this.labels;\n            if (labels.length) {\n                var axis = this.options.vertical ? Y : X;\n                if (this.chartService.isPannable(axis)) {\n                    var offset = this.maxLabelOffset();\n                    box[axis + 1] -= offset.start;\n                    box[axis + 2] += offset.end;\n                } else {\n                    if (labels[0].options.visible) {\n                        box.wrap(labels[0].box);\n                    }\n                    var lastLabel = labels[labels.length - 1];\n                    if (lastLabel.options.visible) {\n                        box.wrap(lastLabel.box);\n                    }\n                }\n            }\n\n            return box;\n        },\n\n        maxLabelOffset: function() {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var labelsBetweenTicks = this.labelsBetweenTicks();\n            var tickPositions = this.getLabelsTickPositions();\n            var offsetField = vertical ? Y : X;\n            var labels = this.labels;\n            var startPosition = reverse ? 1 : 0;\n            var endPosition = reverse ? 0 : 1;\n            var maxStartOffset = 0;\n            var maxEndOffset = 0;\n\n            for (var idx = 0; idx < labels.length; idx++) {\n                var label = labels[idx];\n                var tickIx = this$1$1.labelTickIndex(label);\n                var startTick = (void 0), endTick = (void 0);\n\n                if (labelsBetweenTicks) {\n                    startTick = tickPositions[tickIx + startPosition];\n                    endTick = tickPositions[tickIx + endPosition];\n                } else {\n                    startTick = endTick = tickPositions[tickIx];\n                }\n\n                maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n                maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n            }\n\n            return {\n                start: maxStartOffset,\n                end: maxEndOffset\n            };\n        },\n\n        limitRange: function(from, to, min, max, offset) {\n            var options = this.options;\n\n            if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n                return null;\n            }\n\n            if ((to < min && offset > 0) || (max < from && offset < 0)) {\n                return {\n                    min: from,\n                    max: to\n                };\n            }\n\n            var rangeSize = to - from;\n            var minValue = from;\n            var maxValue = to;\n\n            if (from < min && offset < 0) {\n                minValue = limitValue(from, min, max);\n                maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n            } else if (to > max && offset > 0) {\n                maxValue = limitValue(to, min, max);\n                minValue = limitValue(to - rangeSize, min, max - rangeSize);\n            }\n\n            return {\n                min: minValue,\n                max: maxValue\n            };\n        },\n\n        valueRange: function() {\n            return {\n                min: this.seriesMin,\n                max: this.seriesMax\n            };\n        },\n\n        lineDir: function() {\n            /*\n             * Axis line direction:\n             *   * Vertical: up.\n             *   * Horizontal: right.\n             */\n\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n        },\n\n        lineInfo: function() {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var lineBox = this.lineBox();\n            var lineSize = vertical ? lineBox.height() : lineBox.width();\n            var axis = vertical ? Y : X;\n            var axisDir = this.lineDir();\n            var startEdge = axisDir === 1 ? 1 : 2;\n            var axisOrigin = axis + startEdge.toString();\n            var lineStart = lineBox[axisOrigin];\n\n            return {\n                axis: axis,\n                axisOrigin: axisOrigin,\n                axisDir: axisDir,\n                lineBox: lineBox,\n                lineSize: lineSize,\n                lineStart: lineStart\n            };\n        },\n\n        pointOffset: function(point) {\n            var ref = this.lineInfo();\n            var axis = ref.axis;\n            var axisDir = ref.axisDir;\n            var axisOrigin = ref.axisOrigin;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n            var offset = relative / lineSize;\n\n            return offset;\n        },\n\n        scaleToDelta: function(rawScale, range) {\n            // Scale >= 1 would result in axis range of 0.\n            // Scale <= -1 would reverse the scale direction.\n            var MAX_SCALE = 0.999;\n            var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n\n            var delta;\n            if (scale > 0) {\n                delta = range * Math.min(1, scale);\n            } else {\n                delta = range - (range / (1 + scale));\n            }\n\n            return delta;\n        },\n\n        labelsBetweenTicks: function() {\n            return !this.options.justified;\n        },\n\n        prepareUserOptions: function() {\n        }\n    });\n\n    setDefaultOptions(Axis, {\n        labels: {\n            visible: true,\n            rotation: 0,\n            mirror: false,\n            step: 1,\n            skip: 0\n        },\n        line: {\n            width: 1,\n            color: BLACK,\n            visible: true\n        },\n        title: {\n            visible: true,\n            position: CENTER\n        },\n        majorTicks: {\n            align: OUTSIDE,\n            size: 4,\n            skip: 0,\n            step: 1\n        },\n        minorTicks: {\n            align: OUTSIDE,\n            size: 3,\n            skip: 0,\n            step: 1\n        },\n        axisCrossingValue: 0,\n        majorTickType: OUTSIDE,\n        minorTickType: NONE,\n        majorGridLines: {\n            skip: 0,\n            step: 1\n        },\n        minorGridLines: {\n            visible: false,\n            width: 1,\n            color: BLACK,\n            skip: 0,\n            step: 1\n        },\n        // TODO: Move to line or labels options\n        margin: 5,\n        visible: true,\n        reverse: false,\n        justified: true,\n        notes: {\n            label: {\n                text: \"\"\n            }\n        },\n\n        _alignLines: true,\n        _deferLabels: false\n    });\n\n    var MILLISECONDS = \"milliseconds\";\n    var SECONDS = \"seconds\";\n    var MINUTES = \"minutes\";\n    var HOURS = \"hours\";\n    var DAYS = \"days\";\n    var WEEKS = \"weeks\";\n    var MONTHS = \"months\";\n    var YEARS = \"years\";\n\n    var TIME_PER_MILLISECOND = 1;\n    var TIME_PER_SECOND = 1000;\n    var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\n    var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\n    var TIME_PER_DAY = 24 * TIME_PER_HOUR;\n    var TIME_PER_WEEK = 7 * TIME_PER_DAY;\n    var TIME_PER_MONTH = 31 * TIME_PER_DAY;\n    var TIME_PER_YEAR = 365 * TIME_PER_DAY;\n    var TIME_PER_UNIT = {\n        \"years\": TIME_PER_YEAR,\n        \"months\": TIME_PER_MONTH,\n        \"weeks\": TIME_PER_WEEK,\n        \"days\": TIME_PER_DAY,\n        \"hours\": TIME_PER_HOUR,\n        \"minutes\": TIME_PER_MINUTE,\n        \"seconds\": TIME_PER_SECOND,\n        \"milliseconds\": TIME_PER_MILLISECOND\n    };\n\n    function absoluteDateDiff(a, b) {\n        var diff = a.getTime() - b;\n        var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\n\n        return diff - (offsetDiff * TIME_PER_MINUTE);\n    }\n\n    function addTicks(date, ticks) {\n        return new Date(date.getTime() + ticks);\n    }\n\n    function toDate(value) {\n        var result;\n\n        if (value instanceof Date) {\n            result = value;\n        } else if (value) {\n            result = new Date(value);\n        }\n\n        return result;\n    }\n\n    function startOfWeek(date, weekStartDay) {\n        if (weekStartDay === void 0) { weekStartDay = 0; }\n\n        var daysToSubtract = 0;\n        var day = date.getDay();\n\n        if (!isNaN(day)) {\n            while (day !== weekStartDay) {\n                if (day === 0) {\n                    day = 6;\n                } else {\n                    day--;\n                }\n\n                daysToSubtract++;\n            }\n        }\n\n        return addTicks(date, -daysToSubtract * TIME_PER_DAY);\n    }\n\n    function adjustDST(date, hours) {\n        if (hours === 0 && date.getHours() === 23) {\n            date.setHours(date.getHours() + 2);\n            return true;\n        }\n\n        return false;\n    }\n\n    function addHours(date, hours) {\n        var roundedDate = new Date(date);\n\n        roundedDate.setMinutes(0, 0, 0);\n\n        var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\n\n        return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\n    }\n\n    function addDuration(dateValue, value, unit, weekStartDay) {\n        var result = dateValue;\n\n        if (dateValue) {\n            var date = toDate(dateValue);\n            var hours = date.getHours();\n\n            if (unit === YEARS) {\n                result = new Date(date.getFullYear() + value, 0, 1);\n                adjustDST(result, 0);\n            } else if (unit === MONTHS) {\n                result = new Date(date.getFullYear(), date.getMonth() + value, 1);\n                adjustDST(result, hours);\n            } else if (unit === WEEKS) {\n                result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\n                adjustDST(result, hours);\n            } else if (unit === DAYS) {\n                result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\n                adjustDST(result, hours);\n            } else if (unit === HOURS) {\n                result = addHours(date, value);\n            } else if (unit === MINUTES) {\n                result = addTicks(date, value * TIME_PER_MINUTE);\n\n                if (result.getSeconds() > 0) {\n                    result.setSeconds(0);\n                }\n            } else if (unit === SECONDS) {\n                result = addTicks(date, value * TIME_PER_SECOND);\n            } else if (unit === MILLISECONDS) {\n                result = addTicks(date, value);\n            }\n\n            if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\n                result.setMilliseconds(0);\n            }\n        }\n\n        return result;\n    }\n\n    function floorDate(date, unit, weekStartDay) {\n        return addDuration(toDate(date), 0, unit, weekStartDay);\n    }\n\n    function ceilDate(dateValue, unit, weekStartDay) {\n        var date = toDate(dateValue);\n\n        if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\n            return date;\n        }\n\n        return addDuration(date, 1, unit, weekStartDay);\n    }\n\n    function dateComparer(a, b) {\n        if (a && b) {\n            return a.getTime() - b.getTime();\n        }\n\n        return -1;\n    }\n\n    function dateDiff(a, b) {\n        return a.getTime() - b;\n    }\n\n    function toTime(value) {\n        if (isArray(value)) {\n            var result = [];\n            for (var idx = 0; idx < value.length; idx++) {\n                result.push(toTime(value[idx]));\n            }\n\n            return result;\n        } else if (value) {\n            return toDate(value).getTime();\n        }\n    }\n\n    function dateEquals(a, b) {\n        if (a && b) {\n            return toTime(a) === toTime(b);\n        }\n\n        return a === b;\n    }\n\n    function timeIndex(date, start, baseUnit) {\n        return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n    }\n\n    function dateIndex(value, start, baseUnit, baseUnitStep) {\n        var date = toDate(value);\n        var startDate = toDate(start);\n        var index;\n\n        if (baseUnit === MONTHS) {\n            index = (date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12) +\n                timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n        } else if (baseUnit === YEARS) {\n            index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\n        } else if (baseUnit === DAYS || baseUnit === WEEKS) {\n            index = timeIndex(date, startDate, baseUnit);\n        } else {\n            index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\n        }\n\n        return index / baseUnitStep;\n    }\n\n    function duration(a, b, unit) {\n        var diff;\n\n        if (unit === YEARS) {\n            diff = b.getFullYear() - a.getFullYear();\n        } else if (unit === MONTHS) {\n            diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\n        } else if (unit === DAYS) {\n            diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\n        } else {\n            diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\n        }\n\n        return diff;\n    }\n\n    function lteDateIndex(date, sortedDates) {\n        var low = 0;\n        var high = sortedDates.length - 1;\n        var index;\n\n        while (low <= high) {\n            index = Math.floor((low + high) / 2);\n            var currentDate = sortedDates[index];\n\n            if (currentDate < date) {\n                low = index + 1;\n                continue;\n            }\n\n            if (currentDate > date) {\n                high = index - 1;\n                continue;\n            }\n\n            while (dateEquals(sortedDates[index - 1], date)) {\n                index--;\n            }\n\n            return index;\n        }\n\n        if (sortedDates[index] <= date) {\n            return index;\n        }\n\n        return index - 1;\n    }\n\n    function parseDate(intlService, date) {\n        var result;\n        if (isString(date)) {\n            result = intlService.parseDate(date) || toDate(date);\n        } else {\n            result = toDate(date);\n        }\n        return result;\n    }\n\n    function parseDates(intlService, dates) {\n        if (isArray(dates)) {\n            var result = [];\n            for (var idx = 0; idx < dates.length; idx++) {\n                result.push(parseDate(intlService, dates[idx]));\n            }\n\n            return result;\n        }\n\n        return parseDate(intlService, dates);\n    }\n\n    function firstDay(options, intlService) {\n        if (isNumber(options.weekStartDay)) {\n            return options.weekStartDay;\n        }\n\n        if (intlService && intlService.firstDay) {\n            return intlService.firstDay();\n        }\n\n        return 0;\n    }\n\n    var MIN_CATEGORY_POINTS_RANGE = 0.01;\n    var MIN_CATEGORY_RANGE = 0.1;\n\n    function indexOf(value, arr) {\n        if (value instanceof Date) {\n            var length = arr.length;\n            for (var idx = 0; idx < length; idx++) {\n                if (dateEquals(arr[idx], value)) {\n                    return idx;\n                }\n            }\n\n            return -1;\n        }\n\n        return arr.indexOf(value);\n    }\n\n    var CategoryAxis = Axis.extend({\n        initFields: function() {\n            this._ticks = {};\n        },\n\n        categoriesHash: function() {\n            return \"\";\n        },\n\n        clone: function() {\n            var copy = new CategoryAxis($.extend({}, this.options, {\n                categories: this.options.srcCategories\n            }), this.chartService);\n            copy.createLabels();\n\n            return copy;\n        },\n\n        initUserOptions: function(options) {\n            var categories = options.categories || [];\n            var definedMin = defined(options.min);\n            var definedMax = defined(options.max);\n            options.srcCategories = options.categories = categories;\n\n            if ((definedMin || definedMax) && categories.length) {\n                var min = definedMin ? Math.floor(options.min) : 0;\n                var max;\n\n                if (definedMax) {\n                    max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n                } else {\n                    max = categories.length;\n                }\n\n                options.categories = options.categories.slice(min, max);\n            }\n\n            return options;\n        },\n\n        rangeIndices: function() {\n            var options = this.options;\n            var length = options.categories.length || 1;\n            var min = isNumber(options.min) ? options.min % 1 : 0;\n            var max;\n\n            if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n                max = length - (1 - options.max % 1);\n            } else {\n                max = length - (options.justified ? 1 : 0);\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        range: function() {\n            var options = this.options;\n            var min = isNumber(options.min) ? options.min : 0;\n            var max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        roundedRange: function() {\n            return this.range();\n        },\n\n        totalRange: function() {\n            var options = this.options;\n            return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n        },\n\n        scaleOptions: function() {\n            var ref = this.rangeIndices();\n            var min = ref.min;\n            var max = ref.max;\n            var lineBox = this.lineBox();\n            var size = this.options.vertical ? lineBox.height() : lineBox.width();\n            var scale = size / ((max - min) || 1);\n\n            return {\n                scale: scale * (this.options.reverse ? -1 : 1),\n                box: lineBox,\n                min: min,\n                max: max\n            };\n        },\n\n        arrangeLabels: function() {\n            Axis.fn.arrangeLabels.call(this);\n            this.hideOutOfRangeLabels();\n        },\n\n        hideOutOfRangeLabels: function() {\n            var ref = this;\n            var box = ref.box;\n            var labels = ref.labels;\n\n            if (labels.length > 0) {\n                var valueAxis = this.options.vertical ? Y : X;\n                var start = box[valueAxis + 1];\n                var end = box[valueAxis + 2];\n                var firstLabel = labels[0];\n                var lastLabel = last(labels);\n\n                if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                    firstLabel.options.visible = false;\n                }\n                if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                    lastLabel.options.visible = false;\n                }\n            }\n        },\n\n        getMajorTickPositions: function() {\n            return this.getTicks().majorTicks;\n        },\n\n        getMinorTickPositions: function() {\n            return this.getTicks().minorTicks;\n        },\n\n        getLabelsTickPositions: function() {\n            return this.getTicks().labelTicks;\n        },\n\n        tickIndices: function(stepSize) {\n            var ref = this.rangeIndices();\n            var min = ref.min;\n            var max = ref.max;\n            var limit = Math.ceil(max);\n            var current = Math.floor(min);\n            var indices = [];\n\n            while (current <= limit) {\n                indices.push(current);\n                current += stepSize;\n            }\n\n            return indices;\n        },\n\n        getTickPositions: function(stepSize) {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var min = ref$1.min;\n            var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n            var indices = this.tickIndices(stepSize);\n            var positions = [];\n\n            for (var idx = 0; idx < indices.length; idx++) {\n                positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n            }\n\n            return positions;\n        },\n\n        getTicks: function() {\n            var options = this.options;\n            var cache = this._ticks;\n            var range = this.rangeIndices();\n            var lineBox = this.lineBox();\n            var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n            if (cache._hash !== hash) {\n                var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n                cache._hash = hash;\n                cache.labelTicks = this.getTickPositions(1);\n                cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n                cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n            }\n\n            return cache;\n        },\n\n        filterOutOfRangePositions: function(positions, lineBox) {\n            if (!positions.length) {\n                return positions;\n            }\n\n            var axis = this.options.vertical ? Y : X;\n            var inRange = function (position) { return lineBox[axis + 1] <= position && position <= lineBox[axis + 2]; };\n\n            var end = positions.length - 1;\n            var startIndex = 0;\n            while (!inRange(positions[startIndex]) && startIndex <= end) {\n                startIndex++;\n            }\n\n            var endIndex = end;\n\n            while (!inRange(positions[endIndex]) && endIndex >= 0) {\n                endIndex--;\n            }\n\n            return positions.slice(startIndex, endIndex + 1);\n        },\n\n        lineInfo: function() {\n            var ref = this.options;\n            var vertical = ref.vertical;\n            var reverse = ref.reverse;\n            var lineBox = this.lineBox();\n            var lineSize = vertical ? lineBox.height() : lineBox.width();\n            var axis = vertical ? Y : X;\n            var axisDir = reverse ? -1 : 1;\n            var startEdge = axisDir === 1 ? 1 : 2;\n            var axisOrigin = axis + startEdge.toString();\n            var lineStart = lineBox[axisOrigin];\n\n            return {\n                axis: axis,\n                axisOrigin: axisOrigin,\n                axisDir: axisDir,\n                lineBox: lineBox,\n                lineSize: lineSize,\n                lineStart: lineStart\n            };\n        },\n\n        lineDir: function() {\n            /*\n             *  Category axis line direction:\n             *    * Vertical: down.\n             *    * Horizontal: right.\n             */\n\n            var ref = this.options;\n            var reverse = ref.reverse;\n            return reverse ? -1 : 1;\n        },\n\n        getSlot: function(from, to, limit) {\n            var options = this.options;\n            var reverse = options.reverse;\n            var justified = options.justified;\n            var ref = this.scaleOptions();\n            var scale = ref.scale;\n            var box = ref.box;\n            var min = ref.min;\n            var ref$1 = this.lineInfo();\n            var valueAxis = ref$1.axis;\n            var lineStart = ref$1.lineStart;\n\n            var slotBox = box.clone();\n            var singleSlot = !defined(to);\n\n            var start = valueOrDefault(from, 0);\n            var end = valueOrDefault(to, start);\n            end = Math.max(end - 1, start);\n\n            // Fixes transient bug caused by iOS 6.0 JIT\n            // (one can never be too sure)\n            end = Math.max(start, end);\n\n            var p1 = lineStart + (start - min) * scale;\n            var p2 = lineStart + (end + 1 - min) * scale;\n\n            if (singleSlot && justified) {\n                p2 = p1;\n            }\n\n            if (limit) {\n                p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n                p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n            }\n\n            slotBox[valueAxis + 1] = reverse ? p2 : p1;\n            slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n            return slotBox;\n        },\n\n        limitSlot: function(slot) {\n            var vertical = this.options.vertical;\n            var valueAxis = vertical ? Y : X;\n            var lineBox = this.lineBox();\n            var limittedSlot = slot.clone();\n\n            limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n            limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n            return limittedSlot;\n        },\n\n        slot: function(from, to, limit) {\n            var min = Math.floor(this.options.min || 0);\n            var start = from;\n            var end = to;\n\n            if (typeof start === \"string\") {\n                start = this.categoryIndex(start);\n            } else if (isNumber(start)) {\n                start -= min;\n            }\n\n            if (typeof end === \"string\") {\n                end = this.categoryIndex(end);\n            } else if (isNumber(end)) {\n                end -= min;\n            }\n\n            return Axis.fn.slot.call(this, start, end, limit);\n        },\n\n        pointCategoryIndex: function(point) {\n            var ref = this.options;\n            var reverse = ref.reverse;\n            var justified = ref.justified;\n            var vertical = ref.vertical;\n            var valueAxis = vertical ? Y : X;\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var min = ref$1.min;\n            var max = ref$1.max;\n            var startValue = reverse ? max : min;\n            var lineStart = box[valueAxis + 1];\n            var lineEnd = box[valueAxis + 2];\n            var pos = point[valueAxis];\n\n            if (pos < lineStart || pos > lineEnd) {\n                return null;\n            }\n\n            var value = startValue + (pos - lineStart) / scale;\n            var diff = value % 1;\n\n            if (justified) {\n                value = Math.round(value);\n            } else if (diff === 0 && value > 0) {\n                value--;\n            }\n\n            return Math.floor(value);\n        },\n\n        getCategory: function(point) {\n            var index = this.pointCategoryIndex(point);\n\n            if (index === null) {\n                return null;\n            }\n\n            return this.options.categories[index];\n        },\n\n        categoryIndex: function(value) {\n            return this.totalIndex(value) - Math.floor(this.options.min || 0);\n        },\n\n        categoryAt: function(index, total) {\n            var options = this.options;\n\n            return (total ? options.srcCategories : options.categories)[index];\n        },\n\n        categoriesCount: function() {\n            return (this.options.categories || []).length;\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var size = options.vertical ? lineBox.height() : lineBox.width();\n            var range = options.categories.length;\n            var scale = size / range;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            return {\n                min: offset,\n                max: range + offset\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var rangeIndices = this.limitedRangeIndices();\n            var range = rangeIndices.max - rangeIndices.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = rangeIndices.min + minDelta;\n            var max = rangeIndices.max - maxDelta;\n\n            if (max - min < MIN_CATEGORY_RANGE) {\n                max = min + MIN_CATEGORY_RANGE;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var ref = this.totalRange();\n            var totalMin = ref.min;\n            var totalMax = ref.max;\n            var range = this.scaleRange(scale, cursor);\n\n            return {\n                min: limitValue(range.min, totalMin, totalMax),\n                max: limitValue(range.max, totalMin, totalMax)\n            };\n        },\n\n        labelsCount: function() {\n            var labelsRange = this.labelsRange();\n\n            return labelsRange.max - labelsRange.min;\n        },\n\n        labelsRange: function() {\n            var options = this.options;\n            var justified = options.justified;\n            var labelOptions = options.labels;\n            var ref = this.limitedRangeIndices(true);\n            var min = ref.min;\n            var max = ref.max;\n            var start = Math.floor(min);\n\n            if (!justified) {\n                min = Math.floor(min);\n                max = Math.ceil(max);\n            } else {\n                min = Math.ceil(min);\n                max = Math.floor(max);\n            }\n\n            var skip;\n\n            if (min > labelOptions.skip) {\n                skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n            } else {\n                skip = labelOptions.skip;\n            }\n\n            return {\n                min: skip - start,\n                max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n            };\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var options = this.options;\n            var dataItem = options.dataItems ? options.dataItems[index] : null;\n            var category = valueOrDefault(options.categories[index], \"\");\n\n            labelContext.dataItem = dataItem;\n            var text = this.axisLabelText(category, labelOptions, labelContext);\n\n            return new AxisLabel(category, text, index, dataItem, labelOptions);\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.limitedRangeIndices();\n\n            return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n        },\n\n        noteSlot: function(value) {\n            var options = this.options;\n            var index = value - Math.floor(options.min || 0);\n            return this.getSlot(index);\n        },\n\n        arrangeNotes: function() {\n            Axis.fn.arrangeNotes.call(this);\n            this.hideOutOfRangeNotes();\n        },\n\n        hideOutOfRangeNotes: function() {\n            var ref = this;\n            var notes = ref.notes;\n            var box = ref.box;\n            if (notes && notes.length) {\n                var valueAxis = this.options.vertical ? Y : X;\n                var start = box[valueAxis + 1];\n                var end = box[valueAxis + 2];\n\n                for (var idx = 0; idx < notes.length; idx++) {\n                    var note = notes[idx];\n                    if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                        note.hide();\n                    }\n                }\n            }\n        },\n\n        pan: function(delta) {\n            var range = this.limitedRangeIndices(true);\n            var ref = this.scaleOptions();\n            var scale = ref.scale;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n            var totalRange = this.totalRange();\n            var min = range.min + offset;\n            var max = range.max + offset;\n\n            return this.limitRange(min, max, 0, totalRange.max, offset);\n        },\n\n        pointsRange: function(start, end) {\n            var ref = this.options;\n            var reverse = ref.reverse;\n            var vertical = ref.vertical;\n            var valueAxis = vertical ? Y : X;\n            var range = this.limitedRangeIndices(true);\n            var ref$1 = this.scaleOptions();\n            var scale = ref$1.scale;\n            var box = ref$1.box;\n            var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n            var diffStart = start[valueAxis] - lineStart;\n            var diffEnd = end[valueAxis] - lineStart;\n\n            var min = range.min + diffStart / scale;\n            var max = range.min + diffEnd / scale;\n            var rangeMin = Math.min(min, max);\n            var rangeMax = Math.max(min, max);\n\n            if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n                return {\n                    min: rangeMin,\n                    max: rangeMax\n                };\n            }\n        },\n\n        valueRange: function() {\n            return this.range();\n        },\n\n        totalIndex: function(value) {\n            var options = this.options;\n            var index = this._categoriesMap ?\n                this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n            return index;\n        },\n\n        currentRangeIndices: function() {\n            var options = this.options;\n            var min = 0;\n\n            if (isNumber(options.min)) {\n                min = Math.floor(options.min);\n            }\n\n            var max;\n            if (isNumber(options.max)) {\n                max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n            } else {\n                max = this.totalCount() - 1;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        limitedRangeIndices: function(totalLimit) {\n            var options = this.options;\n            var min = isNumber(options.min) ? options.min : 0;\n            var max;\n\n            if (isNumber(options.max)) {\n                max = options.max;\n            } else if (isNumber(options.min)) {\n                max = min + options.categories.length;\n            } else {\n                max = this.totalRange().max || 1;\n            }\n\n            if (totalLimit) {\n                var totalRange = this.totalRange();\n                min = limitValue(min, 0, totalRange.max);\n                max = limitValue(max, 0, totalRange.max);\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        totalRangeIndices: function() {\n            return {\n                min: 0,\n                max: this.totalRange().max || 1\n            };\n        },\n\n        indexCategories: function() {\n            if (!this._categoriesMap) {\n                var map$$1 = this._categoriesMap = new HashMap();\n                var srcCategories = this.options.srcCategories;\n                for (var idx = 0; idx < srcCategories.length; idx++) {\n                    map$$1.set(srcCategories[idx], idx);\n                }\n            }\n        },\n\n        totalCount: function() {\n            return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n        }\n    });\n\n    setDefaultOptions(CategoryAxis, {\n        type: \"category\",\n        vertical: false,\n        majorGridLines: {\n            visible: false,\n            width: 1,\n            color: BLACK\n        },\n        labels: {\n            zIndex: 1\n        },\n        justified: false,\n        _deferLabels: true\n    });\n\n    var COORDINATE_LIMIT = 300000;\n\n    var DateLabelFormats = {\n        milliseconds: \"HH:mm:ss.fff\",\n        seconds: \"HH:mm:ss\",\n        minutes: \"HH:mm\",\n        hours: \"HH:mm\",\n        days: \"M/d\",\n        weeks: \"M/d\",\n        months: \"MMM 'yy\",\n        years: \"yyyy\"\n    };\n\n    var ZERO_THRESHOLD = 0.2;\n\n    var AUTO = \"auto\";\n    var BASE_UNITS = [\n        MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\n    ];\n    var FIT = \"fit\";\n\n    function categoryRange(categories, clearCache) {\n        if (clearCache) {\n            categories._range = undefined;\n        }\n\n        var range = categories._range;\n        if (!range) {\n            range = categories._range = sparseArrayLimits(categories);\n            range.min = toDate(range.min);\n            range.max = toDate(range.max);\n        }\n\n        return range;\n    }\n\n    var EmptyDateRange = Class.extend({\n        init: function(options) {\n            this.options = options;\n        },\n\n        displayIndices: function() {\n            return {\n                min: 0,\n                max: 1\n            };\n        },\n\n        displayRange: function() {\n            return {};\n        },\n\n        total: function() {\n            return {};\n        },\n\n        valueRange: function() {\n            return {};\n        },\n\n        valueIndex: function() {\n            return -1;\n        },\n\n        values: function() {\n            return [];\n        },\n\n        totalIndex: function() {\n            return -1;\n        },\n\n        valuesCount: function() {\n            return 0;\n        },\n\n        totalCount: function() {\n            return 0;\n        },\n\n        dateAt: function() {\n            return null;\n        }\n    });\n\n    var DateRange = Class.extend({\n        init: function(start, end, options) {\n            this.options = options;\n            options.baseUnitStep = options.baseUnitStep || 1;\n\n            var roundToBaseUnit = options.roundToBaseUnit;\n            var justified = options.justified;\n\n            this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n            var lowerEnd = this.roundToTotalStep(end);\n            var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n\n            this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n\n            var min = options.min || start;\n            this.valueStart = this.roundToTotalStep(min);\n            this.displayStart = roundToBaseUnit ? this.valueStart : min;\n\n            var max = options.max;\n            if (!max) {\n                this.valueEnd = lowerEnd;\n                this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n            } else {\n                var next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n                this.valueEnd = this.roundToTotalStep(max, false, next);\n                this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n            }\n\n            if (this.valueEnd < this.valueStart) {\n                this.valueEnd = this.valueStart;\n            }\n            if (this.displayEnd <= this.displayStart) {\n                this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n            }\n        },\n\n        displayRange: function() {\n            return {\n                min: this.displayStart,\n                max: this.displayEnd\n            };\n        },\n\n        displayIndices: function() {\n            if (!this._indices) {\n                var options = this.options;\n\n                var baseUnit = options.baseUnit;\n                var baseUnitStep = options.baseUnitStep;\n\n                var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n                var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n\n                this._indices = { min: minIdx, max: maxIdx };\n            }\n\n            return this._indices;\n        },\n\n        total: function() {\n            return {\n                min: this.start,\n                max: this.end\n            };\n        },\n\n        totalCount: function() {\n            var last$$1 = this.totalIndex(this.end);\n\n            return last$$1 + (this.options.justified ? 1 : 0);\n        },\n\n        valueRange: function() {\n            return {\n                min: this.valueStart,\n                max: this.valueEnd\n            };\n        },\n\n        valueIndex: function(value) {\n            var options = this.options;\n            return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n        },\n\n        totalIndex: function(value) {\n            var options = this.options;\n            return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n        },\n\n        dateIndex: function(value) {\n            var options = this.options;\n            return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n        },\n\n        valuesCount: function() {\n            var maxIdx = this.valueIndex(this.valueEnd);\n\n            return maxIdx + 1;\n        },\n\n        values: function() {\n            var values = this._values;\n            if (!values) {\n                var options = this.options;\n                var range = this.valueRange();\n                this._values = values = [];\n\n                for (var date = range.min; date <= range.max;) {\n                    values.push(date);\n                    date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n                }\n            }\n\n            return values;\n        },\n\n        dateAt: function(index, total) {\n            var options = this.options;\n\n            return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n        },\n\n        roundToTotalStep: function(value, upper, next) {\n            var ref = this.options;\n            var baseUnit = ref.baseUnit;\n            var baseUnitStep = ref.baseUnitStep;\n            var weekStartDay = ref.weekStartDay;\n            var start = this.start;\n\n            var step = dateIndex(value, start, baseUnit, baseUnitStep);\n            var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n            if (next) {\n                roundedStep += next;\n            }\n\n            return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n        }\n    });\n\n    function autoBaseUnit(options, startUnit, startStep) {\n        var categoryLimits = categoryRange(options.categories);\n        var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n        var autoBaseUnitSteps = options.autoBaseUnitSteps;\n        var maxDateGroups = options.maxDateGroups;\n        var autoUnit = options.baseUnit === FIT;\n        var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n        var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n        var units = span / TIME_PER_UNIT[baseUnit];\n        var totalUnits = units;\n        var unitSteps, step, nextStep;\n\n        while (!step || units >= maxDateGroups) {\n            unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n            do {\n                nextStep = unitSteps.shift();\n            } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n            if (nextStep) {\n                step = nextStep;\n                units = totalUnits / step;\n            } else if (baseUnit === last(BASE_UNITS)) {\n                step = Math.ceil(totalUnits / maxDateGroups);\n                break;\n            } else if (autoUnit) {\n                baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n                totalUnits = span / TIME_PER_UNIT[baseUnit];\n                unitSteps = null;\n            } else {\n                if (units > maxDateGroups) {\n                    step = Math.ceil(totalUnits / maxDateGroups);\n                }\n                break;\n            }\n        }\n\n        options.baseUnitStep = step;\n        options.baseUnit = baseUnit;\n    }\n\n    function defaultBaseUnit(options) {\n        var categories = options.categories;\n        var count = defined(categories) ? categories.length : 0;\n        var minDiff = MAX_VALUE;\n        var lastCategory, unit;\n\n        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n            var category = categories[categoryIx];\n\n            if (category && lastCategory) {\n                var diff = Math.abs(absoluteDateDiff(category, lastCategory));\n\n                if (diff !== 0) {\n                    minDiff = Math.min(minDiff, diff);\n\n                    if (minDiff >= TIME_PER_YEAR) {\n                        unit = YEARS;\n                    } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n                        unit = MONTHS;\n                    } else if (minDiff >= TIME_PER_WEEK) {\n                        unit = WEEKS;\n                    } else if (minDiff >= TIME_PER_DAY) {\n                        unit = DAYS;\n                    } else if (minDiff >= TIME_PER_HOUR) {\n                        unit = HOURS;\n                    } else if (minDiff >= TIME_PER_MINUTE) {\n                        unit = MINUTES;\n                    } else {\n                        unit = SECONDS;\n                    }\n                }\n            }\n\n            lastCategory = category;\n        }\n\n        options.baseUnit = unit || DAYS;\n    }\n\n    function initUnit(options) {\n        var baseUnit = (options.baseUnit || \"\").toLowerCase();\n        var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n        if (useDefault) {\n            defaultBaseUnit(options);\n        }\n\n        if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n            autoBaseUnit(options);\n        }\n\n        return options;\n    }\n\n    var DateCategoryAxis = CategoryAxis.extend({\n        clone: function() {\n            var copy = new DateCategoryAxis($.extend({}, this.options), this.chartService);\n            copy.createLabels();\n\n            return copy;\n        },\n\n        categoriesHash: function() {\n            var start = this.dataRange.total().min;\n            return this.options.baseUnit + this.options.baseUnitStep + start;\n        },\n\n        initUserOptions: function(options) {\n            return options;\n        },\n\n        initFields: function() {\n            CategoryAxis.fn.initFields.call(this);\n\n            var chartService = this.chartService;\n            var intlService = chartService.intl;\n            var options = this.options;\n\n            var categories = options.categories || [];\n            if (!categories._parsed) {\n                categories = parseDates(intlService, categories);\n                categories._parsed = true;\n            }\n\n            options = deepExtend({\n                roundToBaseUnit: true\n            }, options, {\n                categories: categories,\n                min: parseDate(intlService, options.min),\n                max: parseDate(intlService, options.max),\n                weekStartDay: firstDay(options, intlService)\n            });\n\n            if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n                options.roundToBaseUnit = false;\n            }\n\n            options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n            options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n\n            this.options = options;\n            options.srcCategories = categories;\n\n            if (categories.length > 0) {\n                var range = categoryRange(categories, true);\n                var maxDivisions = options.maxDivisions;\n                var safeOptions = initUnit(options);\n\n                var forecast = options._forecast;\n                if (forecast) {\n                    if (forecast.before > 0) {\n                        range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);\n                    }\n\n                    if (forecast.after > 0) {\n                        range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);\n                    }\n                }\n\n                this.dataRange = new DateRange(range.min, range.max, safeOptions);\n\n                if (maxDivisions) {\n                    var dataRange = this.dataRange.displayRange();\n\n                    var divisionOptions = $.extend({}, options, {\n                        justified: true,\n                        roundToBaseUnit: false,\n                        baseUnit: 'fit',\n                        min: dataRange.min,\n                        max: dataRange.max,\n                        maxDateGroups: maxDivisions\n                    });\n\n                    var dataRangeOptions = this.dataRange.options;\n\n                    autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n\n                    this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n                } else {\n                    this.divisionRange = this.dataRange;\n                }\n\n            } else {\n                options.baseUnit = options.baseUnit || DAYS;\n                this.dataRange = this.divisionRange = new EmptyDateRange(options);\n            }\n\n            this.rangeLabels = [];\n        },\n\n        tickIndices: function(stepSize) {\n            var ref = this;\n            var dataRange = ref.dataRange;\n            var divisionRange = ref.divisionRange;\n            var valuesCount = divisionRange.valuesCount();\n\n            if (!this.options.maxDivisions || !valuesCount) {\n                return CategoryAxis.fn.tickIndices.call(this, stepSize);\n            }\n\n            var indices = [];\n            var values = divisionRange.values();\n            var offset = 0;\n\n            if (!this.options.justified) {\n                values = values.concat(divisionRange.dateAt(valuesCount));\n                offset = 0.5;//align ticks to the center of not justified categories\n            }\n\n            for (var idx = 0; idx < values.length; idx++) {\n                indices.push(dataRange.dateIndex(values[idx]) + offset);\n                if (stepSize !== 1 && idx >= 1) {\n                    var last$$1 = indices.length - 1;\n                    indices.splice(idx, 0, indices[last$$1 - 1] + (indices[last$$1] - indices[last$$1 - 1]) * stepSize);\n                }\n            }\n\n            return indices;\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n            var categories = this.options.categories || [];\n\n            return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n        },\n\n        parseNoteValue: function(value) {\n            return parseDate(this.chartService.intl, value);\n        },\n\n        noteSlot: function(value) {\n            return this.getSlot(value);\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var baseUnit = options.baseUnit;\n            var weekStartDay = options.weekStartDay;\n            var vertical = options.vertical;\n            var lineBox = this.lineBox();\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var range = this.range();\n            var scale = size / (range.max - range.min);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if (range.min && range.max) {\n                var from = addTicks(options.min || range.min, offset);\n                var to = addTicks(options.max || range.max, offset);\n\n                range = {\n                    min: addDuration(from, 0, baseUnit, weekStartDay),\n                    max: addDuration(to, 0, baseUnit, weekStartDay)\n                };\n            }\n\n            return range;\n        },\n\n        labelsRange: function() {\n            return {\n                min: this.options.labels.skip,\n                max: this.divisionRange.valuesCount()\n            };\n        },\n\n        pan: function(delta) {\n            if (this.isEmpty()) {\n                return null;\n            }\n\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var size = options.vertical ? lineBox.height() : lineBox.width();\n            var ref = this.dataRange.displayRange();\n            var min = ref.min;\n            var max = ref.max;\n            var totalLimits = this.dataRange.total();\n            var scale = size / (max - min);\n            var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n            var from = addTicks(min, offset);\n            var to = addTicks(max, offset);\n\n            var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n            if (panRange) {\n                panRange.min = toDate(panRange.min);\n                panRange.max = toDate(panRange.max);\n                panRange.baseUnit = options.baseUnit;\n                panRange.baseUnitStep = options.baseUnitStep || 1;\n                panRange.userSetBaseUnit = options.userSetBaseUnit;\n                panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n\n                return panRange;\n            }\n        },\n\n        pointsRange: function(start, end) {\n            if (this.isEmpty()) {\n                return null;\n            }\n\n            var pointsRange = CategoryAxis.fn.pointsRange.call(this, start, end);\n            var datesRange = this.dataRange.displayRange();\n            var indicesRange = this.dataRange.displayIndices();\n            var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n            var options = this.options;\n\n            var min = addTicks(datesRange.min, pointsRange.min * scale);\n            var max = addTicks(datesRange.min, pointsRange.max * scale);\n\n            return {\n                min: min,\n                max: max,\n                baseUnit: options.userSetBaseUnit || options.baseUnit,\n                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            if (this.isEmpty()) {\n                return {};\n            }\n\n            var options = this.options;\n            var fit = options.userSetBaseUnit === FIT;\n            var totalLimits = this.dataRange.total();\n            var ref = this.dataRange.displayRange();\n            var rangeMin = ref.min;\n            var rangeMax = ref.max;\n\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = rangeMax - rangeMin;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = Math.round(position * delta);\n            var maxDelta = Math.round((1 - position) * delta);\n\n            var ref$1 = this.dataRange.options;\n            var baseUnit = ref$1.baseUnit;\n            var min = new Date(rangeMin.getTime() + minDelta);\n            var max = new Date(rangeMax.getTime() - maxDelta);\n\n            if (fit) {\n                var autoBaseUnitSteps = options.autoBaseUnitSteps;\n                var maxDateGroups = options.maxDateGroups;\n\n                var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n                var rangeDiff = dateDiff(rangeMax, rangeMin);\n                var diff = dateDiff(max, min);\n                var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n                var autoBaseUnitStep, ticks;\n\n                if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n                    baseUnit = BASE_UNITS[baseUnitIndex - 1];\n                    autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n                    ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n                    min = addTicks(rangeMin, ticks);\n                    max = addTicks(rangeMax, -ticks);\n\n                } else if (diff > maxDiff && baseUnit !== YEARS) {\n                    var stepIndex = 0;\n\n                    do {\n                        baseUnitIndex++;\n                        baseUnit = BASE_UNITS[baseUnitIndex];\n                        stepIndex = 0;\n                        ticks = 2 * TIME_PER_UNIT[baseUnit];\n                        do {\n                            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n                            stepIndex++;\n                        } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n                    } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n                    ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n                    if (ticks > 0) {\n                        min = addTicks(rangeMin, -ticks);\n                        max = addTicks(rangeMax, ticks);\n                        min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n                        max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n                    }\n                }\n            }\n\n            if (min && max && dateDiff(max, min) > 0) {\n                return {\n                    min: min,\n                    max: max,\n                    baseUnit: options.userSetBaseUnit || options.baseUnit,\n                    baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n                };\n            }\n        },\n\n        zoomRange: function(scale, cursor) {\n            var totalLimits = this.dataRange.total();\n            var range = this.scaleRange(scale, cursor);\n\n            if (range) {\n                if (range.min < totalLimits.min) {\n                    range.min = totalLimits.min;\n                }\n                if (range.max > totalLimits.max) {\n                    range.max = totalLimits.max;\n                }\n            }\n\n            return range;\n        },\n\n        range: function() {\n            return this.dataRange.displayRange();\n        },\n\n        createLabels: function() {\n            CategoryAxis.fn.createLabels.call(this);\n            this.createRangeLabels();\n        },\n\n        clearLabels: function() {\n            CategoryAxis.fn.clearLabels.call(this);\n            this.rangeLabels = [];\n        },\n\n        arrangeLabels: function() {\n            this.arrangeRangeLabels();\n            CategoryAxis.fn.arrangeLabels.call(this);\n        },\n\n        arrangeRangeLabels: function() {\n            var ref = this;\n            var options = ref.options;\n            var rangeLabels = ref.rangeLabels;\n            if (rangeLabels.length === 0) {\n                return;\n            }\n\n            var lineBox = this.lineBox();\n            var vertical = options.vertical;\n            var mirror = options.rangeLabels.mirror || options.labels.mirror;\n\n            var firstLabel = rangeLabels[0];\n            if (firstLabel) {\n                var position = vertical ? lineBox.y1 - (firstLabel.box.height() / 2) : lineBox.x1;\n                this.positionLabel(firstLabel, mirror, position);\n            }\n\n            var lastLabel = rangeLabels[1];\n            if (lastLabel) {\n                var position$1 = vertical ? lineBox.y2 - (lastLabel.box.height() / 2) : lineBox.x2;\n                this.positionLabel(lastLabel, mirror, position$1);\n            }\n        },\n\n        autoRotateLabels: function() {\n            CategoryAxis.fn.autoRotateLabels.call(this);\n            this.autoRotateRangeLabels();\n        },\n\n        hideOutOfRangeLabels: function() {\n            CategoryAxis.fn.hideOutOfRangeLabels.call(this);\n            this.hideOverlappingLabels();\n        },\n\n        hideOverlappingLabels: function() {\n            var ref = this;\n            var rangeLabels = ref.rangeLabels;\n            var labels = ref.labels;\n            if (rangeLabels.length === 0) {\n                return;\n            }\n\n            function clip(rangeLabel, label) {\n                if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n                    label.options.visible = false;\n                    return true;\n                }\n\n                return false;\n            }\n\n            var firstRangeLabel = rangeLabels[0];\n            if (firstRangeLabel && firstRangeLabel.options.visible) {\n                for (var i = 0; i < labels.length; i++) {\n                    var overlaps = clip(firstRangeLabel, labels[i]);\n                    if (!overlaps) {\n                        break;\n                    }\n                }\n            }\n\n            var lastRangeLabel = rangeLabels[1];\n            if (lastRangeLabel && lastRangeLabel.options.visible) {\n                for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {\n                    var overlaps$1 = clip(lastRangeLabel, labels[i$1]);\n                    if (!overlaps$1) {\n                        break;\n                    }\n                }\n            }\n        },\n\n        contentBox: function() {\n            var box = CategoryAxis.fn.contentBox.call(this);\n            var rangeLabels = this.rangeLabels;\n\n            for (var i = 0; i < rangeLabels.length; i++) {\n                var label = rangeLabels[i];\n                if (label.options.visible) {\n                    box.wrap(label.box);\n                }\n            }\n\n            return box;\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            if (labelContext === void 0) { labelContext = {}; }\n\n            var options = this.options;\n            var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n            var date = this.divisionRange.dateAt(index);\n            var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n\n            labelOptions.format = labelOptions.format || unitFormat;\n            labelContext.dataItem = dataItem;\n\n            var text = this.axisLabelText(date, labelOptions, labelContext);\n            if (text) {\n                return new AxisLabel(date, text, index, dataItem, labelOptions);\n            }\n        },\n\n        createRangeLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this.divisionRange;\n            var displayStart = ref.displayStart;\n            var displayEnd = ref.displayEnd;\n            var options = this.options;\n            var labelOptions = $.extend({}, options.labels, options.rangeLabels, {\n                align: CENTER,\n                zIndex: options.zIndex\n            });\n\n            if (labelOptions.visible !== true) {\n                return;\n            }\n\n            this.normalizeLabelRotation(labelOptions);\n            labelOptions.alignRotation = CENTER;\n\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateRangeLabels = true;\n            }\n\n            var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n\n            var createLabel = function (index, date, text) {\n                if (text) {\n                    var label = new AxisLabel(date, text, index, null, labelOptions);\n                    this$1$1.append(label);\n                    this$1$1.rangeLabels.push(label);\n                }\n            };\n\n            var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });\n            createLabel(0, displayStart, startText);\n\n            var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });\n            createLabel(1, displayEnd, endText);\n        },\n\n        autoRotateRangeLabels: function() {\n            var this$1$1 = this;\n\n            var labels = this.rangeLabels;\n            if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n                return;\n            }\n\n            var rotateLabel = function (label, tickPositions, index) {\n                var width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n                var angle = this$1$1.autoRotateLabelAngle(label.box, width);\n                if (angle !== 0) {\n                    label.options.rotation = angle;\n                    label.reflow(new Box());\n                }\n            };\n\n            var tickPositions = this.getMajorTickPositions();\n            rotateLabel(labels[0], tickPositions, 0);\n            rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n        },\n\n        categoryIndex: function(value) {\n            return this.dataRange.valueIndex(value);\n        },\n\n        slot: function(from, to, limit) {\n            var dateRange = this.dataRange;\n            var start = from;\n            var end = to;\n\n            if (start instanceof Date) {\n                start = dateRange.dateIndex(start);\n            }\n\n            if (end instanceof Date) {\n                end = dateRange.dateIndex(end);\n            }\n\n            var slot = this.getSlot(start, end, limit);\n            if (slot) {\n                return slot.toRect();\n            }\n        },\n\n        getSlot: function(a, b, limit) {\n            var start = a;\n            var end = b;\n\n            if (typeof start === OBJECT) {\n                start = this.categoryIndex(start);\n            }\n\n            if (typeof end === OBJECT) {\n                end = this.categoryIndex(end);\n            }\n\n            return CategoryAxis.fn.getSlot.call(this, start, end, limit);\n        },\n\n        valueRange: function() {\n            var options = this.options;\n            var range = categoryRange(options.srcCategories);\n\n            return {\n                min: toDate(range.min),\n                max: toDate(range.max)\n            };\n        },\n\n        categoryAt: function(index, total) {\n            return this.dataRange.dateAt(index, total);\n        },\n\n        categoriesCount: function() {\n            return this.dataRange.valuesCount();\n        },\n\n        rangeIndices: function() {\n            return this.dataRange.displayIndices();\n        },\n\n        labelsBetweenTicks: function() {\n            return !this.divisionRange.options.justified;\n        },\n\n        prepareUserOptions: function() {\n            if (this.isEmpty()) {\n                return;\n            }\n\n            this.options.categories = this.dataRange.values();\n        },\n\n        getCategory: function(point) {\n            var index = this.pointCategoryIndex(point);\n\n            if (index === null) {\n                return null;\n            }\n\n            return this.dataRange.dateAt(index);\n        },\n\n        totalIndex: function(value) {\n            return this.dataRange.totalIndex(value);\n        },\n\n        currentRangeIndices: function() {\n            var range = this.dataRange.valueRange();\n            return {\n                min: this.dataRange.totalIndex(range.min),\n                max: this.dataRange.totalIndex(range.max)\n            };\n        },\n\n        totalRange: function() {\n            return this.dataRange.total();\n        },\n\n        totalRangeIndices: function() {\n            var range = this.dataRange.total();\n            return {\n                min: this.dataRange.totalIndex(range.min),\n                max: this.dataRange.totalIndex(range.max)\n            };\n        },\n\n        totalCount: function() {\n            return this.dataRange.totalCount();\n        },\n\n        isEmpty: function() {\n            return !this.options.srcCategories.length;\n        },\n\n        roundedRange: function() {\n            if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n                return this.range();\n            }\n\n            var options = this.options;\n            var datesRange = categoryRange(options.srcCategories);\n\n            var dateRange = new DateRange(datesRange.min, datesRange.max, $.extend({}, options, {\n                justified: false,\n                roundToBaseUnit: true,\n                justifyEnd: false\n            }));\n\n            return dateRange.displayRange();\n        }\n    });\n\n    setDefaultOptions(DateCategoryAxis, {\n        type: DATE,\n        labels: {\n            dateFormats: DateLabelFormats\n        },\n        rangeLabels: {\n            visible: false\n        },\n        autoBaseUnitSteps: {\n            milliseconds: [ 1, 10, 100 ],\n            seconds: [ 1, 2, 5, 15, 30 ],\n            minutes: [ 1, 2, 5, 15, 30 ],\n            hours: [ 1, 2, 3 ],\n            days: [ 1, 2, 3 ],\n            weeks: [ 1, 2 ],\n            months: [ 1, 2, 3, 6 ],\n            years: [ 1, 2, 3, 5, 10, 25, 50 ]\n        },\n        maxDateGroups: 10\n    });\n\n    function autoAxisMin(min, max, narrow) {\n        if (!min && !max) {\n            return 0;\n        }\n\n        var axisMin;\n\n        if (min >= 0 && max >= 0) {\n            var minValue = min === max ? 0 : min;\n\n            var diff = (max - minValue) / max;\n            if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n                return 0;\n            }\n\n            axisMin = Math.max(0, minValue - ((max - minValue) / 2));\n        } else {\n            axisMin = min;\n        }\n\n        return axisMin;\n    }\n\n    function autoAxisMax(min, max, narrow) {\n        if (!min && !max) {\n            return 1;\n        }\n\n        var axisMax;\n\n        if (min <= 0 && max <= 0) {\n            var maxValue = min === max ? 0 : max;\n\n            var diff = Math.abs((maxValue - min) / maxValue);\n            if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\n                return 0;\n            }\n\n            axisMax = Math.min(0, maxValue - ((min - maxValue) / 2));\n        } else {\n            axisMax = max;\n        }\n\n        return axisMax;\n    }\n\n    function floor(value, step) {\n        return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\n    }\n\n    function ceil(value, step) {\n        return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\n    }\n\n    function limitCoordinate(value) {\n        return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\n    }\n\n    var MIN_VALUE_RANGE$1 = Math.pow(10, -DEFAULT_PRECISION + 1);\n\n    var NumericAxis = Axis.extend({\n        init: function(seriesMin, seriesMax, options, chartService) {\n            Axis.fn.init.call(this, $.extend({}, options, {\n                seriesMin: seriesMin,\n                seriesMax: seriesMax\n            }), chartService);\n        },\n\n        initUserOptions: function(options) {\n            var autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);\n            this.totalOptions = totalAxisOptions(autoOptions, options);\n\n            return axisOptions(autoOptions, options);\n        },\n\n        initFields: function() {\n            this.totalMin = this.totalOptions.min;\n            this.totalMax = this.totalOptions.max;\n            this.totalMajorUnit = this.totalOptions.majorUnit;\n            this.seriesMin = this.options.seriesMin;\n            this.seriesMax = this.options.seriesMax;\n        },\n\n        clone: function() {\n            return new NumericAxis(\n                this.seriesMin,\n                this.seriesMax,\n                $.extend({}, this.options),\n                this.chartService\n            );\n        },\n\n        startValue: function() {\n            return 0;\n        },\n\n        range: function() {\n            var options = this.options;\n            return { min: options.min, max: options.max };\n        },\n\n        getDivisions: function(stepValue) {\n            if (stepValue === 0) {\n                return 1;\n            }\n\n            var options = this.options;\n            var range = options.max - options.min;\n\n            return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\n        },\n\n        getTickPositions: function(unit, skipUnit) {\n            var options = this.options;\n            var ref = this.lineInfo();\n            var axisDir = ref.axisDir;\n            var axisOrigin = ref.axisOrigin;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var range = options.max - options.min;\n            var scale = lineSize / range;\n            var step = unit * scale;\n            var divisions = this.getDivisions(unit);\n            var positions = [];\n            var pos = lineBox[axisOrigin];\n            var skipStep = 0;\n\n            if (skipUnit) {\n                skipStep = skipUnit / unit;\n            }\n\n            for (var idx = 0; idx < divisions; idx++) {\n                if (idx % skipStep !== 0) {\n                    positions.push(round(pos, COORD_PRECISION));\n                }\n\n                pos = pos + step * axisDir;\n            }\n\n            return positions;\n        },\n\n        getMajorTickPositions: function() {\n            return this.getTickPositions(this.options.majorUnit);\n        },\n\n        getMinorTickPositions: function() {\n            return this.getTickPositions(this.options.minorUnit);\n        },\n\n        getSlot: function(a, b, limit) {\n            if (limit === void 0) { limit = false; }\n\n            var options = this.options;\n            var ref = this.lineInfo();\n            var axis = ref.axis;\n            var axisDir = ref.axisDir;\n            var lineBox = ref.lineBox;\n            var lineSize = ref.lineSize;\n            var lineStart = ref.lineStart;\n            var step = axisDir * (lineSize / (options.max - options.min));\n\n            var start = valueOrDefault(a, b || 0);\n            var end = valueOrDefault(b, a || 0);\n\n            if (limit) {\n                start = limitValue(start, options.min, options.max);\n                end = limitValue(end, options.min, options.max);\n            }\n\n            var p1 = Math.min(start, end) - options.min;\n            var p2 = Math.max(start, end) - options.min;\n\n            var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n            slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n            slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n            return slotBox;\n        },\n\n        getValue: function(point) {\n            var options = this.options;\n            var max = Number(options.max);\n            var min = Number(options.min);\n            var offset = this.pointOffset(point);\n            var valueOffset = offset * (max - min);\n\n            if (offset < 0 || offset > 1) {\n                return null;\n            }\n\n            var value = min + valueOffset;\n            return round(value, DEFAULT_PRECISION);\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var vertical = options.vertical;\n            var reverse = options.reverse;\n            var max = options.max;\n            var min = options.min;\n            var ref = this.lineInfo();\n            var lineSize = ref.lineSize;\n            var range = max - min;\n            var scale = lineSize / range;\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse )) {\n                offset = -offset;\n            }\n\n            return {\n                min: min + offset,\n                max: max + offset,\n                offset: offset\n            };\n        },\n\n        labelsCount: function() {\n            return this.getDivisions(this.options.majorUnit);\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var options = this.options;\n            var value = round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);\n            var text = this.axisLabelText(value, labelOptions, labelContext);\n\n            return new AxisLabel(value, text, index, null, labelOptions);\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n            return range.min <= value && value <= range.max;\n        },\n\n        pan: function(delta) {\n            var range = this.translateRange(delta);\n            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n        },\n\n        pointsRange: function(start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            if (this.isValidRange(min, max)) {\n                return {\n                    min: min,\n                    max: max\n                };\n            }\n        },\n\n        scaleRange: function(scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = this.options.max - this.options.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = round(this.options.min + minDelta, DEFAULT_PRECISION);\n            var max = round(this.options.max - maxDelta, DEFAULT_PRECISION);\n\n            if (max - min < MIN_VALUE_RANGE$1) {\n                max = min + MIN_VALUE_RANGE$1;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var ref = this;\n            var totalMin = ref.totalMin;\n            var totalMax = ref.totalMax;\n            var range = this.scaleRange(scale, cursor);\n\n            return {\n                min: limitValue(range.min, totalMin, totalMax),\n                max: limitValue(range.max, totalMin, totalMax),\n                narrowRange: false\n            };\n        },\n\n        isValidRange: function(min, max) {\n            return max - min > MIN_VALUE_RANGE$1;\n        }\n    });\n\n    function autoAxisOptions(seriesMin, seriesMax, options) {\n        var narrowRange = options.narrowRange;\n\n        var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\n        var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\n\n        var majorUnit = autoMajorUnit(autoMin, autoMax);\n        var autoOptions = {\n            majorUnit: majorUnit\n        };\n\n        if (options.roundToMajorUnit !== false) {\n            if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\n                autoMin -= majorUnit;\n            }\n\n            if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\n                autoMax += majorUnit;\n            }\n        }\n\n        autoOptions.min = floor(autoMin, majorUnit);\n        autoOptions.max = ceil(autoMax, majorUnit);\n\n        return autoOptions;\n    }\n\n    function totalAxisOptions(autoOptions, options) {\n        return {\n            min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\n            max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\n            majorUnit: autoOptions.majorUnit\n        };\n    }\n\n    function clearNullValues(options, fields) {\n        for (var idx = 0; idx < fields.length; idx++) {\n            var field = fields[idx];\n            if (options[field] === null) {\n                options[field] = undefined;\n            }\n        }\n    }\n\n    function axisOptions(autoOptions, userOptions) {\n        var options = userOptions;\n        var userSetMin, userSetMax;\n\n        if (userOptions) {\n            clearNullValues(userOptions, [ 'min', 'max' ]);\n\n            userSetMin = defined(userOptions.min);\n            userSetMax = defined(userOptions.max);\n\n            var userSetLimits = userSetMin || userSetMax;\n\n            if (userSetLimits) {\n                if (userOptions.min === userOptions.max) {\n                    if (userOptions.min > 0) {\n                        userOptions.min = 0;\n                    } else {\n                        userOptions.max = 1;\n                    }\n                }\n            }\n\n            if (userOptions.majorUnit) {\n                autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\n                autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\n            } else if (userSetLimits) {\n                options = deepExtend(autoOptions, userOptions);\n\n                // Determine an auto major unit after min/max have been set\n                autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\n            }\n        }\n\n        autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\n\n        var result = deepExtend(autoOptions, options);\n        if (result.min >= result.max) {\n            if (userSetMin && !userSetMax) {\n                result.max = result.min + result.majorUnit;\n            } else if (!userSetMin && userSetMax) {\n                result.min = result.max - result.majorUnit;\n            }\n        }\n\n        return result;\n    }\n\n    function remainderClose(value, divisor, ratio) {\n        var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\n        var threshold = divisor * (1 - ratio);\n\n        return remainder === 0 || remainder > threshold;\n    }\n\n    setDefaultOptions(NumericAxis, {\n        type: \"numeric\",\n        min: 0,\n        max: 1,\n        vertical: true,\n        majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n        },\n        labels: {\n            format: \"#.####################\"\n        },\n        zIndex: 1\n    });\n\n    var MIN_VALUE_RANGE = 1000;\n\n    var DateValueAxis = Axis.extend({\n        init: function(seriesMin, seriesMax, axisOptions, chartService) {\n            var min = toDate(seriesMin);\n            var max = toDate(seriesMax);\n\n            var intlService = chartService.intl;\n            var options = axisOptions || {};\n            options = deepExtend(options || {}, {\n                min: parseDate(intlService, options.min),\n                max: parseDate(intlService, options.max),\n                axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),\n                weekStartDay: firstDay(options, intlService)\n            });\n            options = applyDefaults(min, max, options);\n\n            Axis.fn.init.call(this, options, chartService);\n\n            this.intlService = intlService;\n            this.seriesMin = min;\n            this.seriesMax = max;\n\n            var weekStartDay = options.weekStartDay || 0;\n            this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit, weekStartDay));\n            this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit, weekStartDay));\n        },\n\n        clone: function() {\n            return new DateValueAxis(this.seriesMin, this.seriesMax, $.extend({}, this.options), this.chartService);\n        },\n\n        range: function() {\n            var options = this.options;\n            return { min: options.min, max: options.max };\n        },\n\n        getDivisions: function(stepValue) {\n            var options = this.options;\n\n            return Math.floor(\n                duration(options.min, options.max, options.baseUnit) / stepValue + 1\n            );\n        },\n\n        getTickPositions: function(step) {\n            var options = this.options;\n            var ref = this.lineInfo();\n            var dir = ref.axisDir;\n            var lineSize = ref.lineSize;\n            var start = ref.lineStart;\n            var divisions = this.getDivisions(step);\n            var timeRange = dateDiff(options.max, options.min);\n            var scale = lineSize / timeRange;\n            var weekStartDay = options.weekStartDay || 0;\n\n            var positions = [ start ];\n            for (var i = 1; i < divisions; i++) {\n                var date = addDuration(options.min, i * step, options.baseUnit, weekStartDay);\n                var pos = start + dateDiff(date, options.min) * scale * dir;\n\n                positions.push(round(pos, COORD_PRECISION));\n            }\n\n            return positions;\n        },\n\n        getMajorTickPositions: function() {\n            return this.getTickPositions(this.options.majorUnit);\n        },\n\n        getMinorTickPositions: function() {\n            return this.getTickPositions(this.options.minorUnit);\n        },\n\n        getSlot: function(a, b, limit) {\n            return NumericAxis.prototype.getSlot.call(\n                this, parseDate(this.intlService, a), parseDate(this.intlService, b), limit\n            );\n        },\n\n        getValue: function(point) {\n            var value = NumericAxis.prototype.getValue.call(this, point);\n\n            return value !== null ? toDate(value) : null;\n        },\n\n        labelsCount: function() {\n            return this.getDivisions(this.options.majorUnit);\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var options = this.options;\n            var offset = index * options.majorUnit;\n            var weekStartDay = options.weekStartDay || 0;\n            var date = options.min;\n\n            if (offset > 0) {\n                date = addDuration(date, offset, options.baseUnit, weekStartDay);\n            }\n\n            var unitFormat = labelOptions.dateFormats[options.baseUnit];\n            labelOptions.format = labelOptions.format || unitFormat;\n\n            var text = this.axisLabelText(date, labelOptions, labelContext);\n            return new AxisLabel(date, text, index, null, labelOptions);\n        },\n\n        translateRange: function(delta) {\n            var options = this.options;\n            var lineBox = this.lineBox();\n            var vertical = options.vertical;\n            var reverse = options.reverse;\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var range = this.range();\n            var scale = size / dateDiff(range.max, range.min);\n\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n            if ((vertical || reverse) && !(vertical && reverse )) {\n                offset = -offset;\n            }\n\n            var from = addTicks(options.min, offset);\n            var to = addTicks(options.max, offset);\n\n            return {\n                min: from,\n                max: to,\n                offset: offset\n            };\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n\n            return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\n        },\n\n        pan: function(delta) {\n            var range = this.translateRange(delta, true);\n            var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);\n\n            if (limittedRange) {\n                return {\n                    min: toDate(limittedRange.min),\n                    max: toDate(limittedRange.max)\n                };\n            }\n        },\n\n        pointsRange: function(start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            return {\n                min: toDate(min),\n                max: toDate(max)\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = this.options.max - this.options.min;\n            var delta = this.scaleToDelta(scale, range);\n            var minDelta = position * delta;\n            var maxDelta = (1 - position) * delta;\n            var min = toDate(toTime(this.options.min) + minDelta);\n            var max = toDate(toTime(this.options.max) - maxDelta);\n\n            if (max - min < MIN_VALUE_RANGE) {\n                max = toDate(toTime(min) + MIN_VALUE_RANGE);\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var range = this.scaleRange(scale, cursor);\n            var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\n            var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\n\n            return {\n                min: min,\n                max: max\n            };\n        }\n    });\n\n    function timeUnits(delta) {\n        var unit = HOURS;\n\n        if (delta >= TIME_PER_YEAR) {\n            unit = YEARS;\n        } else if (delta >= TIME_PER_MONTH) {\n            unit = MONTHS;\n        } else if (delta >= TIME_PER_WEEK) {\n            unit = WEEKS;\n        } else if (delta >= TIME_PER_DAY) {\n            unit = DAYS;\n        }\n\n        return unit;\n    }\n\n    function applyDefaults(seriesMin, seriesMax, options) {\n        var min = options.min || seriesMin;\n        var max = options.max || seriesMax;\n        var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\n        var baseUnitTime = TIME_PER_UNIT[baseUnit];\n        var weekStartDay = options.weekStartDay || 0;\n        var autoMin = floorDate(toTime(min) - 1, baseUnit, weekStartDay) || toDate(max);\n        var autoMax = ceilDate(toTime(max) + 1, baseUnit, weekStartDay);\n        var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\n        var majorUnit = userMajorUnit || ceil(\n            autoMajorUnit(autoMin.getTime(), autoMax.getTime()),\n            baseUnitTime\n        ) / baseUnitTime;\n        var actualUnits = duration(autoMin, autoMax, baseUnit);\n        var totalUnits = ceil(actualUnits, majorUnit);\n        var unitsToAdd = totalUnits - actualUnits;\n        var head = Math.floor(unitsToAdd / 2);\n        var tail = unitsToAdd - head;\n\n        if (!options.baseUnit) {\n            delete options.baseUnit;\n        }\n\n        options.baseUnit = options.baseUnit || baseUnit;\n        options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);\n        options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);\n        options.minorUnit = options.minorUnit || majorUnit / 5;\n        options.majorUnit = majorUnit;\n\n        return options;\n    }\n\n    setDefaultOptions(DateValueAxis, {\n        type: DATE,\n        majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n        },\n        labels: {\n            dateFormats: DateLabelFormats\n        }\n    });\n\n    var DEFAULT_MAJOR_UNIT = 10;\n    var MIN_VALUE_RANGE$2 = 1e-6;\n\n    var LogarithmicAxis = Axis.extend({\n        init: function(seriesMin, seriesMax, options, chartService) {\n\n            var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n            var base = axisOptions.majorUnit;\n            var autoMax = autoAxisMax$1(seriesMax, base);\n            var autoMin = autoAxisMin$1(seriesMin, seriesMax, axisOptions);\n            var range = initRange(autoMin, autoMax, axisOptions, options);\n\n            axisOptions.max = range.max;\n            axisOptions.min = range.min;\n            axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n            Axis.fn.init.call(this, axisOptions, chartService);\n\n            this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n            this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n            this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n            this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n            this.seriesMin = seriesMin;\n            this.seriesMax = seriesMax;\n\n            this.createLabels();\n        },\n\n        clone: function() {\n            return new LogarithmicAxis(\n                this.seriesMin,\n                this.seriesMax,\n                $.extend({}, this.options),\n                this.chartService\n            );\n        },\n\n        startValue: function() {\n            return this.options.min;\n        },\n\n        getSlot: function(a, b, limit) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var base = options.majorUnit;\n            var min = options.min;\n            var max = options.max;\n            var ref$1 = this.lineInfo();\n            var axis = ref$1.axis;\n            var axisDir = ref$1.axisDir;\n            var lineBox = ref$1.lineBox;\n            var lineSize = ref$1.lineSize;\n            var lineStart = ref$1.lineStart;\n            var step = axisDir * (lineSize / (logMax - logMin));\n            var start = valueOrDefault(a, b || 1);\n            var end = valueOrDefault(b, a || 1);\n\n            if (start <= 0 || end <= 0) {\n                return null;\n            }\n\n            if (limit) {\n                start = limitValue(start, min, max);\n                end = limitValue(end, min, max);\n            }\n\n            start = log(start, base);\n            end = log(end, base);\n\n            var p1 = Math.min(start, end) - logMin;\n            var p2 = Math.max(start, end) - logMin;\n\n            var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n            slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n            slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n            return slotBox;\n        },\n\n        getValue: function(point) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var base = options.majorUnit;\n            var ref$1 = this.lineInfo();\n            var axis = ref$1.axis;\n            var axisDir = ref$1.axisDir;\n            var lineStart = ref$1.lineStart;\n            var lineSize = ref$1.lineSize;\n            var step = ((logMax - logMin) / lineSize);\n            var offset = axisDir * (point[axis] - lineStart);\n            var valueOffset = offset * step;\n\n            if (offset < 0 || offset > lineSize) {\n                return null;\n            }\n\n            var value = logMin + valueOffset;\n\n            return round(Math.pow(base, value), DEFAULT_PRECISION);\n        },\n\n        range: function() {\n            var options = this.options;\n            return { min: options.min, max: options.max };\n        },\n\n        translateRange: function(delta) {\n            var ref = this;\n            var options = ref.options;\n            var logMin = ref.logMin;\n            var logMax = ref.logMax;\n            var reverse = options.reverse;\n            var vertical = options.vertical;\n            var base = options.majorUnit;\n            var lineBox = this.lineBox();\n            var size = vertical ? lineBox.height() : lineBox.width();\n            var scale = size / (logMax - logMin);\n            var offset = round(delta / scale, DEFAULT_PRECISION);\n\n            if ((vertical || reverse) && !(vertical && reverse )) {\n                offset = -offset;\n            }\n\n            return {\n                min: Math.pow(base, logMin + offset),\n                max: Math.pow(base, logMax + offset),\n                offset: offset\n            };\n        },\n\n        labelsCount: function() {\n            var floorMax = Math.floor(this.logMax);\n            var count = Math.floor(floorMax - this.logMin) + 1;\n\n            return count;\n        },\n\n        getMajorTickPositions: function() {\n            var ticks = [];\n\n            this.traverseMajorTicksPositions(function (position) {\n                ticks.push(position);\n            }, { step: 1, skip: 0 });\n\n            return ticks;\n        },\n\n        createTicks: function(lineGroup) {\n            var options = this.options;\n            var majorTicks = options.majorTicks;\n            var minorTicks = options.minorTicks;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var lineBox = this.lineBox();\n            var ticks = [];\n            var tickLineOptions = {\n                // TODO\n                // _alignLines: options._alignLines,\n                vertical: vertical\n            };\n\n            function render(tickPosition, tickOptions) {\n                tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                tickLineOptions.position = tickPosition;\n\n                lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n            }\n\n            if (majorTicks.visible) {\n                this.traverseMajorTicksPositions(render, majorTicks);\n            }\n\n            if (minorTicks.visible) {\n                this.traverseMinorTicksPositions(render, minorTicks);\n            }\n\n            return ticks;\n        },\n\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var vertical = options.vertical;\n            var lineBox = altAxis.lineBox();\n            var lineOptions = {\n                lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n                lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n                vertical: vertical\n            };\n            var majorTicks = [];\n\n            var container = this.gridLinesVisual();\n            function render(tickPosition, gridLine) {\n                if (!inArray(tickPosition, majorTicks)) {\n                    lineOptions.position = tickPosition;\n                    container.append(createAxisGridLine(lineOptions, gridLine));\n\n                    majorTicks.push(tickPosition);\n                }\n            }\n\n            if (majorGridLines.visible) {\n                this.traverseMajorTicksPositions(render, majorGridLines);\n            }\n\n            if (minorGridLines.visible) {\n                this.traverseMinorTicksPositions(render, minorGridLines);\n            }\n\n            return container.children;\n        },\n\n        traverseMajorTicksPositions: function(callback, tickOptions) {\n            var ref = this.lineInfo();\n            var lineStart = ref.lineStart;\n            var step = ref.step;\n            var ref$1 = this;\n            var logMin = ref$1.logMin;\n            var logMax = ref$1.logMax;\n\n            for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n                var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n                callback(position, tickOptions);\n            }\n        },\n\n        traverseMinorTicksPositions: function(callback, tickOptions) {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var minorUnit = ref.minorUnit;\n            var base = ref.majorUnit;\n            var ref$1 = this.lineInfo();\n            var lineStart = ref$1.lineStart;\n            var step = ref$1.step;\n            var ref$2 = this;\n            var logMin = ref$2.logMin;\n            var logMax = ref$2.logMax;\n            var start = Math.floor(logMin);\n\n            for (var power = start; power < logMax; power++) {\n                var minorOptions = this$1$1._minorIntervalOptions(power);\n                for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                    var value = minorOptions.value + idx * minorOptions.minorStep;\n                    if (value > max) {\n                        break;\n                    }\n                    if (value >= min) {\n                        var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                        callback(position, tickOptions);\n                    }\n                }\n            }\n        },\n\n        createAxisLabel: function(index, labelOptions, labelContext) {\n            var power = Math.ceil(this.logMin + index);\n            var value = Math.pow(this.options.majorUnit, power);\n            var text = this.axisLabelText(value, labelOptions, labelContext);\n\n            return new AxisLabel(value, text, index, null, labelOptions);\n        },\n\n        shouldRenderNote: function(value) {\n            var range = this.range();\n            return range.min <= value && value <= range.max;\n        },\n\n        pan: function(delta) {\n            var range = this.translateRange(delta);\n            return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n        },\n\n        pointsRange: function(start, end) {\n            var startValue = this.getValue(start);\n            var endValue = this.getValue(end);\n            var min = Math.min(startValue, endValue);\n            var max = Math.max(startValue, endValue);\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        scaleRange: function(scale, cursor) {\n            var ref = this.options;\n            var base = ref.majorUnit;\n            var logMin = log(this.options.min, base);\n            var logMax = log(this.options.max, base);\n            var position = Math.abs(this.pointOffset(cursor));\n            var range = logMax - logMin;\n            var delta = this.scaleToDelta(scale, range);\n            var min = Math.pow(base, logMin + position * delta);\n            var max = Math.pow(base, logMax - (1 - position) * delta);\n\n            if (max - min < MIN_VALUE_RANGE$2) {\n                max = min + MIN_VALUE_RANGE$2;\n            }\n\n            return {\n                min: min,\n                max: max\n            };\n        },\n\n        zoomRange: function(scale, cursor) {\n            var range = this.scaleRange(scale, cursor);\n            var ref = this;\n            var totalMin = ref.totalMin;\n            var totalMax = ref.totalMax;\n\n            return {\n                min: limitValue(range.min, totalMin, totalMax),\n                max: limitValue(range.max, totalMin, totalMax)\n            };\n        },\n\n        _minorIntervalOptions: function(power) {\n            var ref = this.options;\n            var minorUnit = ref.minorUnit;\n            var base = ref.majorUnit;\n            var value = Math.pow(base, power);\n            var nextValue = Math.pow(base, power + 1);\n            var difference = nextValue - value;\n            var minorStep = difference / minorUnit;\n\n            return {\n                value: value,\n                minorStep: minorStep\n            };\n        },\n\n        lineInfo: function() {\n            var info = Axis.fn.lineInfo.call(this);\n            info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n\n            return info;\n        }\n    });\n\n    function initRange(autoMin, autoMax, axisOptions, options) {\n        var min = axisOptions.min;\n        var max = axisOptions.max;\n\n        if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n            throwNegativeValuesError();\n        }\n\n        if (!defined(options.max)) {\n            max = autoMax;\n        } else if (options.max <= 0) {\n            throwNegativeValuesError();\n        }\n\n        if (!defined(options.min)) {\n            min = autoMin;\n        } else if (options.min <= 0) {\n            throwNegativeValuesError();\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    function autoAxisMin$1(min, max, options) {\n        var base = options.majorUnit;\n        var autoMin = min;\n        if (min <= 0) {\n            autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n        } else if (!options.narrowRange) {\n            autoMin = Math.pow(base, Math.floor(log(min, base)));\n        }\n        return autoMin;\n    }\n\n    function autoAxisMax$1(max, base) {\n        var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n        var autoMax;\n        if (max <= 0) {\n            autoMax = base;\n        } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n            autoMax = Math.pow(base, log(max, base) + 0.2);\n        } else {\n            autoMax = Math.pow(base, Math.ceil(log(max, base)));\n        }\n\n        return autoMax;\n    }\n\n    function throwNegativeValuesError() {\n        throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n    }\n\n    function log(x, base) {\n        return Math.log(x) / Math.log(base);\n    }\n\n    setDefaultOptions(LogarithmicAxis, {\n        type: \"log\",\n        majorUnit: DEFAULT_MAJOR_UNIT,\n        minorUnit: 1,\n        axisCrossingValue: 1,\n        vertical: true,\n        majorGridLines: {\n            visible: true,\n            width: 1,\n            color: BLACK\n        },\n        zIndex: 1,\n        _deferLabels: true\n    });\n\n    var GridLinesMixin = {\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\n            var gridLines = [];\n            var skipMajor = false;\n            var majorAngles, minorAngles;\n\n            if (options.majorGridLines.visible) {\n                majorAngles = this.majorGridLineAngles(altAxis);\n                skipMajor = true;\n\n                gridLines = this.renderMajorGridLines(\n                    majorAngles, radius, options.majorGridLines\n                );\n            }\n\n            if (options.minorGridLines.visible) {\n                minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\n\n                append(gridLines, this.renderMinorGridLines(\n                    minorAngles, radius, options.minorGridLines, altAxis, skipMajor\n                ));\n            }\n\n            return gridLines;\n        },\n\n        renderMajorGridLines: function(angles, radius, options) {\n            return this.renderGridLines(angles, radius, options);\n        },\n\n        renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {\n            var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\n            return this.renderGridLines(angles, radius, options, radiusCallback);\n        },\n\n        renderGridLines: function(angles, radius, options, radiusCallback) {\n            var style = {\n                stroke: {\n                    width: options.width,\n                    color: options.color,\n                    dashType: options.dashType\n                }\n            };\n\n            var center = this.box.center();\n            var circle = new Circle([ center.x, center.y ], radius);\n            var container = this.gridLinesVisual();\n\n            for (var i = 0; i < angles.length; i++) {\n                var line = new Path(style);\n                if (radiusCallback) {\n                    circle.radius = radiusCallback(angles[i]);\n                }\n\n                line.moveTo(circle.center)\n                    .lineTo(circle.pointAt(angles[i] + 180));\n\n                container.append(line);\n            }\n\n            return container.children;\n        },\n\n        gridLineAngles: function(altAxis, size, skip, step, skipAngles) {\n            var this$1$1 = this;\n\n            var divs = this.intervals(size, skip, step, skipAngles);\n            var options = altAxis.options;\n            var altAxisVisible = options.visible && (options.line || {}).visible !== false;\n\n            return map(divs, function (d) {\n                var alpha = this$1$1.intervalAngle(d);\n\n                if (!altAxisVisible || alpha !== 90) {\n                    return alpha;\n                }\n            });\n        }\n    };\n\n    var RadarCategoryAxis = CategoryAxis.extend({\n        range: function() {\n            return { min: 0, max: this.options.categories.length };\n        },\n\n        reflow: function(box) {\n            this.box = box;\n            this.reflowLabels();\n        },\n\n        lineBox: function() {\n            return this.box;\n        },\n\n        reflowLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var labels = ref.labels;\n            var labelOptions = ref.options.labels;\n            var skip = labelOptions.skip || 0;\n            var step = labelOptions.step || 1;\n            var measureBox = new Box();\n\n            for (var i = 0; i < labels.length; i++) {\n                labels[i].reflow(measureBox);\n                var labelBox = labels[i].box;\n\n                labels[i].reflow(this$1$1.getSlot(skip + i * step).adjacentBox(\n                    0, labelBox.width(), labelBox.height()\n                ));\n            }\n        },\n\n        intervals: function(size, skipOption, stepOption, skipAngles) {\n            if (skipAngles === void 0) { skipAngles = false; }\n\n            var options = this.options;\n            var categories = options.categories.length;\n            var divCount = categories / size || 1;\n            var divAngle = 360 / divCount;\n            var skip = skipOption || 0;\n            var step = stepOption || 1;\n            var divs = [];\n            var angle = 0;\n\n            for (var i = skip; i < divCount; i += step) {\n                if (options.reverse) {\n                    angle = 360 - i * divAngle;\n                } else {\n                    angle = i * divAngle;\n                }\n\n                angle = round(angle, COORD_PRECISION) % 360;\n\n                if (!(skipAngles && inArray(angle, skipAngles))) {\n                    divs.push(angle);\n                }\n            }\n\n            return divs;\n        },\n\n        majorIntervals: function() {\n            return this.intervals(1);\n        },\n\n        minorIntervals: function() {\n            return this.intervals(0.5);\n        },\n\n        intervalAngle: function(interval) {\n            return (360 + interval + this.options.startAngle) % 360;\n        },\n\n        majorAngles: function() {\n            var this$1$1 = this;\n\n            return map(this.majorIntervals(), function (interval) { return this$1$1.intervalAngle(interval); });\n        },\n\n        createLine: function() {\n            return [];\n        },\n\n        majorGridLineAngles: function(altAxis) {\n            var majorGridLines = this.options.majorGridLines;\n            return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\n        },\n\n        minorGridLineAngles: function(altAxis, skipMajor) {\n            var ref = this.options;\n            var minorGridLines = ref.minorGridLines;\n            var majorGridLines = ref.majorGridLines;\n            var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\n\n            return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n        },\n\n        radiusCallback: function(radius, altAxis, skipMajor) {\n            if (altAxis.options.type !== ARC) {\n                var minorAngle = rad(360 / (this.options.categories.length * 2));\n                var minorRadius = Math.cos(minorAngle) * radius;\n                var majorAngles = this.majorAngles();\n\n                var radiusCallback = function(angle) {\n                    if (!skipMajor && inArray(angle, majorAngles)) {\n                        return radius;\n                    }\n\n                    return minorRadius;\n                };\n                return radiusCallback;\n            }\n        },\n\n        createPlotBands: function() {\n            var this$1$1 = this;\n\n            var plotBands = this.options.plotBands || [];\n\n            var group = this._plotbandGroup = new Group({\n                zIndex: -1\n            });\n\n            for (var i = 0; i < plotBands.length; i++) {\n                var band = plotBands[i];\n                var slot = this$1$1.plotBandSlot(band);\n                var singleSlot = this$1$1.getSlot(band.from);\n\n                var head = band.from - Math.floor(band.from);\n                slot.startAngle += head * singleSlot.angle;\n\n                var tail = Math.ceil(band.to) - band.to;\n                slot.angle -= (tail + head) * singleSlot.angle;\n\n                var ring = ShapeBuilder.current.createRing(slot, {\n                    fill: {\n                        color: band.color,\n                        opacity: band.opacity\n                    },\n                    stroke: {\n                        opacity: band.opacity\n                    }\n                });\n                group.append(ring);\n            }\n\n            this.appendVisual(group);\n        },\n\n        plotBandSlot: function(band) {\n            return this.getSlot(band.from, band.to - 1);\n        },\n\n        getSlot: function(from, to) {\n            var options = this.options;\n            var justified = options.justified;\n            var box = this.box;\n            var divs = this.majorAngles();\n            var totalDivs = divs.length;\n            var slotAngle = 360 / totalDivs;\n            var fromValue = from;\n\n            if (options.reverse && !justified) {\n                fromValue = (fromValue + 1) % totalDivs;\n            }\n\n            fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\n            var slotStart = divs[fromValue];\n\n            if (justified) {\n                slotStart = slotStart - slotAngle / 2;\n\n                if (slotStart < 0) {\n                    slotStart += 360;\n                }\n            }\n\n            var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\n            var slots = toValue - fromValue + 1;\n            var angle = slotAngle * slots;\n\n            return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\n        },\n\n        slot: function(from, to) {\n            var slot = this.getSlot(from, to);\n            var startAngle = slot.startAngle + 180;\n            var endAngle = startAngle + slot.angle;\n\n            return new geometry.Arc([ slot.center.x, slot.center.y ], {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: slot.radius,\n                radiusY: slot.radius\n            });\n        },\n\n        pointCategoryIndex: function(point) {\n            var this$1$1 = this;\n\n            var length = this.options.categories.length;\n            var index = null;\n\n            for (var i = 0; i < length; i++) {\n                var slot = this$1$1.getSlot(i);\n                if (slot.containsPoint(point)) {\n                    index = i;\n                    break;\n                }\n            }\n\n            return index;\n        }\n    });\n\n    setDefaultOptions(RadarCategoryAxis, {\n        startAngle: 90,\n        labels: {\n            margin: getSpacing(10)\n        },\n        majorGridLines: {\n            visible: true\n        },\n        justified: true\n    });\n    deepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\n\n    var PolarAxis = Axis.extend({\n        init: function(options, chartService) {\n            Axis.fn.init.call(this, options, chartService);\n\n            var instanceOptions = this.options;\n\n            instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\n        },\n\n        getDivisions: function(stepValue) {\n            return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\n        },\n\n        reflow: function(box) {\n            this.box = box;\n            this.reflowLabels();\n        },\n\n        reflowLabels: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var options = ref.options;\n            var labels = ref.labels;\n            var labelOptions = ref.options.labels;\n            var skip = labelOptions.skip || 0;\n            var step = labelOptions.step || 1;\n\n            var measureBox = new Box();\n            var divs = this.intervals(options.majorUnit, skip, step);\n\n            for (var i = 0; i < labels.length; i++) {\n                labels[i].reflow(measureBox);\n                var labelBox = labels[i].box;\n\n                labels[i].reflow(this$1$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\n            }\n        },\n\n        lineBox: function() {\n            return this.box;\n        },\n\n        intervals: function(size, skipOption, stepOption, skipAngles) {\n            if (skipAngles === void 0) { skipAngles = false; }\n\n            var min = this.options.min;\n            var divisions = this.getDivisions(size);\n            var divs = [];\n            var skip = skipOption || 0;\n            var step = stepOption || 1;\n\n            for (var i = skip; i < divisions; i += step) {\n                var current = (360 + min + i * size) % 360;\n                if (!(skipAngles && inArray(current, skipAngles))) {\n                    divs.push(current);\n                }\n            }\n\n            return divs;\n        },\n\n        majorIntervals: function() {\n            return this.intervals(this.options.majorUnit);\n        },\n\n        minorIntervals: function() {\n            return this.intervals(this.options.minorUnit);\n        },\n\n        intervalAngle: function(i) {\n            return (540 - i - this.options.startAngle) % 360;\n        },\n\n        createLine: function() {\n            return [];\n        },\n\n        majorGridLineAngles: function(altAxis) {\n            var majorGridLines = this.options.majorGridLines;\n            return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\n        },\n\n        minorGridLineAngles: function(altAxis, skipMajor) {\n            var options = this.options;\n            var minorGridLines = options.minorGridLines;\n            var majorGridLines = options.majorGridLines;\n            var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\n\n            return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\n        },\n\n        plotBandSlot: function(band) {\n            return this.getSlot(band.from, band.to);\n        },\n\n        getSlot: function(a, b) {\n            var ref = this;\n            var options = ref.options;\n            var box = ref.box;\n            var startAngle = options.startAngle;\n            var start = limitValue(a, options.min, options.max);\n            var end = limitValue(b || start, start, options.max);\n\n            if (options.reverse) {\n                start *= -1;\n                end *= -1;\n            }\n\n            start = (540 - start - startAngle) % 360;\n            end = (540 - end - startAngle) % 360;\n\n            if (end < start) {\n                var tmp = start;\n                start = end;\n                end = tmp;\n            }\n\n            return new Ring(box.center(), 0, box.height() / 2, start, end - start);\n        },\n\n        slot: function(from, to) {\n            if (to === void 0) { to = from; }\n\n            var options = this.options;\n            var start = 360 - options.startAngle;\n            var slot = this.getSlot(from, to);\n            var min = Math.min(from, to);\n            var max = Math.max(from, to);\n            var startAngle, endAngle;\n\n            if (options.reverse) {\n                startAngle = min;\n                endAngle = max;\n            } else {\n                startAngle = 360 - max;\n                endAngle = 360 - min;\n            }\n\n            startAngle = (startAngle + start) % 360;\n            endAngle = (endAngle + start) % 360;\n\n            return new geometry.Arc([ slot.center.x, slot.center.y ], {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: slot.radius,\n                radiusY: slot.radius\n            });\n        },\n\n        getValue: function(point) {\n            var options = this.options;\n            var center = this.box.center();\n            var dx = point.x - center.x;\n            var dy = point.y - center.y;\n            var theta = Math.round(deg(Math.atan2(dy, dx)));\n            var start = options.startAngle;\n\n            if (!options.reverse) {\n                theta *= -1;\n                start *= -1;\n            }\n\n            return (theta + start + 360) % 360;\n        },\n\n        valueRange: function() {\n            return {\n                min: 0,\n                max: Math.PI * 2\n            };\n        }\n    });\n\n    setDefaultOptions(PolarAxis, {\n        type: \"polar\",\n        startAngle: 0,\n        reverse: false,\n        majorUnit: 60,\n        min: 0,\n        max: 360,\n        labels: {\n            margin: getSpacing(10)\n        },\n        majorGridLines: {\n            color: BLACK,\n            visible: true,\n            width: 1\n        },\n        minorGridLines: {\n            color: \"#aaa\"\n        }\n    });\n\n    deepExtend(PolarAxis.prototype, GridLinesMixin, {\n        createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\n        majorAngles: RadarCategoryAxis.prototype.majorAngles,\n        range: NumericAxis.prototype.range,\n        labelsCount: NumericAxis.prototype.labelsCount,\n        createAxisLabel: NumericAxis.prototype.createAxisLabel\n    });\n\n    var RadarNumericAxisMixin = {\n        options: {\n            majorGridLines: {\n                visible: true\n            }\n        },\n\n        createPlotBands: function() {\n            var this$1$1 = this;\n\n            var ref = this.options;\n            var type = ref.majorGridLines.type;\n            var plotBands = ref.plotBands; if (plotBands === void 0) { plotBands = []; }\n            var altAxis = this.plotArea.polarAxis;\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var group = this._plotbandGroup = new Group({\n                zIndex: -1\n            });\n\n            for (var i = 0; i < plotBands.length; i++) {\n                var band = plotBands[i];\n                var bandStyle = {\n                    fill: {\n                        color: band.color,\n                        opacity: band.opacity\n                    },\n                    stroke: {\n                        opacity: band.opacity\n                    }\n                };\n\n                var slot = this$1$1.getSlot(band.from, band.to, true);\n                var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n                var shape = (void 0);\n                if (type === ARC) {\n                    shape = ShapeBuilder.current.createRing(ring, bandStyle);\n                } else {\n                    shape = Path.fromPoints(this$1$1.plotBandPoints(ring, majorAngles), bandStyle).close();\n                }\n\n                group.append(shape);\n            }\n\n            this.appendVisual(group);\n        },\n\n        plotBandPoints: function(ring, angles) {\n            var innerPoints = [];\n            var outerPoints = [];\n            var center = [ ring.center.x, ring.center.y ];\n            var innerCircle = new Circle(center, ring.innerRadius);\n            var outerCircle = new Circle(center, ring.radius);\n\n            for (var i = 0; i < angles.length; i++) {\n                innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n                outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n            }\n\n            innerPoints.reverse();\n            innerPoints.push(innerPoints[0]);\n            outerPoints.push(outerPoints[0]);\n\n            return outerPoints.concat(innerPoints);\n        },\n\n        createGridLines: function(altAxis) {\n            var options = this.options;\n            var majorTicks = this.radarMajorGridLinePositions();\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var gridLines = [];\n\n            if (options.majorGridLines.visible) {\n                gridLines = this.renderGridLines(\n                    center, majorTicks, majorAngles, options.majorGridLines\n                );\n            }\n\n            if (options.minorGridLines.visible) {\n                var minorTicks = this.radarMinorGridLinePositions();\n                append(gridLines, this.renderGridLines(\n                    center, minorTicks, majorAngles, options.minorGridLines\n                ));\n            }\n\n            return gridLines;\n        },\n\n        renderGridLines: function(center, ticks, angles, options) {\n            var style = {\n                stroke: {\n                    width: options.width,\n                    color: options.color,\n                    dashType: options.dashType\n                }\n            };\n            var skip = options.skip; if (skip === void 0) { skip = 0; }\n            var step = options.step; if (step === void 0) { step = 0; }\n            var container = this.gridLinesVisual();\n\n            for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\n                var tickRadius = center.y - ticks[tickIx];\n                if (tickRadius > 0) {\n                    var circle = new Circle([ center.x, center.y ], tickRadius);\n                    if (options.type === ARC) {\n                        container.append(new drawing.Circle(circle, style));\n                    } else {\n                        var line = new Path(style);\n                        for (var angleIx = 0; angleIx < angles.length; angleIx++) {\n                            line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                        }\n\n                        line.close();\n                        container.append(line);\n                    }\n                }\n            }\n\n            return container.children;\n        },\n\n        getValue: function(point) {\n            var lineBox = this.lineBox();\n            var altAxis = this.plotArea.polarAxis;\n            var majorAngles = altAxis.majorAngles();\n            var center = altAxis.box.center();\n            var radius = point.distanceTo(center);\n            var distance = radius;\n\n            if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n                var dx = point.x - center.x;\n                var dy = point.y - center.y;\n                var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n                majorAngles.sort(function(a, b) {\n                    return angularDistance(a, theta) - angularDistance(b, theta);\n                });\n\n                // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n                // Angles are derived from triangle (center, point, gridline X)\n                var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n                var alpha = angularDistance(theta, majorAngles[0]);\n                var gamma = 90 - midAngle;\n                var beta = 180 - alpha - gamma;\n\n                distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n            }\n\n            return this.axisType().prototype.getValue.call(\n                this, new Point(lineBox.x1, lineBox.y2 - distance)\n            );\n        }\n    };\n\n    function angularDistance(a, b) {\n        return 180 - Math.abs(Math.abs(a - b) - 180);\n    }\n\n    var RadarNumericAxis = NumericAxis.extend({\n        radarMajorGridLinePositions: function() {\n            return this.getTickPositions(this.options.majorUnit);\n        },\n\n        radarMinorGridLinePositions: function() {\n            var options = this.options;\n            var minorSkipStep = 0;\n\n            if (options.majorGridLines.visible) {\n                minorSkipStep = options.majorUnit;\n            }\n            return this.getTickPositions(options.minorUnit, minorSkipStep);\n        },\n\n        axisType: function() {\n            return NumericAxis;\n        }\n    });\n\n    deepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);\n\n    var RadarLogarithmicAxis = LogarithmicAxis.extend({\n        radarMajorGridLinePositions: function() {\n            var positions = [];\n\n            this.traverseMajorTicksPositions(function(position) {\n                positions.push(position);\n            }, this.options.majorGridLines);\n\n            return positions;\n        },\n\n        radarMinorGridLinePositions: function() {\n            var positions = [];\n\n            this.traverseMinorTicksPositions(function(position) {\n                positions.push(position);\n            }, this.options.minorGridLines);\n\n            return positions;\n        },\n\n        axisType: function() {\n            return LogarithmicAxis;\n        }\n    });\n\n    deepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);\n\n    var WEIGHT = 0.333;\n    var EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\n    var CurveProcessor = Class.extend({\n        init: function(closed) {\n\n            this.closed = closed;\n        },\n\n        process: function(dataPoints) {\n            var this$1$1 = this;\n\n            var points = dataPoints.slice(0);\n            var segments = [];\n            var closed = this.closed;\n            var length = points.length;\n\n            if (length > 2) {\n                this.removeDuplicates(0, points);\n                length = points.length;\n            }\n\n            if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n                return segments;\n            }\n\n            var p0 = points[0];\n            var p1 = points[1];\n            var p2 = points[2];\n\n            segments.push(new Segment(p0));\n\n            while (p0.equals(points[length - 1])) {\n                closed = true;\n                points.pop();\n                length--;\n            }\n\n            if (length === 2) {\n                var tangent = this.tangent(p0,p1, X, Y);\n\n                last(segments).controlOut(\n                    this.firstControlPoint(tangent, p0, p1, X, Y)\n                );\n\n                segments.push(new Segment(\n                    p1,\n                    this.secondControlPoint(tangent, p0, p1, X, Y)\n                ));\n\n                return segments;\n            }\n\n            var initialControlPoint, lastControlPoint;\n\n            if (closed) {\n                p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n                var controlPoints = this.controlPoints(p0, p1, p2);\n                initialControlPoint = controlPoints[1];\n                lastControlPoint = controlPoints[0];\n            } else {\n                var tangent$1 = this.tangent(p0, p1, X,Y);\n                initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\n            }\n\n            var cp0 = initialControlPoint;\n            for (var idx = 0; idx <= length - 3; idx++) {\n                this$1$1.removeDuplicates(idx, points);\n                length = points.length;\n                if (idx + 3 <= length) {\n                    p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                    var controlPoints$1 = this$1$1.controlPoints(p0,p1,p2);\n\n                    last(segments).controlOut(cp0);\n                    cp0 = controlPoints$1[1];\n\n                    var cp1 = controlPoints$1[0];\n                    segments.push(new Segment(p1, cp1));\n                }\n            }\n\n            if (closed) {\n                p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n                var controlPoints$2 = this.controlPoints(p0, p1, p2);\n\n                last(segments).controlOut(cp0);\n                segments.push(new Segment(\n                    p1,\n                    controlPoints$2[0]\n                ));\n\n                last(segments).controlOut(controlPoints$2[1]);\n                segments.push(new Segment(\n                    p2,\n                    lastControlPoint\n                ));\n            } else {\n                var tangent$2 = this.tangent(p1, p2, X, Y);\n\n                last(segments).controlOut(cp0);\n                segments.push(new Segment(\n                    p2,\n                    this.secondControlPoint(tangent$2, p1, p2, X, Y)\n                ));\n            }\n\n            return segments;\n        },\n\n        removeDuplicates: function(idx, points) {\n            while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n                points.splice(idx + 1, 1);\n            }\n        },\n\n        invertAxis: function(p0, p1, p2) {\n            var invertAxis = false;\n\n            if (p0.x === p1.x) {\n                invertAxis = true;\n            } else if (p1.x === p2.x) {\n                if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                    invertAxis = true;\n                }\n            } else {\n                var fn = this.lineFunction(p0,p1);\n                var y2 = this.calculateFunction(fn, p2.x);\n                if (!(p0.y <= p1.y && p2.y <= y2) &&\n                    !(p1.y <= p0.y && p2.y >= y2)) {\n                    invertAxis = true;\n                }\n            }\n\n            return invertAxis;\n        },\n\n        isLine: function(p0, p1, p2) {\n            var fn = this.lineFunction(p0, p1);\n            var y2 = this.calculateFunction(fn, p2.x);\n\n            return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n        },\n\n        lineFunction: function(p1, p2) {\n            var a = (p2.y - p1.y) / (p2.x - p1.x);\n            var b = p1.y - a * p1.x;\n\n            return [ b, a ];\n        },\n\n        controlPoints: function(p0, p1, p2) {\n            var xField = X;\n            var yField = Y;\n            var restrict = false;\n            var switchOrientation = false;\n            var tangent;\n\n            if (this.isLine(p0, p1, p2)) {\n                tangent = this.tangent(p0, p1, X, Y);\n            } else {\n                var monotonic = {\n                    x: this.isMonotonicByField(p0, p1, p2, X),\n                    y: this.isMonotonicByField(p0, p1, p2, Y)\n                };\n\n                if (monotonic.x && monotonic.y) {\n                    tangent = this.tangent(p0, p2, X, Y);\n                    restrict = true;\n                } else {\n                    if (this.invertAxis(p0, p1, p2)) {\n                        xField = Y;\n                        yField = X;\n                    }\n\n                    if (monotonic[xField]) {\n                        tangent = 0;\n                    } else {\n                        var sign;\n                        if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                            (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                        } else {\n                            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                        }\n\n                        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                        switchOrientation = true;\n                    }\n                }\n            }\n\n            var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n            if (switchOrientation) {\n                var oldXField = xField;\n                xField = yField;\n                yField = oldXField;\n            }\n\n            var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n            if (restrict) {\n                this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n                this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n            }\n\n            return [ secondControlPoint, firstControlPoint ];\n        },\n\n        restrictControlPoint: function(p1, p2, cp, tangent) {\n            if (p1.y < p2.y) {\n                if (p2.y < cp.y) {\n                    cp.x = p1.x + (p2.y - p1.y) / tangent;\n                    cp.y = p2.y;\n                } else if (cp.y < p1.y) {\n                    cp.x = p2.x - (p2.y - p1.y) / tangent;\n                    cp.y = p1.y;\n                }\n            } else {\n                if (cp.y < p2.y) {\n                    cp.x = p1.x - (p1.y - p2.y) / tangent;\n                    cp.y = p2.y;\n                } else if (p1.y < cp.y) {\n                    cp.x = p2.x + (p1.y - p2.y) / tangent;\n                    cp.y = p1.y;\n                }\n            }\n        },\n\n        tangent: function(p0, p1, xField, yField) {\n            var x = p1[xField] - p0[xField];\n            var y = p1[yField] - p0[yField];\n            var tangent;\n\n            if (x === 0) {\n                tangent = 0;\n            } else {\n                tangent = y / x;\n            }\n\n            return tangent;\n        },\n\n        isMonotonicByField: function(p0, p1, p2, field) {\n            return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                        (p2[field] < p1[field] && p1[field] < p0[field]);\n        },\n\n        firstControlPoint: function(tangent, p0, p3, xField, yField) {\n            var t1 = p0[xField];\n            var t2 = p3[xField];\n            var distance = (t2 - t1) * WEIGHT;\n\n            return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n        },\n\n        secondControlPoint: function(tangent, p0, p3, xField, yField) {\n            var t1 = p0[xField];\n            var t2 = p3[xField];\n            var distance = (t2 - t1) * WEIGHT;\n\n            return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n        },\n\n        point: function(xValue, yValue, xField, yField) {\n            var controlPoint = new geometry.Point();\n            controlPoint[xField] = xValue;\n            controlPoint[yField] = yValue;\n\n            return controlPoint;\n        },\n\n        calculateFunction: function(fn, x) {\n            var length = fn.length;\n            var result = 0;\n\n            for (var i = 0; i < length; i++) {\n                result += Math.pow(x,i) * fn[i];\n            }\n            return result;\n        }\n    });\n\n    function numberSign(value) {\n        return value <= 0 ? -1 : 1;\n    }\n\n    dataviz.Gradients = GRADIENTS;\n\n    kendo.deepExtend(kendo.dataviz, {\n        constants: constants,\n        services: services,\n        autoMajorUnit: autoMajorUnit,\n        Point: Point,\n        Box: Box,\n        Ring: Ring,\n        Sector: Sector,\n        ShapeBuilder: ShapeBuilder,\n        ShapeElement: ShapeElement,\n        ChartElement: ChartElement,\n        BoxElement: BoxElement,\n        RootElement: RootElement,\n        FloatElement: FloatElement,\n        Text: Text,\n        TextBox: TextBox,\n        Title: Title,\n        AxisLabel: AxisLabel,\n        Axis: Axis,\n        Note: Note,\n        CategoryAxis: CategoryAxis,\n        DateCategoryAxis: DateCategoryAxis,\n        DateValueAxis: DateValueAxis,\n        NumericAxis: NumericAxis,\n        LogarithmicAxis: LogarithmicAxis,\n        PolarAxis: PolarAxis,\n        RadarCategoryAxis: RadarCategoryAxis,\n        RadarNumericAxis: RadarNumericAxis,\n        RadarLogarithmicAxis: RadarLogarithmicAxis,\n        CurveProcessor: CurveProcessor,\n        rectToBox: rectToBox,\n        addClass: addClass,\n        removeClass: removeClass,\n        alignPathToPixel: alignPathToPixel,\n        clockwise: clockwise,\n        convertableToNumber: convertableToNumber,\n        cycleUp: cycleUp,\n        cycleDown: cycleDown,\n        cycleIndex: cycleIndex,\n        deepExtend: deepExtend,\n        elementStyles: elementStyles,\n        getSpacing: getSpacing,\n        getTemplate: getTemplate,\n        getAriaTemplate: getTemplate$1,\n        getter: __common_getter_js,\n        grep: grep,\n        hasClasses: hasClasses,\n        HashMap: HashMap,\n        inArray: inArray,\n        interpolateValue: interpolateValue,\n        InstanceObserver: InstanceObserver,\n        isArray: isArray,\n        isFunction: isFunction,\n        isNumber: isNumber,\n        isObject: isObject,\n        isPlainObject: isPlainObject,\n        isString: isString,\n        map: map,\n        mousewheelDelta: mousewheelDelta,\n        FontLoader: FontLoader,\n        renderIcon: renderIcon,\n        setDefaultOptions: setDefaultOptions,\n        sparseArrayLimits: sparseArrayLimits,\n        styleValue: styleValue,\n        find: find,\n        elementScale: elementScale,\n        autoTextColor: autoTextColor,\n        createHashSet: createHashSet,\n        defaultErrorHandler: defaultErrorHandler,\n        keys: keys,\n        hasOwnProperty: hasOwnProperty,\n        Matrix: Matrix$1,\n        Observable: Observable$$1,\n        append: append,\n        bindEvents: bindEvents,\n        Class: Class,\n        defined: defined,\n        deg: deg,\n        elementOffset: elementOffset,\n        elementSize: elementSize,\n        eventCoordinates: eventCoordinates,\n        eventElement: eventElement,\n        hashKey: hashKey,\n        last: last,\n        limitValue: limitValue,\n        logToConsole: kendo.logToConsole,\n        objectKey: objectKey,\n        rad: rad,\n        round: round,\n        unbindEvents: unbindEvents,\n        valueOrDefault: valueOrDefault,\n        absoluteDateDiff: absoluteDateDiff,\n        addDuration: addDuration,\n        addTicks: addTicks,\n        ceilDate: ceilDate,\n        dateComparer: dateComparer,\n        dateDiff: dateDiff,\n        dateEquals: dateEquals,\n        dateIndex: dateIndex,\n        duration: duration,\n        floorDate: floorDate,\n        lteDateIndex: lteDateIndex,\n        startOfWeek: startOfWeek,\n        toDate: toDate,\n        parseDate: parseDate,\n        parseDates: parseDates,\n        toTime: toTime,\n        firstDay: firstDay\n    });\n\n    })(window.kendo.jQuery);\n\n    (function($) {\n\n        var dataviz = kendo.dataviz;\n        var services = dataviz.services;\n        var draw = kendo.drawing;\n\n        dataviz.SASS_THEMES = [\"sass\", \"default-v2\", \"bootstrap-v4\", \"material-v2\"];\n\n        dataviz.ExportMixin = {\n            extend: function(proto, skipLegacy) {\n                if (!proto.exportVisual) {\n                    throw new Error(\"Mixin target has no exportVisual method defined.\");\n                }\n\n                proto.exportSVG = this.exportSVG;\n                proto.exportImage = this.exportImage;\n                proto.exportPDF = this.exportPDF;\n\n                if (!skipLegacy) {\n                    proto.svg = this.svg;\n                    proto.imageDataURL = this.imageDataURL;\n                }\n            },\n\n            exportSVG: function(options) {\n                return draw.exportSVG(this.exportVisual(), options);\n            },\n\n            exportImage: function(options) {\n                return draw.exportImage(this.exportVisual(options), options);\n            },\n\n            exportPDF: function(options) {\n                return draw.exportPDF(this.exportVisual(), options);\n            },\n\n            svg: function() {\n                if (draw.svg.Surface) {\n                    return draw.svg.exportGroup(this.exportVisual());\n                } else {\n                    throw new Error(\"SVG Export failed. Unable to export instantiate kendo.drawing.svg.Surface\");\n                }\n            },\n\n            imageDataURL: function() {\n                if (!kendo.support.canvas) {\n                    return null;\n                }\n\n                if (draw.canvas.Surface) {\n                    var container = $(\"<div />\").css({\n                        display: \"none\",\n                        width: this.element.width(),\n                        height: this.element.height()\n                    }).appendTo(document.body);\n\n                    var surface = new draw.canvas.Surface(container[0]);\n                    surface.draw(this.exportVisual());\n                    var image = surface._rootElement.toDataURL();\n\n                    surface.destroy();\n                    container.remove();\n\n                    return image;\n                } else {\n                    throw new Error(\"Image Export failed. Unable to export instantiate kendo.drawing.canvas.Surface\");\n                }\n            }\n        };\n\n        services.IntlService.register({\n           format: function(format) {\n               return kendo.format.apply(null, [format].concat(Array.prototype.slice.call(arguments, 1)));\n           },\n           toString: kendo.toString,\n           parseDate: kendo.parseDate,\n           firstDay: function() {\n               return kendo.culture().calendars.standard.firstDay;\n           }\n        });\n\n        services.TemplateService.register({\n           compile: kendo.template\n        });\n\n        dataviz.Point2D = dataviz.Point;\n        dataviz.Box2D = dataviz.Box;\n        dataviz.mwDelta = function(e) {\n            return dataviz.mousewheelDelta(e.originalEvent);\n        };\n\n    })(window.kendo.jQuery);\n\n    var __meta__ = {\n        id: \"dataviz.core\",\n        name: \"Core\",\n        description: \"The DataViz core functions\",\n        category: \"dataviz\",\n        depends: [ \"core\", \"drawing\" ],\n        hidden: true\n    };\n\n    var kendo$1 = kendo;\n\n    return kendo$1;\n\n}));\n"]}