{"version":3,"sources":["raw-js/kendo.dataviz.gauge.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendodataviz","gauge","js","this","$","window","kendo","dataviz","getSpacing","defined","constants","BLACK","COORD_PRECISION","services","deepExtend","isArray","setDefaultOptions","NumericAxis","limitValue","Box","interpolateValue","round","drawing","DrawingGroup","Group","DrawingPath","Path","Animation","AnimationFactory","geometry","Rect","GeometryPoint","Point","transform","ANGULAR_SPEED","ARROW_POINTER","BAR_POINTER","DEFAULT_LINE_WIDTH","DEGREE","Math","PI","INSIDE","LINEAR","OUTSIDE","RADIAL_POINTER","RADIAL_RANGE_POINTER","pad","bbox","value","origin","getOrigin","size","getSize","spacing","setOrigin","x","left","y","top","setSize","width","right","height","bottom","Path$1","Text","buildLabelElement","label","options","labelBox","box","textBox","children","border","background","wrapper","fromRect","x1","y1","stroke","text","font","fill","color","styleGeometry","clone","padding","styleBox","opacity","dashType","lineJoin","lineCap","elements","append","getRange","range","min","max","from","MIN_VALUE","to","MAX_VALUE","unpad","Surface","Gauge","Class","extend","init","element","userOptions","theme","context","contextService","ChartService","_originalOptions","_initTheme","redraw","destroy","surface","surfaceElement","pointerValue","pointer","pointers","arguments","length","_setValueOptions","_draw","clear","draw","_visuals","exportVisual","allValues","values","i","push","i$1","isNumber","concat","arrayValues","resize","noTransitionsRedraw","transitions","_toggleTransitions","_surfaceSize","_initSurface","gaugeArea","_createGaugeArea","_createModel","_gaugeAreaMargin","reflow","setOptions","setDirection","rtl","Boolean","type","setIntlService","intl","currentTheme","areaGeometry","margin","_surfaceElement","elementSize","renderAs","create","_getSize","document","createElement","appendChild","defaultSize","_defaultSize","offsetWidth","offsetHeight","animation","plotArea","scale","Path$2","Group$2","renderAxisTick","tickRenderOptions","tickOptions","start","end","position","tickX","tickY","vertical","moveTo","lineTo","renderTicks","tickGroup","tickPositions","count","visible","mirror","lineBox","skip","step","skipUnit","x2","LinearScale","service","scaleOptions","reverse","fn","call","minorUnit","majorUnit","initUserOptions","labels","autoMajorUnit","initFields","render","renderLabels","scaleLine","renderLine","scaleTicks","ranges","renderRanges","this$1$1","rangeSize","minorTicks","slot","getSlot","slotX","slotY","y2","line","linePath","ticks","majorTicks","getMajorTickPositions","getMinorTickPositions","align","_alignLines","Pointer","ref","newValue","_oldValue","repaint","LinearPointer","track","pointerBox","pointerRangeBox","trackBox","ref$1","trackSize","pointerHalfSize","space","shape","getElementOptions","_margin","ArrowLinearPointerAnimation","setup","axis","fromScale","toScale","duration","distanceTo","pos","translateX","translateY","translate","easing","current","register","Point$1","Path$3","ArrowLinearPointer","pointerShape","halfSize","sign","play","elementOptions","close","BarLinearPointerAnimation","Y","X","newPoints","oldPoints","abs","speed","_set","setter","toUpperCase","points","Group$3","Path$4","BarLinearPointer","dir","minSlot","sizeAxis","p1","p2","p3","p4","pointerPath","oldShape","group","renderTrack","trackOptions","toRect","Group$1","LinearGauge","bboxX","bboxY","_shrinkScaleWidth","_getBox","_alignElements","_shrinkElements","_buildVisual","visuals","scaleElements","currentOptions","pointerType","boxCenter","center","plotAreaBox","wrap","diff","scaleBox","overflow","contentBox","shrink","alignTo","GEO_ARC_ADJUST_ANGLE","Arc","Path$5","Group$5","drawTicks","arc","tickAngles","unit","radius","getRadiusX","tickStart","pointAt","tickEnd","rotate","rangeSegment","RadialScale","renderArc","labelElements","repositionRanges","slotAngle","startAngle","endAngle","angle","hasRanges","ticksSize","labelsCount","labelsGroup","rangeDistance","labelsOptions","isInside","hasLabelElements","setRadiusX","setRadiusY","paddingWidth","paddingHeight","halfWidth","halfHeight","labelAngle","lp","cx","cos","cy","sin","labelPos","labelElement","prevLabelPos","labelTransform","union","rangeRadius","getRangeRadius","newRadius","_geometry","segments","rangeSegments","segmentsCount","result","segment","createRange","rangeGeom","radiusX","radiusY","defaultColor","rangePlaceholderColor","j","majorTickSize","tickArc","majorTickAngles","allTicks","minorTickSize","_tickDifference","minorTickAngles","normalizeTickAngles","angles","splice","ring","stepValue","tickCount","positions","repositionTicks","minor","newPoint","xDiff","anchor","yDiff","RadialPointerAnimation","animationOptions","newAngle","oldAngle","Circle","Group$6","Path$6","RadialPointer","setAngle","_renderNeedle","_renderCap","capSize","cap","fromPoints","needleColor","needlePath","capColor","circle","arrow","Group$4","RadialGauge","_initialPlotArea","fitScale","alignScale","_buildPointers","minDiff","midDiff","maxDiff","mid","oldDiff","getDiff","staleFlag","getPlotBox","scaleArc","plotBbox","plotBox","plotBoxCenter","paddingX","paddingY","pointersArr","ArcScale","rangeLineCap","placeholderRangeAngle","geometry$$1","setEndAngle","setStartAngle","addRange","RangePointerAnimation","startColor","get","currentColor","Color","r","g","b","toHex","RangePointer","abort","colors","currentValue","idx","ref$2","rangeColor","ArcGauge","centerLabelPosition","yLimit","bottomRight","CircularGauge","jQuery","Widget","ui","themeOptions","themes","themeName","lowerName","toLowerCase","SASS_THEMES","indexOf","autoTheme","empty","_createInstance","addClass","notify","_instance","_copyFields","gaugeType","_gaugeType","_resize","proxyMembers","createProxyMember","name","apply","ExportMixin","RadialGaugeWidget","LinearGaugeWidget","ArcGaugeWidget","css","_centerTemplate","instance","_centerElement","centerTemplate","template","centerElement","_getCenterElement","html","remove","CircularGaugeWidget","createExportMethod","method","drawDOM","then","visual","exportMethods","plugin"],"mappings":"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","file":"kendo.dataviz.gauge.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('kendo.core.js'), require('kendo.color.js'), require('kendo.drawing.js'), require('kendo.dataviz.core.js'), require('kendo.dataviz.themes.js')) :\n    typeof define === 'function' && define.amd ? define(['kendo.core', 'kendo.color', 'kendo.drawing', 'kendo.dataviz.core', 'kendo.dataviz.themes'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.kendodataviz = global.kendodataviz || {}, global.kendodataviz.gauge = global.kendodataviz.gauge || {}, global.kendodataviz.gauge.js = factory()));\n})(this, (function () {\n    /***********************************************************************\n     * WARNING: this file is auto-generated.  If you change it directly,\n     * your modifications will eventually be lost.  The source code is in\n     * `kendo-charts` repository, you should make your changes there and\n     * run `src-modules/sync.sh` in this repository.\n     */\n\n    (function($) {\n    /* eslint-disable space-before-blocks, space-before-function-paren */\n\n    window.kendo.dataviz = window.kendo.dataviz || {};\n    var dataviz = kendo.dataviz;\n    var getSpacing = dataviz.getSpacing;\n    var defined = dataviz.defined;\n    var constants = dataviz.constants;\n    var BLACK = constants.BLACK;\n    var COORD_PRECISION = constants.COORD_PRECISION;\n    var services = dataviz.services;\n    var deepExtend = dataviz.deepExtend;\n    var isArray = dataviz.isArray;\n    var setDefaultOptions = dataviz.setDefaultOptions;\n    var NumericAxis = dataviz.NumericAxis;\n    var limitValue = dataviz.limitValue;\n    var Box = dataviz.Box;\n    var interpolateValue = dataviz.interpolateValue;\n    var round = dataviz.round;\n    var drawing = kendo.drawing;\n    var DrawingGroup = drawing.Group;\n    var DrawingPath = drawing.Path;\n    var Animation = drawing.Animation;\n    var AnimationFactory = drawing.AnimationFactory;\n    var geometry = kendo.geometry;\n    var Rect = geometry.Rect;\n    var GeometryPoint = geometry.Point;\n    var transform = geometry.transform;\n\n    var ANGULAR_SPEED = 150;\n    var LINEAR_SPEED = 250;\n    var ARROW = \"arrow\";\n    var ARROW_POINTER = \"arrowPointer\";\n    var BAR_POINTER = \"barPointer\";\n    var DEFAULT_HEIGHT = 200;\n    var DEFAULT_LINE_WIDTH = 0.5;\n    var DEFAULT_WIDTH = 200;\n    var DEGREE = Math.PI / 180;\n    var INSIDE = \"inside\";\n    var LINEAR = \"linear\";\n    var OUTSIDE = \"outside\";\n    var RADIAL_POINTER = \"radialPointer\";\n    var RADIAL_RANGE_POINTER = \"radialRangePointer\";\n\n    function pad(bbox, value) {\n        var origin = bbox.getOrigin();\n        var size = bbox.getSize();\n        var spacing = getSpacing(value);\n\n        bbox.setOrigin([ origin.x - spacing.left, origin.y - spacing.top ]);\n        bbox.setSize([ size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom) ]);\n\n        return bbox;\n    }\n\n    var Group = DrawingGroup;\n    var Path$1 = DrawingPath;\n    var Text = drawing.Text;\n\n    function buildLabelElement(label, options) {\n        var labelBox = label.box;\n        var textBox = label.children[0].box;\n        var border = options.border || {};\n        var background = options.background || \"\";\n\n        var wrapper = Path$1.fromRect(new Rect([ labelBox.x1, labelBox.y1 ], [ labelBox.width(), labelBox.height() ]), {\n            stroke: {}\n        });\n\n        var text = new Text(label.text, new GeometryPoint(textBox.x1, textBox.y1), {\n            font: options.font,\n            fill: { color: options.color }\n        });\n\n        var styleGeometry = pad(text.bbox().clone(), options.padding);\n\n        var styleBox = Path$1.fromRect(styleGeometry, {\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                opacity: border.opacity,\n                dashType: border.dashType,\n                lineJoin: \"round\",\n                lineCap: \"round\"\n            },\n            fill: {\n                color: background\n            }\n        });\n\n        var elements = new Group();\n        elements.append(wrapper);\n        elements.append(styleBox);\n        elements.append(text);\n\n        return elements;\n    }\n\n    function getRange(range, min, max) {\n        var from = defined(range.from) ? range.from : constants.MIN_VALUE;\n        var to = defined(range.to) ? range.to : constants.MAX_VALUE;\n\n        range.from = Math.max(Math.min(to, from), min);\n        range.to = Math.min(Math.max(to, from), max);\n\n        return range;\n    }\n\n    function unpad(bbox, value) {\n        var spacing = getSpacing(value);\n\n        spacing.left = -spacing.left; spacing.top = -spacing.top;\n        spacing.right = -spacing.right; spacing.bottom = -spacing.bottom;\n\n        return pad(bbox, spacing);\n    }\n\n    var DEFAULT_MARGIN = 5;\n    var Path = DrawingPath;\n    var Surface = drawing.Surface;\n\n    var Gauge = dataviz.Class.extend({\n        init: function(element, userOptions, theme, context) {\n            if (context === void 0) { context = {}; }\n\n            this.element = element;\n            this.theme = theme;\n            this.contextService = new services.ChartService(this, context);\n            this._originalOptions = deepExtend({}, this.options, userOptions);\n            this.options = deepExtend({}, this._originalOptions);\n            this._initTheme(theme);\n\n            this.redraw();\n        },\n\n        destroy: function() {\n            if (this.surface) {\n                this.surface.destroy();\n                this.surface = null;\n            }\n\n            delete this.element;\n            delete this.surfaceElement;\n        },\n\n        value: function(pointerValue) {\n            var pointer = this.pointers[0];\n\n            if (arguments.length === 0) {\n                return pointer.value();\n            }\n\n            pointer.value(pointerValue);\n            this._setValueOptions(pointerValue);\n        },\n\n        _draw: function() {\n            var surface = this.surface;\n\n            surface.clear();\n            surface.draw(this._visuals);\n        },\n\n        exportVisual: function() {\n            return this._visuals;\n        },\n\n        allValues: function(values) {\n            var pointers = this.pointers;\n            var allValues = [];\n\n            if (arguments.length === 0) {\n                for (var i = 0; i < pointers.length; i++) {\n                    allValues.push(pointers[i].value());\n                }\n\n                return allValues;\n            }\n\n            if (isArray(values)) {\n                for (var i$1 = 0; i$1 < values.length; i$1++) {\n                    if (dataviz.isNumber(values[i$1])) {\n                        pointers[i$1].value(values[i$1]);\n                    }\n                }\n            }\n\n            this._setValueOptions(values);\n        },\n\n        _setValueOptions: function(values) {\n            var pointers = [].concat(this.options.pointer);\n            var arrayValues = [].concat(values);\n\n            for (var i = 0; i < arrayValues.length; i++) {\n                pointers[i].value = arrayValues[i];\n            }\n        },\n\n        resize: function() {\n            this.noTransitionsRedraw();\n        },\n\n        noTransitionsRedraw: function() {\n            var transitions = this.options.transitions;\n\n            this._toggleTransitions(false);\n\n            this.redraw();\n\n            this._toggleTransitions(transitions);\n        },\n\n        redraw: function() {\n            var size = this._surfaceSize();\n            var wrapper = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n            this._initSurface();\n\n            this.gaugeArea = this._createGaugeArea();\n\n            this._createModel();\n\n            var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);\n            this.reflow(bbox);\n        },\n\n        setOptions: function(options, theme) {\n            this._originalOptions = deepExtend(this._originalOptions, options);\n            this.options = deepExtend({}, this._originalOptions);\n\n            this._initTheme(theme);\n\n            this.redraw();\n        },\n\n        setDirection: function(rtl) {\n            this.contextService.rtl = Boolean(rtl);\n            if (this.surface && this.surface.type === 'svg') {\n                this.surface.destroy();\n                this.surface = null;\n            }\n        },\n\n        setIntlService: function(intl) {\n            this.contextService.intl = intl;\n        },\n\n        _initTheme: function(theme) {\n            var currentTheme = theme || this.theme || {};\n            this.theme = currentTheme;\n\n            this.options = deepExtend({}, currentTheme, this.options);\n            var options = this.options;\n            var pointer = options.pointer;\n\n            if (isArray(pointer)) {\n                var pointers = [];\n                for (var i = 0; i < pointer.length; i++) {\n                    pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));\n                }\n                options.pointer = pointers;\n            }\n        },\n\n        _createGaugeArea: function() {\n            var options = this.options.gaugeArea;\n            var size = this.surface.size();\n            var border = options.border || {};\n            var areaGeometry = new Rect([ 0, 0 ], [ size.width, size.height ]);\n\n            this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;\n\n            if (border.width > 0) {\n                areaGeometry = unpad(areaGeometry, border.width);\n            }\n\n            var gaugeArea = Path.fromRect(areaGeometry, {\n                stroke: {\n                    color: border.width ? border.color : \"\",\n                    width: border.width,\n                    opacity: border.opacity,\n                    dashType: border.dashType,\n                    lineJoin: \"round\",\n                    lineCap: \"round\"\n                },\n                fill: {\n                    color: options.background\n                }\n            });\n\n            return gaugeArea;\n        },\n\n        _initSurface: function() {\n            var ref = this;\n            var options = ref.options;\n            var surface = ref.surface;\n            var element = this._surfaceElement();\n            var size = this._surfaceSize();\n\n            dataviz.elementSize(element, size);\n\n            if (!surface || surface.options.type !== options.renderAs) {\n                if (surface) {\n                    surface.destroy();\n                }\n\n                this.surface = Surface.create(element, {\n                    type: options.renderAs\n                });\n            } else {\n                this.surface.clear();\n                this.surface.resize();\n            }\n        },\n\n        _surfaceSize: function() {\n            var options = this.options;\n            var size = this._getSize();\n\n            if (options.gaugeArea) {\n                deepExtend(size, options.gaugeArea);\n            }\n\n            return size;\n        },\n\n        _surfaceElement: function() {\n            if (!this.surfaceElement) {\n                this.surfaceElement = document.createElement('div');\n                this.element.appendChild(this.surfaceElement);\n            }\n\n            return this.surfaceElement;\n        },\n\n        getSize: function() {\n            return this._getSize();\n        },\n\n        _getSize: function() {\n            var element = this.element;\n            var defaultSize = this._defaultSize();\n            var width = element.offsetWidth;\n            var height = element.offsetHeight;\n\n            if (!width) {\n                width = defaultSize.width;\n            }\n\n            if (!height) {\n                height = defaultSize.height;\n            }\n\n            return { width: width, height: height };\n        },\n\n        _defaultSize: function() {\n            return {\n                width: DEFAULT_WIDTH,\n                height: DEFAULT_HEIGHT\n            };\n        },\n\n        _toggleTransitions: function(value) {\n            var this$1$1 = this;\n\n            this.options.transitions = value;\n            for (var i = 0; i < this.pointers.length; i++) {\n                this$1$1.pointers[i].options.animation.transitions = value;\n            }\n        }\n    });\n\n    setDefaultOptions(Gauge, {\n        plotArea: {},\n        theme: \"sass\",\n        renderAs: \"\",\n        pointer: {},\n        scale: {},\n        gaugeArea: {}\n    });\n\n    var Path$2 = DrawingPath;\n    var Group$2 = DrawingGroup;\n    var Point = GeometryPoint;\n\n    function renderAxisTick(tickRenderOptions, tickOptions) {\n        var position = tickRenderOptions.position;\n        var tickX = tickRenderOptions.tickX;\n        var tickY = tickRenderOptions.tickY;\n        var start, end;\n\n        if (tickRenderOptions.vertical) {\n            start = new Point(tickX, position);\n            end = new Point(tickX + tickOptions.size, position);\n        } else {\n            start = new Point(position, tickY);\n            end = new Point(position, tickY + tickOptions.size);\n        }\n\n        var tickPath = new Path$2({\n            stroke: {\n                color: tickOptions.color,\n                width: tickOptions.width\n            }\n        }).moveTo(start).lineTo(end);\n\n        return tickPath;\n    }\n\n    function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {\n        var count = tickPositions.length;\n\n        if (tickOptions.visible) {\n            var mirror = tickRenderOptions.mirror;\n            var lineBox = tickRenderOptions.lineBox;\n            for (var i = tickOptions.skip; i < count; i += tickOptions.step) {\n                if (i % tickOptions.skipUnit === 0) {\n                    continue;\n                }\n\n                tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                tickRenderOptions.position = tickPositions[i];\n\n                tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));\n            }\n        }\n    }\n\n    var LinearScale = NumericAxis.extend({\n        init: function(options, service) {\n            var scaleOptions = options || {};\n            if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {\n                scaleOptions = $.extend({}, scaleOptions, {\n                    reverse: true\n                });\n            }\n\n            NumericAxis.fn.init.call(this, 0, 1, scaleOptions, service);\n\n            this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;\n        },\n\n        initUserOptions: function(options) {\n            var scaleOptions = deepExtend({}, this.options, options);\n            scaleOptions = deepExtend({}, scaleOptions , { labels: { mirror: scaleOptions.mirror } });\n            scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n\n            return scaleOptions;\n        },\n\n        initFields: function() {\n        },\n\n        render: function() {\n            var elements = this.elements = new Group$2();\n            var labels = this.renderLabels();\n            var scaleLine = this.renderLine();\n            var scaleTicks = this.renderTicks();\n            var ranges = this.renderRanges();\n\n            elements.append(scaleLine, labels, scaleTicks, ranges);\n\n            return elements;\n        },\n\n        renderRanges: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var min = options.min;\n            var max = options.max;\n            var vertical = options.vertical;\n            var mirror = options.labels.mirror;\n            var ranges = options.ranges || [];\n            var elements = new Group$2();\n            var count = ranges.length;\n            var rangeSize = options.rangeSize || options.minorTicks.size / 2;\n\n            for (var i = 0; i < count; i++) {\n                var range = getRange(ranges[i], min, max);\n                var slot = this$1$1.getSlot(range.from, range.to);\n                var slotX = vertical ? this$1$1.lineBox() : slot;\n                var slotY = vertical ? slot : this$1$1.lineBox();\n                if (vertical) {\n                    slotX.x1 -= rangeSize * (mirror ? -1 : 1);\n                } else {\n                    slotY.y2 += rangeSize * (mirror ? -1 : 1);\n                }\n\n                elements.append(Path$2.fromRect(new Rect([ slotX.x1, slotY.y1 ], [ slotX.x2 - slotX.x1, slotY.y2 - slotY.y1 ]), {\n                    fill: { color: range.color, opacity: range.opacity },\n                    stroke: { }\n                }));\n            }\n\n            return elements;\n        },\n\n        renderLabels: function() {\n            var ref = this;\n            var labels = ref.labels;\n            var options = ref.options;\n            var elements = new Group$2();\n\n            for (var i = 0; i < labels.length; i++) {\n                elements.append(buildLabelElement(labels[i], options.labels));\n            }\n\n            return elements;\n        },\n\n        renderLine: function() {\n            var line = this.options.line;\n            var lineBox = this.lineBox();\n            var elements = new Group$2();\n\n            if (line.width > 0 && line.visible) {\n                var linePath = new Path$2({\n                    stroke: {\n                        color: line.color,\n                        dashType: line.dashType,\n                        width: line.width\n                    }\n                });\n\n                linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n                elements.append(linePath);\n            }\n\n            return elements;\n        },\n\n        renderTicks: function() {\n            var ticks = new Group$2();\n            var options = this.options;\n            var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n            var tickRenderOptions = {\n                vertical: options.vertical,\n                mirror: options.labels.mirror,\n                lineBox: this.lineBox()\n            };\n\n            renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);\n            renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {\n                skipUnit: majorUnit / options.minorUnit\n            }, options.minorTicks));\n\n            return ticks;\n        }\n    });\n\n    setDefaultOptions(LinearScale, {\n        min: 0,\n        max: 50,\n\n        majorTicks: {\n            size: 15,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n        },\n\n        minorTicks: {\n            size: 10,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n        },\n\n        line: {\n            width: DEFAULT_LINE_WIDTH\n        },\n\n        labels: {\n            position: INSIDE,\n            padding: 2\n        },\n        mirror: false,\n        _alignLines: false\n    });\n\n    var Pointer = dataviz.Class.extend({\n        init: function(scale, userOptions) {\n\n            var ref = scale.options;\n            var min = ref.min;\n            var max = ref.max;\n            var options = this.options = deepExtend({}, this.options, userOptions);\n\n            options.fill = options.color;\n\n            this.scale = scale;\n\n            if (defined(options.value)) {\n                options.value = limitValue(options.value, min, max);\n            } else {\n                options.value = min;\n            }\n        },\n\n        value: function(newValue) {\n            var options = this.options;\n            var value = options.value;\n\n            if (arguments.length === 0) {\n                return value;\n            }\n\n            var ref = this.scale.options;\n            var min = ref.min;\n            var max = ref.max;\n\n            options._oldValue = defined(options._oldValue) ? options.value : min;\n            options.value = limitValue(newValue, min, max);\n\n            if (this.elements) {\n                this.repaint();\n            }\n        }\n    });\n\n    setDefaultOptions(Pointer, {\n        color: BLACK\n    });\n\n    var LinearPointer = Pointer.extend({\n        init: function(scale, options) {\n            Pointer.fn.init.call(this, scale, options);\n\n            this.options = deepExtend({\n                track: {\n                    visible: defined(options.track)\n                }\n            }, this.options);\n        },\n\n        reflow: function() {\n            var ref = this;\n            var options = ref.options;\n            var scale = ref.scale;\n            var ref$1 = scale.options;\n            var mirror = ref$1.mirror;\n            var vertical = ref$1.vertical;\n            var scaleLine = scale.lineBox();\n            var trackSize = options.track.size || options.size;\n            var pointerHalfSize = options.size / 2;\n            var margin = getSpacing(options.margin);\n            var space = vertical ?\n                margin[mirror ? \"left\" : \"right\"] :\n                margin[mirror ? \"bottom\" : \"top\"];\n            var pointerBox, pointerRangeBox, trackBox;\n\n            space = mirror ? -space : space;\n\n            if (vertical) {\n                trackBox = new Box(\n                    scaleLine.x1 + space, scaleLine.y1,\n                    scaleLine.x1 + space, scaleLine.y2);\n\n                if (mirror) {\n                    trackBox.x1 -= trackSize;\n                } else {\n                    trackBox.x2 += trackSize;\n                }\n\n                if (options.shape !== BAR_POINTER) {\n                    pointerRangeBox = new Box(\n                        scaleLine.x2 + space, scaleLine.y1 - pointerHalfSize,\n                        scaleLine.x2 + space, scaleLine.y2 + pointerHalfSize\n                    );\n                    pointerBox = pointerRangeBox;\n                }\n            } else {\n                trackBox = new Box(\n                    scaleLine.x1, scaleLine.y1 - space,\n                    scaleLine.x2, scaleLine.y1 - space);\n\n                if (mirror) {\n                    trackBox.y2 += trackSize;\n                } else {\n                    trackBox.y1 -= trackSize;\n                }\n\n                if (options.shape !== BAR_POINTER) {\n                    pointerRangeBox = new Box(\n                        scaleLine.x1 - pointerHalfSize, scaleLine.y1 - space,\n                        scaleLine.x2 + pointerHalfSize, scaleLine.y1 - space\n                    );\n                    pointerBox = pointerRangeBox;\n                }\n            }\n\n            this.trackBox = trackBox;\n            this.pointerRangeBox = pointerRangeBox;\n            this.box = pointerBox || trackBox.clone().pad(options.border.width);\n        },\n\n        getElementOptions: function() {\n            var options = this.options;\n\n            return {\n                fill: {\n                    color: options.color,\n                    opacity: options.opacity\n                },\n                stroke: defined(options.border) ? {\n                    color: options.border.width ? options.border.color || options.color : \"\",\n                    width: options.border.width,\n                    dashType: options.border.dashType,\n                    opacity: options.opacity\n                } : null\n            };\n        },\n\n        _margin: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var ref$1 = scale.options;\n            var mirror = ref$1.mirror;\n            var vertical = ref$1.vertical;\n            var margin = getSpacing(options.margin);\n\n            var space = vertical ?\n                margin[mirror ? \"left\" : \"right\"] :\n                margin[mirror ? \"bottom\" : \"top\"];\n\n            return space;\n        }\n    });\n\n    setDefaultOptions(LinearPointer, {\n        shape: BAR_POINTER,\n\n        track: {\n            border: {\n                width: 1\n            }\n        },\n\n        color: BLACK,\n        border: {\n            width: 1\n        },\n        opacity: 1,\n\n        margin: getSpacing(3),\n        animation: {\n            type: BAR_POINTER\n        },\n        visible: true\n    });\n\n    var ArrowLinearPointerAnimation = Animation.extend({\n        setup: function() {\n            var options = this.options;\n            var margin = options.margin;\n            var from = options.from;\n            var to = options.to;\n            var vertical = options.vertical;\n            var axis = vertical ? \"x1\" : \"y1\";\n\n            if (options.mirror === vertical) {\n                from[axis] -= margin; to[axis] -= margin;\n            } else {\n                from[axis] += margin; to[axis] += margin;\n            }\n\n            var fromScale = this.fromScale = new GeometryPoint(from.x1, from.y1);\n            var toScale = this.toScale = new GeometryPoint(to.x1, to.y1);\n\n            if (options.duration !== 0) {\n                options.duration = Math.max((fromScale.distanceTo(toScale) / options.duration) * 1000, 1);\n            }\n        },\n\n        step: function(pos) {\n            var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);\n            var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);\n\n            this.element.transform(transform().translate(translateX, translateY));\n        }\n    });\n\n    setDefaultOptions(ArrowLinearPointerAnimation, {\n        easing: LINEAR,\n        duration: LINEAR_SPEED\n    });\n\n    AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);\n\n    var Point$1 = GeometryPoint;\n    var Path$3 = DrawingPath;\n\n    var ArrowLinearPointer = LinearPointer.extend({\n        init: function(scale, options) {\n            LinearPointer.fn.init.call(this, scale, options);\n\n            if (!defined(this.options.size)) {\n                this.options.size = this.scale.options.majorTicks.size * 0.6;\n            }\n        },\n\n        pointerShape: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var size = ref.options.size;\n            var halfSize = size / 2;\n            var sign = (scale.options.mirror ? -1 : 1);\n            var shape;\n\n            if (scale.options.vertical) {\n                shape = [\n                    new Point$1(0, 0 - halfSize), new Point$1(0 - sign * size, 0), new Point$1(0, 0 + halfSize)\n                ];\n            } else {\n                shape = [\n                    new Point$1(0 - halfSize, 0), new Point$1(0, 0 + sign * size), new Point$1(0 + halfSize, 0)\n                ];\n            }\n\n            return shape;\n        },\n\n        repaint: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var animation = new ArrowLinearPointerAnimation(this.elements, deepExtend(options.animation, {\n                vertical: scale.options.vertical,\n                mirror: scale.options.mirror,\n                margin: this._margin(options.margin),\n                from: scale.getSlot(options._oldValue),\n                to: scale.getSlot(options.value)\n            }));\n\n            if (options.animation.transitions === false) {\n                animation.options.duration = 0;\n            }\n\n            animation.setup();\n            animation.play();\n        },\n\n        render: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var elementOptions = this.getElementOptions();\n            var shape = this.pointerShape(options.value);\n\n            options.animation.type = ARROW_POINTER;\n\n            var elements = new Path$3({\n                stroke: elementOptions.stroke,\n                fill: elementOptions.fill\n            }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();\n\n            var slot = scale.getSlot(options.value);\n            elements.transform(transform().translate(slot.x1, slot.y1));\n\n            this.elements = elements;\n\n            return elements;\n        }\n    });\n\n    var BarLinearPointerAnimation = Animation.extend({\n        setup: function() {\n            var options = this.options;\n            var axis = this.axis = options.vertical ? constants.Y : constants.X;\n            var to = this.to = options.newPoints[0][axis];\n            var from = this.from = options.oldPoints[0][axis];\n\n            if (options.duration !== 0) {\n                options.duration = Math.max((Math.abs(to - from) / options.speed) * 1000, 1);\n            }\n\n            this._set(from);\n        },\n\n        step: function(pos) {\n            var value = interpolateValue(this.from, this.to, pos);\n            this._set(value);\n        },\n\n        _set: function(value) {\n            var setter = \"set\" + this.axis.toUpperCase();\n            var points = this.options.newPoints;\n\n            points[0][setter](value);\n            points[1][setter](value);\n        }\n    });\n\n    setDefaultOptions(BarLinearPointerAnimation, {\n        easing: LINEAR,\n        speed: LINEAR_SPEED\n    });\n\n    AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);\n\n    var Group$3 = DrawingGroup;\n    var Path$4 = DrawingPath;\n\n    var BarLinearPointer = LinearPointer.extend({\n        init: function(scale, options) {\n            LinearPointer.fn.init.call(this, scale, options);\n\n            if (!defined(this.options.size)) {\n                this.options.size = this.scale.options.majorTicks.size * 0.3;\n            }\n        },\n\n        pointerShape: function(value) {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var ref$1 = scale.options;\n            var mirror = ref$1.mirror;\n            var vertical = ref$1.vertical;\n            var dir = mirror === vertical ? -1 : 1;\n            var size = options.size * dir;\n            var minSlot = scale.getSlot(scale.options.min);\n            var slot = scale.getSlot(value);\n            var axis = vertical ? constants.Y : constants.X;\n            var sizeAxis = vertical ? constants.X : constants.Y;\n            var margin = this._margin() * dir;\n\n            var p1 = new GeometryPoint();\n            p1[axis] = minSlot[axis + \"1\"];\n            p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n\n            var p2 = new GeometryPoint();\n            p2[axis] = slot[axis + \"1\"];\n            p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n            if (vertical) {\n                p1.translate(margin, 0);\n                p2.translate(margin, 0);\n            } else {\n                p1.translate(0, margin);\n                p2.translate(0, margin);\n            }\n\n            var p3 = p2.clone();\n            var p4 = p1.clone();\n\n            if (vertical) {\n                p3.translate(size, 0);\n                p4.translate(size, 0);\n            } else {\n                p3.translate(0, size);\n                p4.translate(0, size);\n            }\n\n            return [ p1, p2, p3, p4 ];\n        },\n\n        repaint: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var shape = this.pointerShape(options.value);\n            var pointerPath = this.pointerPath;\n            var oldShape = this.pointerShape(options._oldValue);\n\n            pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n\n            var animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n                reverse: scale.options.reverse,\n                vertical: scale.options.vertical,\n                oldPoints: [ oldShape[1], oldShape[2] ],\n                newPoints: [ shape[1], shape[2] ]\n            }));\n\n            if (options.animation.transitions === false) {\n                animation.options.duration = 0;\n            }\n\n            animation.setup();\n            animation.play();\n        },\n\n        render: function() {\n            var group = new Group$3();\n            var elementOptions = this.getElementOptions();\n\n            if (this.options.track.visible) {\n                group.append(this.renderTrack());\n            }\n\n            var pointer = this.pointerPath = new Path$4({\n                stroke: elementOptions.stroke,\n                fill: elementOptions.fill\n            });\n\n            group.append(pointer);\n\n            this.elements = group;\n\n            return group;\n        },\n\n        renderTrack: function() {\n            var trackOptions = this.options.track;\n            var border = trackOptions.border || {};\n            var trackBox = this.trackBox.clone().pad(border.width || 0);\n\n            return new Path$4.fromRect(trackBox.toRect(), {\n                fill: {\n                    color: trackOptions.color,\n                    opacity: trackOptions.opacity\n                },\n                stroke: {\n                    color: border.width ? border.color || trackOptions.color : \"\",\n                    width: border.width,\n                    dashType: border.dashType\n                }\n            });\n        }\n    });\n\n    var DEFAULT_MIN_WIDTH = 60;\n    var DEFAULT_MIN_HEIGHT = 60;\n\n    var Group$1 = DrawingGroup;\n\n    var LinearGauge = Gauge.extend({\n        reflow: function(bbox) {\n            var pointers = this.pointers;\n            var bboxX = bbox.origin.x;\n            var bboxY = bbox.origin.y;\n\n            var box = new Box(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());\n\n            this.scale.reflow(box);\n            this._shrinkScaleWidth(box);\n\n            for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow();\n            }\n\n            this.bbox = this._getBox(box);\n            this._alignElements();\n            this._shrinkElements();\n            this._buildVisual();\n            this._draw();\n        },\n\n        _buildVisual: function() {\n            var visuals = new Group$1();\n            var scaleElements = this.scale.render();\n            var pointers = this.pointers;\n\n            visuals.append(this.gaugeArea);\n            visuals.append(scaleElements);\n\n            for (var i = 0; i < pointers.length; i++) {\n                var current = pointers[i];\n                visuals.append(current.render());\n                current.value(current.options.value);\n            }\n\n            this._visuals = visuals;\n        },\n\n        _createModel: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var scale = this.scale = new LinearScale(options.scale, this.contextService);\n\n            this.pointers = [];\n\n            var pointers = options.pointer;\n            pointers = isArray(pointers) ? pointers : [ pointers ];\n\n            for (var i = 0; i < pointers.length; i++) {\n                var currentOptions = deepExtend({}, pointers[i], {\n                    animation: {\n                        transitions: options.transitions\n                    }\n                });\n                var pointerType = currentOptions.shape === ARROW ? ArrowLinearPointer : BarLinearPointer;\n\n                this$1$1.pointers.push(new pointerType(scale, currentOptions));\n            }\n        },\n\n        _defaultSize: function() {\n            var vertical = this.options.scale.vertical;\n\n            return {\n                width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH,\n                height: vertical ? DEFAULT_HEIGHT : DEFAULT_MIN_HEIGHT\n            };\n        },\n\n        _getBox: function(box) {\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            var boxCenter = box.center();\n            var plotAreaBox = pointers[0].box.clone().wrap(scale.box);\n\n            for (var i = 0; i < pointers.length; i++) {\n                plotAreaBox.wrap(pointers[i].box.clone());\n            }\n\n            var size;\n            if (scale.options.vertical) {\n                size = plotAreaBox.width() / 2;\n                plotAreaBox = new Box(\n                    boxCenter.x - size, box.y1,\n                    boxCenter.x + size, box.y2\n                );\n            } else {\n                size = plotAreaBox.height() / 2;\n                plotAreaBox = new Box(\n                    box.x1, boxCenter.y - size,\n                    box.x2, boxCenter.y + size\n                );\n            }\n\n            return plotAreaBox;\n        },\n\n        _alignElements: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            var scaleBox = scale.box;\n            var box = pointers[0].box.clone().wrap(scale.box);\n            var plotAreaBox = this.bbox;\n\n            for (var i = 0; i < pointers.length; i++) {\n                box.wrap(pointers[i].box.clone());\n            }\n\n            var diff;\n            if (scale.options.vertical) {\n                diff = plotAreaBox.center().x - box.center().x;\n                scale.reflow(new Box(\n                    scaleBox.x1 + diff, plotAreaBox.y1,\n                    scaleBox.x2 + diff, plotAreaBox.y2\n                ));\n            } else {\n                diff = plotAreaBox.center().y - box.center().y;\n                scale.reflow(new Box(\n                    scaleBox.x1, scaleBox.y1 + diff,\n                    scaleBox.x2, scaleBox.y2 + diff\n                ));\n            }\n\n            for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n                pointers[i$1].reflow(this$1$1.bbox);\n            }\n        },\n\n        _shrinkScaleWidth: function(bbox) {\n            var ref = this;\n            var scale = ref.scale;\n            if (!scale.options.vertical) {\n                var overflow = scale.contentBox().width() - bbox.width();\n                if (overflow > 0) {\n                    scale.box.shrink(overflow, 0);\n                    scale.box.alignTo(bbox, 'center');\n                    scale.reflow(scale.box);\n                }\n            }\n        },\n\n        _shrinkElements: function() {\n            var this$1$1 = this;\n\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n            var scaleBox = scale.box.clone();\n            var pos = scale.options.vertical ? \"y\" : \"x\";\n            var pointerBox = pointers[0].box;\n\n            for (var i = 0; i < pointers.length; i++) {\n                pointerBox.wrap(pointers[i].box.clone());\n            }\n\n            scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);\n            scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);\n\n            scale.reflow(scaleBox);\n\n            for (var i$1 = 0; i$1 < pointers.length; i$1++) {\n                pointers[i$1].reflow(this$1$1.bbox);\n            }\n        }\n    });\n\n    setDefaultOptions(LinearGauge, {\n        transitions: true,\n        gaugeArea: {\n            background: \"\"\n        },\n        scale: {\n            vertical: true\n        }\n    });\n\n    var GEO_ARC_ADJUST_ANGLE = 180;\n\n    var Arc = drawing.Arc;\n    var Path$5 = DrawingPath;\n    var Group$5 = DrawingGroup;\n\n    function drawTicks(arc, tickAngles, unit, tickOptions) {\n        var ticks = new Group$5();\n        var center = arc.center;\n        var radius = arc.getRadiusX();\n\n        if (tickOptions.visible) {\n            for (var i = 0; i < tickAngles.length; i++) {\n                var tickStart = arc.pointAt(tickAngles[i]);\n                var tickEnd = new GeometryPoint(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n\n                ticks.append(new Path$5({\n                    stroke: {\n                        color: tickOptions.color,\n                        width: tickOptions.width\n                    }\n                }).moveTo(tickStart).lineTo(tickEnd));\n            }\n        }\n\n        return ticks;\n    }\n\n    function rangeSegment(from, to, color, opacity) {\n        return { from: from, to: to, color: color, opacity: opacity };\n    }\n\n    var RadialScale = NumericAxis.extend({\n        init: function(options, service) {\n            NumericAxis.fn.init.call(this, 0, 1, options, service);\n        },\n\n        initUserOptions: function(options) {\n            var scaleOptions = deepExtend({}, this.options, options);\n            scaleOptions.majorUnit = scaleOptions.majorUnit || dataviz.autoMajorUnit(scaleOptions.min, scaleOptions.max);\n            scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n\n            return scaleOptions;\n        },\n\n        initFields: function() {\n        },\n\n        render: function(center, radius) {\n            var arc = this.renderArc(center, radius);\n\n            this.bbox = arc.bbox();\n            this.labelElements = this.renderLabels();\n            this.ticks = this.renderTicks();\n            this.ranges = this.renderRanges();\n        },\n\n        reflow: function(bbox) {\n            var center = bbox.center();\n            var radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n            if (defined(this.bbox)) {\n                this.bbox = this.arc.bbox();\n                this.radius(this.arc.getRadiusX());\n                this.repositionRanges();\n                this.renderLabels();\n            } else {\n                return this.render(center, radius);\n            }\n        },\n\n        slotAngle: function(value) {\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var reverse = ref.reverse;\n            var startAngle = ref.startAngle;\n            var endAngle = ref.endAngle;\n            var angle = endAngle - startAngle;\n            var result;\n\n            if (reverse) {\n                result = endAngle - (value - min) / (max - min) * angle;\n            } else {\n                result = ((value - min) / (max - min) * angle) + startAngle;\n            }\n\n            return result + GEO_ARC_ADJUST_ANGLE;\n        },\n\n        hasRanges: function() {\n            var ranges = this.options.ranges;\n\n            return ranges && ranges.length;\n        },\n\n        ticksSize: function() {\n            var ref = this.options;\n            var majorTicks = ref.majorTicks;\n            var minorTicks = ref.minorTicks;\n            var size = 0;\n            if (majorTicks.visible) {\n                size = majorTicks.size;\n            }\n\n            if (minorTicks.visible) {\n                size = Math.max(minorTicks.size, size);\n            }\n\n            return size;\n        },\n\n        labelsCount: function() {\n            var count = NumericAxis.fn.labelsCount.call(this);\n            var options = this.options;\n            var angle = options.endAngle - options.startAngle;\n\n            if (angle >= 360 && (options.max % options.majorUnit === 0)) {\n                count -= 1;\n            }\n\n            return count;\n        },\n\n        renderLabels: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var arc = this.arc.clone();\n            var radius = arc.getRadiusX();\n            var tickAngles = this.tickAngles(arc, options.majorUnit);\n            var rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n            var labelsGroup = new Group$5();\n\n            var rangeDistance = radius * 0.05;\n            if (defined(options.rangeDistance)) {\n                rangeDistance = options.rangeDistance;\n            } else {\n                options.rangeDistance = rangeDistance;\n            }\n\n            var labelsOptions = options.labels;\n            var isInside = labelsOptions.position === INSIDE;\n            var hasLabelElements = defined(this.labelElements);\n\n            if (isInside) {\n                radius -= this.ticksSize();\n\n                if (this.hasRanges() && !hasLabelElements) {\n                    radius -= rangeSize + rangeDistance;\n                }\n                arc.setRadiusX(radius).setRadiusY(radius);\n            }\n\n            var labels = this.labels;\n            var count = labels.length;\n            var padding = getSpacing(labelsOptions.padding);\n            var paddingWidth = (padding.left + padding.right) / 2;\n            var paddingHeight = (padding.top + padding.bottom) / 2;\n\n            for (var i = 0; i < count; i++) {\n                var label = labels[i];\n                var halfWidth = label.box.width() / 2;\n                var halfHeight = label.box.height() / 2;\n                var angle = tickAngles[i];\n                var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n\n                var lp = arc.pointAt(angle);\n                var cx = lp.x + (Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1));\n                var cy = lp.y + (Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1));\n\n                label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n                var labelPos = new GeometryPoint(label.box.x1, label.box.y1);\n\n                var labelElement = (void 0);\n                if (!hasLabelElements) {\n                    labelElement = buildLabelElement(label, options.labels);\n                    labelsGroup.append(labelElement);\n                } else {\n                    labelElement = this$1$1.labelElements.children[i];\n                    var prevLabelPos = labelElement.bbox().origin;\n\n                    var labelTransform = labelElement.transform() || transform();\n                    labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                    labelElement.transform(labelTransform);\n                }\n\n                this$1$1.bbox = Rect.union(this$1$1.bbox, labelElement.bbox());\n            }\n\n            return labelsGroup;\n        },\n\n        repositionRanges: function() {\n            var ranges = this.ranges.children;\n\n            if (ranges.length > 0) {\n                var ref = this.options;\n                var rangeDistance = ref.rangeDistance;\n                var rangeSize = ref.rangeSize;\n                var rangeRadius = this.getRangeRadius();\n\n                if (this.options.labels.position === INSIDE) {\n                    rangeRadius += rangeSize + rangeDistance;\n                }\n\n                var newRadius = rangeRadius + (rangeSize / 2);\n\n                for (var i = 0; i < ranges.length; i++) {\n                    ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n                }\n\n                this.bbox = Rect.union(this.bbox, this.ranges.bbox());\n            }\n        },\n\n        renderRanges: function() {\n            var this$1$1 = this;\n\n            var segments = this.rangeSegments();\n            var segmentsCount = segments.length;\n            var result = new Group$5();\n\n            if (segmentsCount) {\n                var ref = this.options;\n                var rangeSize = ref.rangeSize;\n                var reverse = ref.reverse;\n                var rangeDistance = ref.rangeDistance;\n                var rangeRadius = this.getRangeRadius();\n\n                // move the ticks with a range distance and a range size\n                this.radius(this.radius() - rangeSize - rangeDistance);\n\n                for (var i = 0; i < segmentsCount; i++) {\n                    var segment = segments[i];\n                    var from = this$1$1.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                    var to = this$1$1.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                    if (to - from !== 0) {\n                        result.append(this$1$1.createRange(from, to, rangeRadius, segment));\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        createRange: function(startAngle, endAngle, rangeRadius, options) {\n            var rangeSize = this.options.rangeSize;\n            var rangeGeom = new geometry.Arc(this.arc.center, {\n                radiusX: rangeRadius + (rangeSize / 2),\n                radiusY: rangeRadius + (rangeSize / 2),\n                startAngle: startAngle,\n                endAngle: endAngle\n            });\n\n            return new Arc(rangeGeom, {\n                stroke: {\n                    width: rangeSize,\n                    color: options.color,\n                    opacity: options.opacity,\n                    lineCap: options.lineCap\n                }\n            });\n        },\n\n        rangeSegments: function() {\n            var options = this.options;\n            var ranges = options.ranges || [];\n            var count = ranges.length;\n            var segments = [];\n\n            if (count) {\n                var min = options.min;\n                var max = options.max;\n                var defaultColor = options.rangePlaceholderColor;\n                segments.push(rangeSegment(min, max, defaultColor));\n\n                for (var i = 0; i < count; i++) {\n                    var range = getRange(ranges[i], min, max);\n                    var segmentsCount = segments.length;\n\n                    for (var j = 0; j < segmentsCount; j++) {\n                        var segment = segments[j];\n\n                        if (segment.from <= range.from && range.from <= segment.to) {\n                            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                            if (segment.from <= range.to && range.to <= segment.to) {\n                                segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                            }\n\n                            segment.to = range.from;\n\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return segments;\n        },\n\n        getRangeRadius: function() {\n            var ref = this;\n            var arc = ref.arc;\n            var options = ref.options;\n            var rangeSize = options.rangeSize;\n            var rangeDistance = options.rangeDistance;\n            var majorTickSize = options.majorTicks.size;\n            var radius;\n\n            if (options.labels.position === OUTSIDE) {\n                radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n            } else {\n                radius = arc.getRadiusX() - rangeSize;\n            }\n\n            return radius;\n        },\n\n        renderArc: function(center, radius) {\n            var options = this.options;\n\n            var arc = this.arc = new geometry.Arc(center, {\n                radiusX: radius,\n                radiusY: radius,\n                startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n                endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n            });\n\n            return arc;\n        },\n\n        renderTicks: function() {\n            var ref = this;\n            var arc = ref.arc;\n            var options = ref.options;\n            var tickArc = arc.clone();\n\n            this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n            this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n\n            var allTicks = new Group$5();\n            allTicks.append(this.majorTicks);\n\n            var majorTickSize = options.majorTicks.size;\n            var minorTickSize = options.minorTicks.size;\n\n            this._tickDifference = majorTickSize - minorTickSize;\n\n            if (options.labels.position === OUTSIDE) {\n                var radius = tickArc.getRadiusX();\n                tickArc.setRadiusX(radius - majorTickSize + minorTickSize)\n                    .setRadiusY(radius - majorTickSize + minorTickSize);\n            }\n\n            this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n            this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n            allTicks.append(this.minorTicks);\n\n            return allTicks;\n        },\n\n        normalizeTickAngles: function(angles) {\n            var options = this.options;\n            var skip = options.majorUnit / options.minorUnit;\n\n            for (var i = angles.length - 1; i >= 0; i--) {\n                if (i % skip === 0) {\n                    angles.splice(i, 1);\n                }\n            }\n\n            return angles;\n        },\n\n        tickAngles: function(ring, stepValue) {\n            var options = this.options;\n            var reverse = options.reverse;\n            var range = options.max - options.min;\n            var angle = ring.endAngle - ring.startAngle;\n            var tickCount = range / stepValue;\n            var pos = ring.startAngle;\n            var step = angle / tickCount;\n\n            if (reverse) {\n                pos += angle;\n                step = -step;\n            }\n\n            if (angle >= 360 && (options.max % stepValue === 0)) {\n                tickCount -= 1;\n            }\n\n            var positions = [];\n            for (var i = 0; i < tickCount; i++) {\n                positions.push(round(pos, COORD_PRECISION));\n                pos += step;\n            }\n\n            if (round(pos) <= ring.endAngle) {\n                positions.push(pos);\n            }\n\n            return positions;\n        },\n\n        radius: function(value) {\n            if (value) {\n                this.arc.setRadiusX(value).setRadiusY(value);\n                this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n                this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n            } else {\n                return this.arc.getRadiusX();\n            }\n        },\n\n        repositionTicks: function(ticks, tickAngles, minor) {\n            var diff = minor ? (this._tickDifference || 0) : 0;\n            var tickArc = this.arc;\n            var radius = tickArc.getRadiusX();\n\n            if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n                tickArc = this.arc.clone();\n                tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n            }\n\n            for (var i = 0; i < ticks.length; i++) {\n                var newPoint = tickArc.pointAt(tickAngles[i]);\n                var segments = ticks[i].segments;\n                var xDiff = newPoint.x - segments[0].anchor().x;\n                var yDiff = newPoint.y - segments[0].anchor().y;\n\n                ticks[i].transform(new transform().translate(xDiff, yDiff));\n            }\n        }\n    });\n\n    setDefaultOptions(RadialScale, {\n        min: 0,\n        max: 100,\n\n        majorTicks: {\n            size: 15,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n        },\n\n        minorTicks: {\n            size: 10,\n            align: INSIDE,\n            color: BLACK,\n            width: DEFAULT_LINE_WIDTH,\n            visible: true\n        },\n\n        startAngle: -30,\n        endAngle: 210,\n\n        labels: {\n            position: INSIDE,\n            padding: 2\n        }\n    });\n\n    var RadialPointerAnimation = Animation.extend({\n        init: function(element, options) {\n            Animation.fn.init.call(this, element, options);\n\n            var animationOptions = this.options;\n\n            animationOptions.duration = Math.max((Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000, 1);\n        },\n\n        step: function(pos) {\n            var options = this.options;\n            var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n\n            this.element.transform(transform().rotate(angle, options.center));\n        }\n    });\n\n    setDefaultOptions(RadialPointerAnimation, {\n        easing: LINEAR,\n        duration: ANGULAR_SPEED\n    });\n\n    AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);\n\n    var CAP_SIZE = 0.05;\n    var Circle = drawing.Circle;\n    var Group$6 = DrawingGroup;\n    var Path$6 = DrawingPath;\n\n    var RadialPointer = Pointer.extend({\n        setAngle: function(angle) {\n            this.elements.transform(transform().rotate(angle, this.center));\n        },\n\n        repaint: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var oldAngle = scale.slotAngle(options._oldValue);\n            var newAngle = scale.slotAngle(options.value);\n\n            if (options.animation.transitions === false) {\n                this.setAngle(newAngle);\n            } else {\n                new RadialPointerAnimation(this.elements, deepExtend(options.animation, {\n                    oldAngle: oldAngle,\n                    newAngle: newAngle\n                })).play();\n            }\n        },\n\n        render: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var elements = new Group$6();\n\n            if (options.animation !== false) {\n                deepExtend(options.animation, {\n                    startAngle: 0,\n                    center: scale.arc.center,\n                    reverse: scale.options.reverse\n                });\n            }\n\n            elements.append(this._renderNeedle(), this._renderCap());\n\n            this.elements = elements;\n            this.setAngle(DEGREE);\n\n            return elements;\n        },\n\n        reflow: function(arc) {\n            var center = this.center = arc.center;\n            var length = limitValue(this.options.length || 1, 0.1, 1.5);\n            var radius = this.radius = arc.getRadiusX() * length;\n            var capSize = this.capSize = Math.round(radius * this.options.cap.size);\n\n            this.bbox = Rect.fromPoints(new GeometryPoint(center.x - capSize, center.y - capSize),\n                new GeometryPoint(center.x + capSize, center.y + capSize));\n        },\n\n        _renderNeedle: function() {\n            var minorTickSize = this.scale.options.minorTicks.size;\n            var center = this.center;\n            var needleColor = this.options.color;\n\n            var needlePath = new Path$6({\n                fill: { color: needleColor },\n                stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }\n            });\n\n            needlePath.moveTo(center.x + this.radius - minorTickSize, center.y)\n                .lineTo(center.x, center.y - (this.capSize / 2))\n                .lineTo(center.x, center.y + (this.capSize / 2))\n                .close();\n\n            return needlePath;\n        },\n\n        _renderCap: function() {\n            var options = this.options;\n            var capColor = options.cap.color || options.color;\n            var circle = new geometry.Circle(this.center, this.capSize);\n\n            var cap = new Circle(circle, {\n                fill: { color: capColor },\n                stroke: { color: capColor }\n            });\n\n            return cap;\n        }\n    });\n\n    setDefaultOptions(RadialPointer, {\n        cap: {\n            size: CAP_SIZE\n        },\n        arrow: {\n            width: 16,\n            height: 14\n        },\n        animation: {\n            type: RADIAL_POINTER,\n            duration: ANGULAR_SPEED\n        }\n    });\n\n    var Group$4 = DrawingGroup;\n\n    var RadialGauge = Gauge.extend({\n        reflow: function(bbox) {\n            var this$1$1 = this;\n\n            var pointers = this.pointers;\n            this.scale.reflow(bbox);\n            this._initialPlotArea = this.scale.bbox;\n\n            for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow(this$1$1.scale.arc);\n                this$1$1._initialPlotArea = Rect.union(this$1$1._initialPlotArea, pointers[i].bbox);\n            }\n\n            this.fitScale(bbox);\n            this.alignScale(bbox);\n            this._buildVisual(this.gaugeArea, pointers, this.scale);\n            this._draw();\n        },\n\n        _buildVisual: function(gaugeArea, pointers, scale) {\n            var visuals = this._visuals = new Group$4();\n\n            visuals.append(gaugeArea);\n            visuals.append(scale.ticks);\n            visuals.append(scale.ranges);\n            this._buildPointers(pointers);\n            visuals.append(scale.labelElements);\n        },\n\n        _buildPointers: function(pointers) {\n            var this$1$1 = this;\n\n            for (var i = 0; i < pointers.length; i++) {\n                var current = pointers[i];\n                current.render();\n                this$1$1._visuals.append(current.elements);\n\n                current.value(current.options.value);\n            }\n        },\n\n        fitScale: function(bbox) {\n            var this$1$1 = this;\n\n            var arc = this.scale.arc;\n            var plotAreaBox = this._initialPlotArea;\n            var step = Math.abs(this.getDiff(plotAreaBox, bbox));\n            var min = round(step, COORD_PRECISION);\n            var max = round(-step, COORD_PRECISION);\n            var minDiff, midDiff, maxDiff, mid, oldDiff;\n            var staleFlag = 0;\n            var i = 0;\n\n            while (i++ < 100) {\n                staleFlag = (oldDiff === maxDiff) ? (staleFlag + 1) : 0;\n\n                if (staleFlag > 5) {\n                    break;\n                }\n\n                if (min !== mid) {\n                    minDiff = this$1$1.getPlotBox(min, bbox, arc);\n                    if (0 <= minDiff && minDiff <= 2) {\n                        break;\n                    }\n                }\n\n                if (max !== mid) {\n                    maxDiff = this$1$1.getPlotBox(max, bbox, arc);\n                    if (0 <= maxDiff && maxDiff <= 2) {\n                        break;\n                    }\n                }\n\n                if (minDiff > 0 && maxDiff > 0) {\n                    mid = min * 2;\n                } else if (minDiff < 0 && maxDiff < 0) {\n                    mid = max * 2;\n                } else {\n                    mid = round(((min + max) / 2) || 1, COORD_PRECISION);\n                }\n\n                midDiff = this$1$1.getPlotBox(mid, bbox, arc);\n                if (0 <= midDiff && midDiff <= 2) {\n                    break;\n                }\n\n                oldDiff = maxDiff;\n\n                if (midDiff > 0) {\n                    max = mid;\n                    maxDiff = midDiff;\n                } else {\n                    min = mid;\n                    minDiff = midDiff;\n                }\n            }\n        },\n\n        getPlotBox: function(step, bbox, arc) {\n            var this$1$1 = this;\n\n            var scale = this.scale;\n            var pointers = this.pointers;\n            var radius = arc.getRadiusX();\n            var scaleArc = arc.clone();\n\n            scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);\n\n            scale.arc = scaleArc;\n            scale.reflow(bbox);\n            this.plotBbox = scale.bbox;\n\n            for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow(scaleArc);\n                this$1$1.plotBbox = Rect.union(this$1$1.plotBbox, pointers[i].bbox);\n            }\n\n            return this.getDiff(this.plotBbox, bbox);\n        },\n\n        getDiff: function(plotBox, box) {\n            return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());\n        },\n\n        alignScale: function(bbox) {\n            var this$1$1 = this;\n\n            var plotBoxCenter = this.plotBbox.center();\n            var boxCenter = bbox.center();\n            var paddingX = plotBoxCenter.x - boxCenter.x;\n            var paddingY = plotBoxCenter.y - boxCenter.y;\n            var ref = this;\n            var scale = ref.scale;\n            var pointers = ref.pointers;\n\n            scale.arc.center.x -= paddingX;\n            scale.arc.center.y -= paddingY;\n\n            scale.reflow(bbox);\n\n            for (var i = 0; i < pointers.length; i++) {\n                pointers[i].reflow(scale.arc);\n                this$1$1.plotBbox = Rect.union(scale.bbox, pointers[i].bbox);\n            }\n        },\n\n        _createModel: function() {\n            var this$1$1 = this;\n\n            var options = this.options;\n            var pointers = options.pointer;\n            var scale = this.scale = new RadialScale(options.scale, this.contextService);\n\n            this.pointers = [];\n\n            var pointersArr = isArray(pointers) ? pointers : [ pointers ];\n            for (var i = 0; i < pointersArr.length; i++) {\n                var current = new RadialPointer(scale, deepExtend({}, pointersArr[i], {\n                    animation: {\n                        transitions: options.transitions\n                    }\n                }));\n\n                this$1$1.pointers.push(current);\n            }\n        }\n    });\n\n    setDefaultOptions(RadialGauge, {\n        transitions: true,\n        gaugeArea: {\n            background: \"\"\n        }\n    });\n\n    var ArcScale = RadialScale.extend({\n        rangeSegments: function() {\n            var ref = this.options;\n            var min = ref.min;\n            var max = ref.max;\n            var rangePlaceholderColor = ref.rangePlaceholderColor;\n            var rangeLineCap = ref.rangeLineCap;\n\n            return [ { from: min, to: max, color: rangePlaceholderColor, lineCap: rangeLineCap } ];\n        },\n\n        hasRanges: function() {\n            return true;\n        },\n\n        placeholderRangeAngle: function(angle) {\n            var geometry$$1 = this.ranges.children[0].geometry();\n\n            if (this.options.reverse) {\n                geometry$$1.setEndAngle(angle);\n            } else {\n                geometry$$1.setStartAngle(angle);\n            }\n        },\n\n        addRange: function(from, to, options) {\n            var reverse = this.options.reverse;\n\n            var startAngle = this.slotAngle(reverse ? to : from);\n            var endAngle = this.slotAngle(reverse ? from : to);\n\n            var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);\n\n            this.ranges.append(range);\n\n            return range;\n        }\n    });\n\n    setDefaultOptions(ArcScale, {\n        min: 0,\n        max: 100,\n\n        majorTicks: {\n            visible: false\n        },\n\n        minorTicks: {\n            visible: false\n        },\n\n        labels: {\n            visible: false\n        },\n\n        startAngle: 0,\n        endAngle: 180,\n        rangeLineCap: 'round'\n    });\n\n    var MAX_DURATION = 800;\n\n    var RangePointerAnimation = Animation.extend({\n        init: function(element, options) {\n            Animation.fn.init.call(this, element, options);\n\n            var animationOptions = this.options;\n            var duration = (Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration) * 1000;\n            animationOptions.duration = limitValue(duration, ANGULAR_SPEED, MAX_DURATION);\n\n            var startColor = element.elements.options.get(\"stroke.color\");\n            var color = element.currentColor();\n            if (startColor !== color) {\n                this.startColor = new kendo.Color(startColor);\n                this.color = new kendo.Color(color);\n            }\n        },\n\n        step: function(pos) {\n            var ref = this;\n            var options = ref.options;\n            var startColor = ref.startColor;\n            var color = ref.color;\n            var angle = interpolateValue(options.oldAngle, options.newAngle, pos);\n            this.element.angle(angle);\n\n            if (color) {\n                var r = round(interpolateValue(startColor.r, color.r, pos));\n                var g = round(interpolateValue(startColor.g, color.g, pos));\n                var b = round(interpolateValue(startColor.b, color.b, pos));\n\n                this.element.stroke(new kendo.Color(r, g, b).toHex());\n            }\n        }\n    });\n\n    setDefaultOptions(RangePointerAnimation, {\n        easing: LINEAR,\n        duration: ANGULAR_SPEED\n    });\n\n    AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);\n\n    var RangePointer = Pointer.extend({\n        repaint: function() {\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n            var oldAngle = scale.slotAngle(options._oldValue);\n            var newAngle = scale.slotAngle(options.value);\n\n            if (this.animation) {\n                this.animation.abort();\n            }\n\n            if (options.animation.transitions === false) {\n                this.angle(newAngle);\n                this.stroke(this.currentColor());\n            } else {\n                this.animation = new RangePointerAnimation(this, deepExtend(options.animation, {\n                    oldAngle: oldAngle,\n                    newAngle: newAngle\n                }));\n\n                this.animation.play();\n            }\n        },\n\n        angle: function(value) {\n            var geometry$$1 = this.elements.geometry();\n            if (this.scale.options.reverse) {\n                geometry$$1.setStartAngle(value);\n            } else {\n                geometry$$1.setEndAngle(value);\n            }\n            this.scale.placeholderRangeAngle(value);\n        },\n\n        stroke: function(value) {\n            this.elements.stroke(value);\n        },\n\n        render: function() {\n            if (this.elements) {\n                return;\n            }\n\n            var ref = this;\n            var scale = ref.scale;\n            var options = ref.options;\n\n            if (options.animation !== false) {\n                deepExtend(options.animation, {\n                    startAngle: 0,\n                    center: scale.arc.center,\n                    reverse: scale.options.reverse\n                });\n            }\n\n            this.elements = scale.addRange(scale.options.min, this.options.value, {\n                color: this.currentColor(),\n                opacity: options.opacity,\n                lineCap: scale.options.rangeLineCap\n            });\n        },\n\n        currentColor: function() {\n            var ref = this.scale.options;\n            var min = ref.min;\n            var max = ref.max;\n            var ref$1 = this.options;\n            var colors = ref$1.colors;\n            var color = ref$1.color;\n            var value = ref$1.value;\n            var currentValue = dataviz.isNumber(value) ? value : min;\n\n            if (colors) {\n                for (var idx = 0; idx < colors.length; idx++) {\n                    var ref$2 = colors[idx];\n                    var rangeColor = ref$2.color;\n                    var from = ref$2.from; if (from === void 0) { from = min; }\n                    var to = ref$2.to; if (to === void 0) { to = max; }\n\n                    if (from <= currentValue && currentValue <= to) {\n                        return rangeColor;\n                    }\n                }\n            }\n\n            return color;\n        },\n\n        reflow: function() {\n            this.render();\n\n            this.bbox = this.elements.bbox();\n        }\n    });\n\n    setDefaultOptions(RangePointer, {\n        animation: {\n            type: RADIAL_RANGE_POINTER,\n            duration: ANGULAR_SPEED\n        }\n    });\n\n    var ArcGauge = RadialGauge.extend({\n        _initTheme: function(theme) {\n            RadialGauge.fn._initTheme.call(this, theme);\n\n            this.options.color = this.options.color || (this.theme.pointer || {}).color;\n        },\n\n        _createModel: function() {\n            var options = this.options;\n            var scale = this.scale = new ArcScale(options.scale, this.contextService);\n\n            var pointer = new RangePointer(scale, deepExtend({}, {\n                colors: options.colors,\n                color: options.color,\n                value: options.value,\n                opacity: options.opacity,\n                animation: {\n                    transitions: options.transitions\n                }\n            }));\n\n            this.pointers = [ pointer ];\n        },\n\n        _buildPointers: function(pointers) {\n            for (var i = 0; i < pointers.length; i++) {\n                var current = pointers[i];\n                current.render();\n\n                current.value(current.options.value);\n            }\n        },\n\n        _setValueOptions: function(value) {\n            this.options.value = value;\n        },\n\n        currentColor: function() {\n            var pointer = this.pointers[0];\n            if (pointer) {\n                return pointer.currentColor();\n            }\n        },\n\n        centerLabelPosition: function(width, height) {\n            var size = this.getSize();\n            var center = this.scale.arc.center;\n\n            var left = center.x - width / 2;\n            var top = center.y - height / 2;\n\n            if (width < size.width) {\n                var right = left + width;\n\n                left = Math.max(left, 0);\n\n                if (right > size.width) {\n                    left -= right - size.width;\n                }\n            }\n\n            if (height < size.height) {\n                var bbox = this.scale.bbox;\n                var yLimit = bbox.bottomRight().y;\n                var bottom = top + height;\n\n                top = Math.max(top, bbox.origin.y);\n\n                if (bottom > yLimit) {\n                    top -= bottom - yLimit;\n                }\n            }\n\n            return {\n                left: left,\n                top: top\n            };\n        }\n    });\n\n    var defaultStartAngle = 90;\n\n    var CircularGauge = ArcGauge.extend({\n        _createModel: function() {\n            var scaleOptions = this.options.scale;\n            if (typeof scaleOptions.startAngle !== 'number') {\n                scaleOptions.startAngle = defaultStartAngle;\n            }\n\n            scaleOptions.endAngle = scaleOptions.startAngle + 360;\n\n            ArcGauge.fn._createModel.call(this);\n        }\n    });\n\n    kendo.deepExtend(kendo.dataviz, {\n        Gauge: Gauge,\n        LinearGauge: LinearGauge,\n        LinearPointer: LinearPointer,\n        ArrowLinearPointer: ArrowLinearPointer,\n        BarLinearPointer: BarLinearPointer,\n        LinearScale: LinearScale,\n        RadialGauge: RadialGauge,\n        RadialPointer: RadialPointer,\n        RadialScale: RadialScale,\n        ArcGauge: ArcGauge,\n        RangePointer: RangePointer,\n        ArcScale: ArcScale,\n        CircularGauge: CircularGauge\n    });\n\n    })(window.kendo.jQuery);\n\n    (function($) {\n        var kendo = window.kendo;\n        var Widget = kendo.ui.Widget;\n        var dataviz = kendo.dataviz;\n        var LinearGauge = dataviz.LinearGauge;\n        var RadialGauge = dataviz.RadialGauge;\n        var ArcGauge = dataviz.ArcGauge;\n        var CircularGauge = dataviz.CircularGauge;\n        var draw = kendo.drawing;\n\n        function themeOptions(options) {\n            var themes = dataviz.ui.themes || {};\n            var themeName = options.theme || \"\";\n            var lowerName = themeName.toLowerCase();\n\n            if (dataviz.SASS_THEMES.indexOf(lowerName) != -1) {\n                return dataviz.autoTheme().gauge;\n            }\n\n            return (themes[themeName] || themes[lowerName] || {}).gauge;\n        }\n\n        var Gauge = Widget.extend({\n            init: function(element, userOptions) {\n                kendo.destroy(element);\n                $(element).empty();\n\n                Widget.fn.init.call(this, element);\n\n                this.options = kendo.deepExtend(this.options, userOptions);\n\n                this.wrapper = this.element;\n                this._createInstance();\n\n                this.element.addClass('k-gauge');\n\n                kendo.notify(this, dataviz.ui);\n            },\n\n            options: {\n                theme: \"sass\",\n                renderAs: \"\",\n                pointer: {},\n                scale: {},\n                gaugeArea: {\n                    background: \"\"\n                },\n                transitions: true\n            },\n\n            setOptions: function(options) {\n                this._instance.setOptions(options, themeOptions(options));\n\n                this._copyFields();\n            },\n\n            redraw: function() {\n                this._instance.redraw();\n                this._copyFields();\n            },\n\n            destroy: function() {\n                Widget.fn.destroy.call(this);\n                this._instance.destroy();\n            },\n\n            _createInstance: function() {\n                var gaugeType = this._gaugeType();\n                this._instance = new gaugeType(this.element[0], this.options, themeOptions(this.options));\n                this._copyFields();\n            },\n\n            _copyFields: function() {\n                this._originalOptions = this._instance._originalOptions;\n                this.options = this._instance.options;\n                this.surface = this._instance.surface;\n                this.bbox = this._instance.bbox;\n                this.gaugeArea = this._instance.gaugeArea;\n                this.pointers = this._instance.pointers;\n                this.scale = this._instance.scale;\n            },\n\n            _resize: function() {\n                this._instance.resize();\n            }\n        });\n\n        var proxyMembers = [\"getSize\", \"value\", \"allValues\", \"exportVisual\"];\n\n        function createProxyMember(name) {\n            Gauge.fn[name] = function() {\n                return this._instance[name].apply(this._instance, arguments);\n            };\n        }\n\n        for (var idx = 0; idx < proxyMembers.length; idx++) {\n            createProxyMember(proxyMembers[idx]);\n        }\n\n        dataviz.ExportMixin.extend(Gauge.fn);\n\n        var RadialGaugeWidget = Gauge.extend({\n\n            options: {\n                name: \"RadialGauge\"\n            },\n\n            _gaugeType: function() {\n                return RadialGauge;\n            }\n        });\n\n        var LinearGaugeWidget = Gauge.extend({\n\n            options: {\n                name: \"LinearGauge\",\n                scale: {\n                    vertical: true\n                }\n            },\n\n            _gaugeType: function() {\n                return LinearGauge;\n            }\n        });\n\n        var ArcGaugeWidget = Gauge.extend({\n            init: function(element, userOptions) {\n                Gauge.fn.init.call(this, element, userOptions);\n\n                this.element.css('position', 'relative');\n                this.element.addClass('k-arcgauge');\n\n                this._centerTemplate();\n            },\n\n            options: {\n                name: \"ArcGauge\"\n            },\n\n            setOptions: function(options) {\n                Gauge.fn.setOptions.call(this, options);\n                this._centerTemplate();\n            },\n\n            redraw: function() {\n                Gauge.fn.redraw.call(this);\n                this._centerTemplate();\n            },\n\n            value: function(value) {\n                var instance = this._instance;\n                if (arguments.length === 0) {\n                    return instance.value();\n                }\n\n                instance.value(value);\n\n                this._centerTemplate();\n            },\n\n            destroy: function() {\n                Gauge.fn.destroy.call(this);\n                delete this._centerElement;\n            },\n\n            exportVisual: function() {\n                if (this._centerElement) {\n                    return false;\n                }\n\n                return Gauge.fn.exportVisual.call(this);\n            },\n\n            _resize: function() {\n                this._instance.resize();\n\n                this._centerTemplate();\n            },\n\n            _centerTemplate: function() {\n                if (this.options.centerTemplate) {\n                    var template = kendo.template(this.options.centerTemplate);\n\n                    var instance = this._instance;\n                    var centerElement = this._getCenterElement();\n\n                    centerElement.html(template({ color: instance.currentColor(), value: instance.value() }));\n\n                    var position = instance.centerLabelPosition(centerElement.width(), centerElement.height());\n\n                    centerElement.css(position);\n                } else if (this._centerElement) {\n                    this._centerElement.remove();\n                    this._centerElement = null;\n                }\n            },\n\n            _getCenterElement: function() {\n                var centerElement = this._centerElement;\n                if (!centerElement) {\n                    centerElement = this._centerElement = $('<div></div>').addClass('k-arcgauge-label');\n                    this.element.append(centerElement);\n                }\n\n                return centerElement;\n            },\n\n            _gaugeType: function() {\n                return ArcGauge;\n            }\n        });\n\n        var CircularGaugeWidget = ArcGaugeWidget.extend({\n            options: {\n                name: \"CircularGauge\"\n            },\n\n            _gaugeType: function() {\n                return CircularGauge;\n            }\n        });\n\n        function createExportMethod(name) {\n            ArcGaugeWidget.fn[name] = function(options) {\n                var gauge = this;\n                var method = draw[name];\n\n                if (!gauge._centerElement) {\n                    return method(gauge.exportVisual(), options);\n                }\n\n                return draw.drawDOM(gauge.element).then(function(visual) {\n                    return method(visual, options);\n                });\n            };\n        }\n\n        var exportMethods = ['exportSVG', 'exportImage', 'exportPDF'];\n\n        for (idx = 0; idx < exportMethods.length; idx++) {\n            createExportMethod(exportMethods[idx]);\n        }\n\n        dataviz.ui.plugin(LinearGaugeWidget);\n        dataviz.ui.plugin(RadialGaugeWidget);\n        dataviz.ui.plugin(ArcGaugeWidget);\n        dataviz.ui.plugin(CircularGaugeWidget);\n\n        kendo.deepExtend(dataviz, {\n            Gauge: Gauge,\n            LinearGauge: LinearGaugeWidget,\n            RadialGauge: RadialGaugeWidget,\n            ArcGauge: ArcGaugeWidget,\n            CircularGauge: CircularGaugeWidget\n        });\n\n    })(window.kendo.jQuery);\n\n    var __meta__ = {\n        id: \"dataviz.gauge\",\n        name: \"Gauge\",\n        category: \"dataviz\",\n        description: \"Linear, Radial and Arc gauges.\",\n        depends: [ \"dataviz.core\", \"dataviz.themes\" ]\n    };\n\n    var kendo$1 = kendo;\n\n    return kendo$1;\n\n}));\n"]}