{"version":3,"sources":["raw-js/kendo.dockmanager.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendodockmanager","js","this","$","undefined$1","kendo","window","Widget","ui","NS","extend","percentageUnitsRegex","DOCK_MANAGER_TOOLBAR","isPlainObject","TOOLBAR_TEMPLATE","KSTATIC_PANE","KPANE_TABBED","SPLITTER","KSPLITBAR","PANE_SIZING_PROP","HORIZONTAL","VERTICAL","KHIDDEN","KBUTTON","MAX_NUMBER_VALUE","Number","MAX_SAFE_INTEGER","KPANE","KPANES_CONTAINER","KPANE_ACTIONS","KDOCK_INDICATOR","KDOCK_NAVIGATOR","KDOCK_PREVIEW","KSELECTED","KACTIVE","KTABSTRIP","KSPLITBAR_DRAGGABLE","SPLIT","TAB","HEIGHT","WIDTH","TOP","BOTTOM","LEFT","RIGHT","MIDDLE","CLICK","PIN","UNPIN","UNSHIFT","PANE","paneSelector","uid","attr","unpinnedResizeSplitbar","UID_ATTR","INDICATOR_ATTR","ACTION_ATTR","INDICATOR_TEMPLATE","NAVIGATOR_TEMPLATE","CLOSE","DOCK","INNER_DOCK","RESIZE","DRAG","DRAGSTART","DRAGEND","isPercentageSize","size","test","DockSplitter","init","element","options","that","fn","call","_marker","guid","substring","addClass","orientation","_initPanes","_initResizable","notify","panes","events","paneElements","children","panesCount","length","sizedPanes","i","paneElement","eq","pane","css","collapsed","splitter","insertAfter","push","pop","markerAttribute","_resizable","Resizable","handle","clickMoveClick","invalidClass","resizeend","find","remove","resize","e","delta","splitterBarIndex","_getElementIndex","currentTarget","splitterBar","rtlModifier","support","isRtl","x","y","leftPane","rightPane","_dragSplitterBar","trigger","start","_onResizeStart","bind","_getAdjacentPanes","leftPaneNewSize","computedSize","isLeftPaneSizeInBounds","min","max","panesWithoutSize","_getPaneElements","filter","style","canResizeBothPanes","_resizePane","leftPaneIndex","rightPaneIndex","leftPaneELement","_getPaneElement","rightPaneELement","_getPane","leftPaneSize","_getPaneOffsetSize","rightPaneSize","totalPaneSize","splitterSize","_getElementClientSize","getPixelSize","paneSize","_calculatePixelSize","leftPaneMaxSize","rightPaneMaxSize","_getAdjacentPanesMaxSize","rightMaxPixelSize","leftMaxPixelSize","index","collapsible","constrainedSize","value","Math","newSize","toPercentages","parseFloat","toPixel","_setPaneSize","_allExpandedPanesHaveSize","expandedPanes","paneIndex","_getPaneSizes","containerSize","numericSize","_getElementOffsetSize","rect","getBoundingClientRect","width","height","_getElementSize","sizeType","_getPaneIndex","indexOf","leftPaneMinSize","leftPaneMaxPixelSize","rightPaneMinSize","rightPaneMaxPixelSize","stopPropagation","_addResizeOverlays","_addResizeOverlay","overlay","append","Array","from","hasClass","childrenSelector","parent","matches","destroy","off","empty","DockManager","panesContainer","appendTo","_processPanes","rootPane","_refreshToolbar","_createPane","_bindEvents","_initNavigator","_initUnpinnedResizable","name","type","paneDefaults","visible","closeable","actions","icon","shouldAdd","unpinnable","unpinned","minimizable","maximizable","indicators","top","left","transform","previewTop","previewLeft","rotate","hoveredPaneHeight","draggedPaneHeight","hoveredPaneWidth","draggedPaneWidth","togglePane","id","_getPaneById","_togglePane","removePane","_removePane","getOptions","setOptions","currentOptions","deepExtend","_unpinnedResizable","unpinnedContainer","containerWidth","on","_toolbarButtonClick","_hideUnpinnedPanes","_pinPaneClick","_closePane","_displayDockPreview","_hideDockPreview","currentlyOpened","unpinnedContainerVisible","is","_toolbar","removeClass","itemUid","preventDefault","_showUnpinnedPane","paneUid","toolbarWidth","outerWidth","_findPaneByUid","hasUnpinnedSize","unpinnedSize","button","isTabbed","action","closest","isUnpinned","parentPane","parentUid","eventData","_refreshRootPane","toggleClass","event","splice","_shouldHideParent","some","_refreshPane","parentElement","_extendPane","forEach","childPane","j","subItem","unpinnedPanes","_unpinnedPanes","unpinnedPannesContainer","insertBefore","prepend","html","renderButton","fillMode","_paneHeader","wrapper","refresh","rootPaneElement","_createSplitPane","splitterElement","splitterOptions","paneOptions","_createUnpinnedPane","_updatePaneSize","ev","_createTabPane","tabStripElement","tabContainer","selectedPane","selected","tab","title","contentElement","_addActions","kendoTabStrip","animation","_createContentPane","content","template","data","isUnnpinned","actionsContainer","string","charAt","toUpperCase","slice","result","concat","header","tabHeader","found","prop","params","navigatorDraggable","Draggable","autoScroll","hint","actionsHtml","_getActionButtons","hintTemplate","dragstart","_dragStart","dragend","_dragEnd","drag","_drag","target","draggedPane","_displayGlobalIndicators","draggableEvent","hoveredIndicator","hide","_updateLayout","_showHiddenPanes","hoveredPane","currentPane","elementUnderCursor","navigator","currentPaneUid","prevPaneUid","position","dockable","innerDock","_showTab","_showPane","tabstrip","show","activateTab","splitbar","siblings","_hideDraggedPane","draggedElement","_hideTab","_hidePane","prevElement","prev","nextElement","next","isActive","buttons","container","each","_","clone","indicator","isGlobalIndicator","indicatorName","indicatorUid","indicatorData","previewElement","containerHeight","outerHeight","existingPreview","preview","location","draggedPaneParent","draggedPaneIndex","_tabDock","_splitDock","_adjustSiblingSizes","targetPane","isGlobalDock","targetPaneParent","targetPaneIndex","dimension","newParentPane","unshift","_getSiblings","parentSize","draggedPaneSize","newParentSize","noSizePanes","freeSpace","_calculateNewSize","noSizePane","proportion","noUnitSize","unit","replace","p","plugin","jQuery"],"mappings":"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","file":"kendo.dockmanager.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('kendo.core.js'), require('kendo.splitter.js'), require('kendo.tabstrip.js'), require('kendo.window.js'), require('kendo.html.button.js'), require('kendo.resizable.js'), require('kendo.draganddrop.js')) :\n    typeof define === 'function' && define.amd ? define(['kendo.core', 'kendo.splitter', 'kendo.tabstrip', 'kendo.window', 'kendo.html.button', 'kendo.resizable', 'kendo.draganddrop'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.kendodockmanager = global.kendodockmanager || {}, global.kendodockmanager.js = factory()));\n})(this, (function () {\n    const __meta__ = {\n        id: \"dockManager\",\n        name: \"DockManager\",\n        category: \"web\",\n        description: \"The DockManager widget represents a layout component that allows users to achieve custom layouts by docking panes.\",\n        depends: [\"core\", \"splitter\", \"tabstrip\", \"window\", \"html.button\"]\n    };\n\n    (function($, undefined$1) {\n        const kendo = window.kendo,\n            Widget = kendo.ui.Widget,\n            NS = \".kendoDockManager\",\n            ui = kendo.ui,\n            extend = $.extend,\n            pxUnitsRegex = /^\\d+(\\.\\d+)?px$/i,\n            percentageUnitsRegex = /^\\d+(\\.\\d+)?%$/i,\n            isPlainObject = $.isPlainObject,\n            DOCK_MANAGER = \"k-dock-manager\",\n            DOCK_MANAGER_TOOLBAR = \"k-dock-manager-toolbar\",\n            TOOLBAR_TEMPLATE = `<div class=\"${DOCK_MANAGER_TOOLBAR} k-toolbar-left k-toolbar k-toolbar-md\"></div>`,\n            TOOLBAR_BUTTON = \"k-toolbar-button\",\n            SEPARATOR = `<div class=\"k-separator k-separator-horizontal\"></div>`,\n            KSTATIC_PANE = \"k-pane-static\",\n            KKPINNED_PANE = \"k-pane-pinned\",\n            KPANE_TABBED = \"k-pane-tabbed\",\n            SPLITTER = \"k-splitter\",\n            KSPLITBAR = \"k-splitbar\",\n            SPLITTER_FLEX = \"k-splitter-flex\",\n            DOCK_SPLITTER = \"k-dock-manager-splitter\",\n            KUNPINNED_CONTAINER = \"k-dock-manager-unpinned-container\",\n            PANE_SIZING_PROP = \"flex-basis\",\n            HORIZONTAL = \"horizontal\",\n            VERTICAL = \"vertical\",\n            KHIDDEN = \"k-hidden\",\n            KBUTTON = \"k-button\",\n            MAX_NUMBER_VALUE = Number.MAX_SAFE_INTEGER,\n            KPANE = \"k-pane\",\n            KPANE_FLEX = \"k-pane-flex\",\n            KPANES_CONTAINER = \"k-dock-manager-pane-container\",\n            KPANE_SCROLLABLE = \"k-pane-scrollable\",\n            KPANE_ACTIONS = \"k-pane-actions\",\n            KDOCK_INDICATOR = \"k-dock-indicator\",\n            KDOCK_NAVIGATOR = \"k-dock-navigator\",\n            KDOCK_PREVIEW = \"k-docking-preview\",\n            KSELECTED = \"k-selected\",\n            KACTIVE = \"k-active\",\n            KTABSTRIP = \"k-tabstrip\",\n            KSPLITBAR_DRAGGABLE = \"k-splitbar-draggable\",\n            SPLIT = \"split\",\n            TAB = \"tab\",\n            CONTENT = \"content\",\n            HEIGHT = \"height\",\n            WIDTH = \"width\",\n            TOP = \"top\",\n            BOTTOM = \"bottom\",\n            LEFT = \"left\",\n            RIGHT = \"right\",\n            MIDDLE = \"middle\",\n            CLICK = \"click\",\n            PIN = \"pin\",\n            UNPIN = \"unpin\",\n            UNSHIFT = \"unshift\",\n            PUSH = \"push\",\n            PANE = `<div class=\"${KPANE} ${KPANE_FLEX} ${KSTATIC_PANE}\"></div>`,\n            paneSelector = uid => `.${KPANE}[${kendo.attr(\"uid\")}=\"${uid}\"]`,\n            buttonTextTemplate = text => `<span class=\"k-button-text\">${text}</span>`,\n            contentPaneTemplate = data => `<div class=\"${KPANE_SCROLLABLE}\">\n                                            <div class=\"k-pane-header\">\n                                                <span class=\"k-pane-title\">${data.title}</span>\n                                                <div class=\"${KPANE_ACTIONS}\"></div>\n                                            </div>\n                                            <div class=\"k-pane-content\">${data.content}</div>\n                                        </div>`,\n            tabTemplate = title => `<li><span class=\"k-link\">${title}</span></li>`,\n            unpinnedResizeSplitbar = `<div class=\"k-splitbar k-splitbar-horizontal ${KSPLITBAR_DRAGGABLE}-horizontal\">\n                                    <div class=\"k-resize-handle\"></div>\n                                </div>`,\n            UID_ATTR = kendo.attr(\"uid\"),\n            INDICATOR_ATTR = kendo.attr(\"indicator\"),\n            ACTION_ATTR = kendo.attr(\"action\"),\n            hintTemplate = pane => `<div class=\"k-tooltip k-tooltip-primary\">\n                                    <div class=\"k-tooltip-content\">${pane.title}</div>\n                                </div>`,\n            INDICATOR_TEMPLATE = `<div class=\"${KDOCK_INDICATOR}\">\n                        <span class=\"k-svg-icon k-icon-xl k-svg-i-position-top\">\n                        <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                            <path d=\"M480 448V32H32v448h448v-32zm-416 0V64h384v384H64zM96 96h320v96H96z\"></path>\n                        </svg>\n                        </span>\n                    </div>`,\n            NAVIGATOR_TEMPLATE = `<div class=\"${KDOCK_NAVIGATOR}\" style=\"position: relative;\">\n                                <div class=\"k-dock-indicator k-dock-indicator-top\" ${INDICATOR_ATTR}=\"top\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-top\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M480 448V32H32v448h448v-32zm-416 0V64h384v384H64zM96 96h320v96H96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-right\" ${INDICATOR_ATTR}=\"right\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-right\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M64 480h416V32H32v448h32zm0-416h384v384H64V64zm256 32h96v320h-96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-bottom\" ${INDICATOR_ATTR}=\"bottom\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-bottom\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M32 64v416h448V32H32v32zm416 0v384H64V64h384zM96 320h320v96H96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-left\" ${INDICATOR_ATTR}=\"left\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-position-left\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M448 32H32v448h448V32h-32zm0 416H64V64h384v384zM96 96h96v320H96z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                                <div class=\"k-dock-indicator k-dock-indicator-middle\" ${INDICATOR_ATTR}=\"middle\">\n                                <span class=\"k-svg-icon k-icon-xl k-svg-i-window\">\n                                    <svg aria-hidden=\"true\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n                                        <path d=\"M96 96v320h320V96H96zm288 288H128V192h256v192z\"></path>\n                                    </svg>\n                                </span>\n                                </div>\n                            </div>`,\n            SPLITBAR = (splitter) => $(`<div class=\"${KSPLITBAR} ${KSPLITBAR}-${splitter.options.orientation} ${KSPLITBAR_DRAGGABLE}-${splitter.options.orientation}\" ${kendo.attr(\"marker\")}=\"${splitter._marker}\" >\n                        <div class=\"k-resize-handle\"></div>\n                    </div>`),\n            CLOSE = \"close\",\n            DOCK = \"dock\",\n            INNER_DOCK = \"innerDock\",\n            RESIZE = \"resize\",\n            DRAG = \"drag\",\n            DRAGSTART = \"dragStart\",\n            DRAGEND = \"dragEnd\",\n            CHANGE = \"change\";\n\n        function capitalizeFirstLetter(string) {\n            return string.charAt(0).toUpperCase() + string.slice(1);\n        }\n\n        function isPercentageSize(size) {\n            return percentageUnitsRegex.test(size);\n        }\n\n        function isPixelSize(size) {\n            return pxUnitsRegex.test(size) || /^\\d+$/.test(size);\n        }\n\n        function isFluid(size) {\n            return !isPercentageSize(size) && !isPixelSize(size);\n        }\n\n        function calculateSize(size, total) {\n            let output = parseInt(size, 10);\n\n            if (isPercentageSize(size)) {\n                output = Math.floor(output * total / 100);\n            }\n\n            return output;\n        }\n\n        function toPercentages(value) {\n            return `${value}%`;\n        }\n\n        function toPixel(value ) {\n            return kendo.parseFloat(value) + \"px\";\n        }\n\n        function percentage(partialValue, totalValue) {\n            return (100 * partialValue) / totalValue;\n        }\n\n        function clamp(value, min, max) {\n            return Math.min(max, Math.max(min, value));\n        }\n\n        const DockSplitter = Widget.extend({\n            init: function(element, options) {\n                const that = this;\n\n                Widget.fn.init.call(that, element, options);\n                options = $.extend(true, {}, options);\n                that._marker = kendo.guid().substring(0, 8);\n                that.element.addClass(`${SPLITTER} ${SPLITTER_FLEX} ${SPLITTER}-${options.orientation} ${DOCK_SPLITTER}`);\n                that._initPanes();\n                that._initResizable();\n                kendo.notify(that);\n            },\n\n            options: {\n                orientation: \"horizontal\",\n                panes: []\n            },\n\n            events: [\n                RESIZE\n            ],\n\n            _initPanes: function() {\n                const that = this;\n                const paneElements = that.element.children();\n                const panesCount = paneElements.length;\n                const orientation = that.options.orientation;\n                const markerAttribute = kendo.attr(\"marker\");\n                const sizedPanes = [];\n\n                for (let i = 0; i < panesCount; i++) {\n                    const paneElement = paneElements.eq(i);\n                    let pane = that.options.panes[i];\n\n                    if (!pane) {\n                        pane = that.options.panes[i] = {};\n                    }\n\n                    pane.size = pane.size || \"auto\";\n                    paneElement.attr(kendo.attr(\"uid\"), pane.uid)\n                                .attr(\"role\", \"group\")\n                                .css(\"flex-basis\", pane.size)\n                                .addClass();\n\n                    if (pane.collapsed) {\n                        pane.css(\"display\", \"none\");\n                    }\n\n                    if (i < panesCount - 1 && !that.options.panes[i + 1].collapsed) {\n                        let splitbar = SPLITBAR(that);\n\n                        splitbar.insertAfter(paneElement);\n                    }\n\n                    if (pane.size) {\n                        sizedPanes.push(paneElement);\n                    }\n                }\n\n                if (sizedPanes.length === 1 && panesCount > 1) {\n                    sizedPanes.pop().addClass(KSTATIC_PANE);\n                }\n            },\n\n            _initResizable: function() {\n                const that = this;\n                const orientation = that.options.orientation;\n                const markerAttribute = kendo.attr(\"marker\");\n\n                that._resizable = new kendo.ui.Resizable(that.element, {\n                    orientation: orientation,\n                    handle: `[${markerAttribute}=${that._marker}].${KSPLITBAR_DRAGGABLE}-${orientation} `,\n                    clickMoveClick: that.options.clickMoveClick,\n                    invalidClass: \"k-restricted-size-\" + orientation,\n                    resizeend: function() {\n                        that.element.find(\".k-splitter-overlay\").remove();\n                    },\n                    resize: function(e) {\n                        const axis = orientation === HORIZONTAL ? 'x' : 'y';\n                        let delta;\n                        const splitterBarIndex = that._getElementIndex(e.currentTarget, `.${KSPLITBAR}`);\n                        const splitterBar = e.currentTarget;\n\n                        if (orientation === HORIZONTAL) {\n                            const rtlModifier = kendo.support.isRtl(that.element) ? -1 : 1;\n                            delta = e.x.delta * rtlModifier;\n                        } else {\n                            delta = e.y.delta;\n                        }\n\n                        const { leftPane, rightPane } = that._dragSplitterBar(splitterBar, splitterBarIndex, delta);\n                        that.trigger(RESIZE, { leftPane: leftPane, rightPane: rightPane });\n                    },\n                    start: that._onResizeStart.bind(that)\n                });\n\n            },\n\n            _dragSplitterBar: function(splitterBar, splitterBarIndex, delta) {\n                const that = this;\n                const { leftPane, rightPane } = that._getAdjacentPanes(splitterBar, splitterBarIndex);\n\n                const leftPaneNewSize = leftPane.computedSize + delta;\n                const isLeftPaneSizeInBounds = leftPaneNewSize > leftPane.min && leftPaneNewSize < leftPane.max;\n\n                const panesWithoutSize = that._getPaneElements().filter(x => !x.style[PANE_SIZING_PROP]);\n                const canResizeBothPanes = (leftPane.size || rightPane.size) && panesWithoutSize.length > 1;\n\n                if ((leftPane.size && rightPane.size) || canResizeBothPanes) {\n                    if (isLeftPaneSizeInBounds) {\n                        that._resizePane(leftPane, delta);\n                        that._resizePane(rightPane, -delta);\n                    }\n                } else if (rightPane.size) {\n                    that._resizePane(rightPane, -delta);\n                } else {\n                    that._resizePane(leftPane, delta);\n                }\n                return { leftPane, rightPane };\n            },\n\n            _getAdjacentPanes: function(splitterBar, splitterBarIndex) {\n                const that = this;\n                const leftPaneIndex = splitterBarIndex;\n                const rightPaneIndex = splitterBarIndex + 1;\n\n                const leftPaneELement = that._getPaneElement(leftPaneIndex);\n                const rightPaneELement = that._getPaneElement(rightPaneIndex);\n\n                const leftPane = that._getPane(leftPaneIndex);\n                const rightPane = that._getPane(rightPaneIndex);\n\n                const leftPaneSize = that._getPaneOffsetSize(leftPaneIndex);\n                const rightPaneSize = that._getPaneOffsetSize(rightPaneIndex);\n\n                const totalPaneSize = leftPaneSize + rightPaneSize;\n                const splitterSize = that._getElementClientSize(that.element, that.options.orientation);\n                const getPixelSize = paneSize => that._calculatePixelSize(paneSize, splitterSize);\n\n                const { leftPaneMaxSize, rightPaneMaxSize } = that._getAdjacentPanesMaxSize(leftPaneIndex, rightPaneIndex);\n                const rightMaxPixelSize = getPixelSize(rightPane && rightPane.max);\n                const leftMaxPixelSize = getPixelSize(leftPane && leftPane.max);\n\n                return {\n                    leftPane: {\n                        index: leftPaneIndex,\n                        computedSize: leftPaneSize,\n                        min: getPixelSize(leftPane && leftPane.min) || ( rightMaxPixelSize ? totalPaneSize - rightMaxPixelSize : 0 ) || 0,\n                        max: leftPaneMaxSize,\n                        size: leftPaneELement.style[PANE_SIZING_PROP],\n                        collapsible: leftPane && leftPane.collapsible,\n                        uid: leftPane.uid\n                    },\n                    rightPane: {\n                        index: rightPaneIndex,\n                        computedSize: rightPaneSize,\n                        min: getPixelSize(rightPane && rightPane.min) || (leftMaxPixelSize ? totalPaneSize - leftMaxPixelSize : 0) || 0,\n                        max: rightPaneMaxSize,\n                        size: rightPaneELement.style[PANE_SIZING_PROP],\n                        collapsible: rightPane && rightPane.collapsible,\n                        uid: rightPane.uid\n                    }\n                };\n            },\n\n            _resizePane: function(pane, delta) {\n                const that = this;\n                const constrainedSize = clamp(pane.computedSize + delta, pane.min, pane.max);\n                let newSize = \"\";\n\n                if (isPercentageSize(pane.size)) {\n                    const splitterSize = that._getElementClientSize(that.element, that.options.orientation);\n                    newSize = toPercentages(100 * constrainedSize / splitterSize);\n                } else {\n                    newSize = toPixel(constrainedSize);\n                }\n                pane.size = newSize;\n                that._setPaneSize(pane.index, newSize);\n            },\n\n            _allExpandedPanesHaveSize: function() {\n                const that = this;\n                const expandedPanes = that.options.panes.filter(x=> !x.collapsed);\n\n                if (expandedPanes.length) {\n                    return expandedPanes.filter(x=> x.size).length;\n                }\n\n                return false;\n            },\n\n            _setPaneSize: function(paneIndex, size) {\n                const that = this;\n                const paneElement = that._getPaneElement(paneIndex);\n\n                if (!paneElement) {\n                    return;\n                }\n\n                if (!that._allExpandedPanesHaveSize()) {\n                    $(paneElement).addClass(KSTATIC_PANE);\n                }\n\n                paneElement.style[PANE_SIZING_PROP] = size;\n            },\n\n            _getPaneSizes: function(paneIndex) {\n                const that = this;\n                const splitterSize = that._getElementClientSize(that.element, that.options.orientation);\n                const pane = that._getPane(paneIndex);\n                const paneSize = that._getPaneOffsetSize(paneIndex);\n                const paneMinSize = pane && pane.min ? that._calculatePixelSize(pane.min, splitterSize) : 0;\n                const paneMaxSize = pane && pane.max ? that._calculatePixelSize(pane.max, splitterSize) : MAX_NUMBER_VALUE;\n\n                return {\n                    size: paneSize,\n                    min: paneMinSize,\n                    max: paneMaxSize\n                };\n            },\n\n            _calculatePixelSize: function(size, containerSize) {\n                let numericSize = kendo.parseFloat(size);\n\n                if (isPercentageSize(size)) {\n                    numericSize = (containerSize * numericSize / 100);\n                }\n\n                return numericSize;\n            },\n\n            _getPaneOffsetSize: function(paneIndex) {\n                const that = this;\n                const paneElement = that._getPaneElement(paneIndex);\n                const size = that._getElementOffsetSize(paneElement, that.options.orientation);\n                return size;\n            },\n\n\n            _getElementOffsetSize: function(element, orientation) {\n                if (!element) {\n                    return 0;\n                }\n\n                const rect = element.getBoundingClientRect();\n\n                if (orientation === HORIZONTAL) {\n                    return rect.width;\n                } else {\n                    return rect.height;\n                }\n            },\n\n            _getElementClientSize: function(element, orientation) {\n                const that = this;\n\n                return that._getElementSize(element, orientation, \"client\");\n            },\n\n            _getElementSize: function(element, orientation, sizeType) {\n                if (!element) {\n                    return 0;\n                }\n\n                element = element[0];\n\n                if (orientation === HORIZONTAL) {\n                    return element[`${sizeType}Width`];\n                } else {\n                    return element[`${sizeType}Height`];\n                }\n            },\n\n            _getPane: function(paneIndex) {\n                const that = this;\n\n                return (that.options.panes || [])[paneIndex];\n            },\n\n            _getPaneIndex: function(pane) {\n                const that = this;\n\n                return that.options.panes.indexOf(pane);\n            },\n\n            _getAdjacentPanesMaxSize: function(leftPaneIndex, rightPaneIndex) {\n                const that = this;\n                const {\n                    size: leftPaneSize,\n                    min: leftPaneMinSize,\n                    max: leftPaneMaxPixelSize\n                } = that._getPaneSizes(leftPaneIndex);\n\n                const {\n                    size: rightPaneSize,\n                    min: rightPaneMinSize,\n                    max: rightPaneMaxPixelSize\n                } = that._getPaneSizes(rightPaneIndex);\n\n                const totalPaneSize = leftPaneSize + rightPaneSize;\n\n                const leftPaneMaxSize = Math.min(leftPaneMaxPixelSize, totalPaneSize - rightPaneMinSize);\n                const rightPaneMaxSize = Math.min(rightPaneMaxPixelSize, totalPaneSize - leftPaneMinSize);\n\n                return {\n                    leftPaneMaxSize,\n                    rightPaneMaxSize\n                };\n            },\n\n            _onResizeStart: function(e) {\n                const that = this;\n\n                e.stopPropagation();\n\n                const splitterBarIndex = that._getElementIndex(e.currentTarget, `.${SPLITTER}`);\n\n                that._addResizeOverlays(splitterBarIndex);\n            },\n\n            _addResizeOverlays: function(splitterBarIndex) {\n                const that = this;\n\n                that._addResizeOverlay(splitterBarIndex);\n                that._addResizeOverlay(splitterBarIndex + 1);\n            },\n\n            _addResizeOverlay: function(paneIndex) {\n                const that = this;\n                const paneElement = that._getPaneElement(paneIndex);\n\n                if (!paneElement) {\n                    return;\n                }\n\n                const overlay = $(`<div class=\"k-splitter-overlay k-overlay\"></div>`);\n\n                $(paneElement).append(overlay);\n            },\n\n\n            _getPaneElement: function(paneIndex) {\n                const that = this;\n                const panes = that._getPaneElements();\n                return panes[paneIndex];\n            },\n\n            _getPaneElements: function() {\n                const that = this;\n                const panes = Array.from(that.element.children() || []).filter(x => $(x).hasClass(\"k-pane\") || $(x).hasClass(\"k-splitter\"));\n                return panes;\n            },\n\n            _getElementIndex: function(element, childrenSelector) {\n                if (!element) {\n                    return [].indexOf(element);\n                }\n\n                let children = Array.from(element.parent().children());\n\n                if (childrenSelector) {\n                    children = children.filter(x => x.matches(childrenSelector));\n                }\n\n                return Array.from(children).indexOf(element[0]);\n            },\n\n            destroy: function() {\n                const that = this;\n\n                Widget.fn.destroy.call(that);\n\n                that.element.off(NS);\n                that.element.empty();\n\n                that._resizable.destroy();\n                kendo.destroy(that.element);\n            }\n        });\n\n        const DockManager = Widget.extend({\n            init: function(element, options) {\n                const that = this;\n\n                Widget.fn.init.call(that, element, options);\n                options = $.extend(true, {}, options);\n                that.element.addClass(DOCK_MANAGER);\n\n                that.panesContainer = $(`<div class=\"${KPANES_CONTAINER}\" />`).appendTo(that.element);\n                that._processPanes(that.options.rootPane);\n                that._refreshToolbar();\n                that._createPane(that.panesContainer, that.options.rootPane);\n                that._bindEvents();\n                that._initNavigator();\n                that._initUnpinnedResizable();\n\n                kendo.notify(that);\n            },\n\n            events: [\n                CLOSE,\n                PIN,\n                UNPIN,\n                DOCK,\n                INNER_DOCK,\n                RESIZE,\n                DRAG,\n                DRAGSTART,\n                DRAGEND\n            ],\n\n            options: {\n                name: 'DockManager',\n                rootPane: {\n                    type: SPLIT,\n                    orientation: HORIZONTAL,\n                    panes: []\n                }\n            },\n\n            paneDefaults: {\n                visible: true,\n                closeable: true,\n                collapsed: false,\n                size: ''\n            },\n\n            actions: [\n                {\n                    name: \"pin\",\n                    icon: \"unpin\",\n                    shouldAdd: pane => pane.unpinnable && pane.unpinnable.unpinned\n                },{\n                    name: \"unpin\",\n                    icon: \"pin\",\n                    shouldAdd: pane => pane.unpinnable && !pane.unpinnable.unpinned\n                },{\n                    name: \"minimize\",\n                    icon: \"minimize\",\n                    shouldAdd: pane => pane.minimizable\n                },{\n                    name: \"maximize\",\n                    icon: \"maximize\",\n                    shouldAdd: pane => pane.maximizable\n                },{\n                    name: \"close\",\n                    icon: \"x\",\n                    shouldAdd: pane => pane.closeable != false\n                },{\n                    name: \"more\",\n                    icon: \"more-vertical\",\n                    shouldAdd: pane => false //not needed for v1 as currently only 2 actions are available\n                }\n            ],\n\n            indicators: [\n                {\n                    name: TOP,\n                    top: 0,\n                    left: \"50%\",\n                    transform: \"translate(-50%, 0)\",\n                    previewTop: () => 0,\n                    previewLeft: () => 0,\n                    rotate: \"0deg\"\n                },{\n                    name: BOTTOM,\n                    top: \"100%\",\n                    left: \"50%\",\n                    transform: \"translate(-50%, -100%)\",\n                    previewTop: (hoveredPaneHeight, draggedPaneHeight) => hoveredPaneHeight - draggedPaneHeight,\n                    previewLeft: () => 0,\n                    rotate: \"180deg\"\n                },{\n                    name: LEFT,\n                    top: \"50%\",\n                    left: 0,\n                    transform: \"translate(0, -50%)\",\n                    previewTop: () => 0,\n                    previewLeft: () => 0,\n                    rotate: \"270deg\"\n                },{\n                    name: RIGHT,\n                    top: \"50%\",\n                    left: \"100%\",\n                    transform: \"translate(-100%, -50%)\",\n                    previewTop: () => 0,\n                    previewLeft: (hoveredPaneWidth, draggedPaneWidth) => hoveredPaneWidth - draggedPaneWidth,\n                    rotate: \"90deg\"\n                },{\n                    name: MIDDLE,\n                    previewTop: () => 0,\n                    previewLeft: () => 0,\n                }\n            ],\n\n            togglePane: function(id) {\n                const that = this,\n                pane = that._getPaneById(that.options.rootPane, \"id\", id);\n\n                if (pane != undefined$1) {\n                    that._togglePane(pane);\n                }\n            },\n\n            removePane: function(id) {\n                const that = this;\n                const pane = that._getPaneById(that.options.rootPane, \"id\", id);\n\n                if (pane != undefined$1) {\n                    that._removePane(pane);\n                }\n            },\n\n            getOptions: function() {\n                const that = this;\n                return that.options;\n            },\n\n            setOptions: function(options) {\n                const that = this;\n                let currentOptions = that.getOptions();\n                kendo.deepExtend(currentOptions, options);\n\n                that.destroy();\n                that.element.empty();\n\n                that.init(that.element, currentOptions);\n\n            },\n\n            _initUnpinnedResizable: function() {\n                const that = this;\n\n                that._unpinnedResizable = new kendo.ui.Resizable(that.unpinnedContainer, {\n                    orientation: HORIZONTAL,\n                    handle: \".k-splitbar-horizontal.k-splitbar-draggable-horizontal\",\n                    resize: function(e) {\n                        const delta = e.x.delta;\n                        const containerWidth = that.unpinnedContainer.width();\n\n                        that.unpinnedContainer.width(containerWidth + delta);\n                    }\n                });\n            },\n\n            _bindEvents: function() {\n                const that = this;\n\n                that.element.on(CLICK + NS, `.k-dock-manager-toolbar .${KBUTTON}`, that._toolbarButtonClick.bind(that));\n                that.element.on(CLICK + NS, `.${KPANES_CONTAINER}`, that._hideUnpinnedPanes.bind(that));\n                that.element.on(CLICK + NS, `.${KBUTTON}[${ACTION_ATTR}=\"pin\"], .${KBUTTON}[${ACTION_ATTR}=\"unpin\"]`, that._pinPaneClick.bind(that));\n                that.element.on(CLICK + NS, `.${KBUTTON}[${ACTION_ATTR}=\"close\"]`, that._closePane.bind(that));\n                that.element.on(\"mouseenter\" + NS, `.${KDOCK_INDICATOR}`, that._displayDockPreview.bind(that));\n                that.element.on(\"mouseleave\" + NS, `.${KDOCK_INDICATOR}`, that._hideDockPreview.bind(that));\n            },\n\n            _hideUnpinnedPanes: function(e) {\n                const that = this;\n                const unpinnedPanes = that.unpinnedContainer.find(`.${KPANE}`);\n                const currentlyOpened = unpinnedPanes.filter(\":visible\");\n                const unpinnedContainerVisible = that.unpinnedContainer.is(\":visible\");\n\n                if (currentlyOpened && unpinnedContainerVisible) {\n                    that._toolbar.find(`.${KSELECTED}`).removeClass(KSELECTED);\n                    that.unpinnedContainer.addClass(KHIDDEN);\n                    return;\n                }\n            },\n\n            _toolbarButtonClick: function(e) {\n                const that = this;\n                const itemUid = $(e.currentTarget).attr(UID_ATTR);\n                const unpinnedPanes = that.unpinnedContainer.find(`.${KPANE}`);\n                const currentlyOpened = unpinnedPanes.filter(\":visible\");\n                const unpinnedContainerVisible = that.unpinnedContainer.is(\":visible\");\n\n                e.preventDefault();\n                that._toolbar.find(`.${KBUTTON}`).removeClass(KSELECTED);\n\n                if (currentlyOpened.attr(UID_ATTR) === itemUid && unpinnedContainerVisible) {\n                    that.unpinnedContainer.addClass(KHIDDEN);\n                    return;\n                }\n\n                that._showUnpinnedPane(itemUid);\n            },\n\n            _showUnpinnedPane: function(paneUid) {\n                const that = this;\n                const toolbarWidth = that._toolbar.outerWidth();\n                const pane = that._findPaneByUid(paneUid);\n                const hasUnpinnedSize = pane.unpinnable.unpinnedSize;\n\n                that.unpinnedContainer.removeClass(KHIDDEN).css({ left: `${toolbarWidth}px` });\n                that.unpinnedContainer.find(`.${KPANE}`).addClass(KHIDDEN);\n                that.unpinnedContainer.find(paneSelector(paneUid)).removeClass(KHIDDEN);\n\n                if (hasUnpinnedSize) {\n                    that.unpinnedContainer.css({ width: `${pane.unpinnable.unpinnedSize}` });\n                }\n\n                that._toolbar.find(`.${KBUTTON}[${UID_ATTR}=\"${paneUid}\"]`).addClass(KSELECTED);\n            },\n\n            _pinPaneClick: function(e) {\n                const that = this;\n                const button = $(e.currentTarget);\n                const isTabbed = button.parent().is(\"li\");\n                const action = button.attr(ACTION_ATTR);\n                const paneElement = isTabbed ? button.parent() : $(e.currentTarget).closest(`.${KPANE}`);\n                const pane = that._findPaneByUid(paneElement.attr(UID_ATTR));\n                const isUnpinned = pane.unpinnable.unpinned;\n                const parentPane = that._findPaneByUid(pane.parentUid);\n                const parentPaneElement = that.panesContainer.find(`.${KPANE}[${UID_ATTR}=\"${parentPane.uid}\"], .${SPLITTER}[${UID_ATTR}=\"${parentPane.uid}\"]`);\n                const eventData = { pane: pane, paneElement: paneElement };\n\n                if (isUnpinned) {\n                    kendo.destroy(paneElement);\n                    paneElement.remove();\n                }\n\n                pane.unpinnable.unpinned = action === PIN ? false : true;\n                that._refreshRootPane();\n                that.unpinnedContainer.toggleClass(KHIDDEN, action === PIN);\n\n                if (action === \"pin\") {\n                    that.trigger(PIN, eventData);\n                    return;\n                }\n\n                that.trigger(UNPIN, eventData);\n                that._showUnpinnedPane(pane.uid);\n            },\n\n            _closePane: function(e) {\n                const that = this;\n                const button = $(e.currentTarget);\n                const isTabbed = button.parent().is(\"li\");\n                const paneElement = isTabbed ? button.parent() : $(e.currentTarget).closest(`.${KPANE}`);\n                const pane = that._findPaneByUid(paneElement.attr(UID_ATTR));\n                const parentPane = that._findPaneByUid(pane.parentUid);\n                const parentPaneElement = that.panesContainer.find(`.${KPANE}[${UID_ATTR}=\"${parentPane.uid}\"], .${SPLITTER}[${UID_ATTR}=\"${parentPane.uid}\"]`);\n                const paneIndex = parentPane.panes.indexOf(pane);\n                const eventData = { pane: pane, paneElement: paneElement, event: e };\n\n                if (that.trigger(CLOSE, eventData)) {\n                    e.preventDefault();\n                }\n\n                if (pane.unpinnable && pane.unpinnable.unpinned) {\n                    that.unpinnedContainer.addClass(KHIDDEN);\n                }\n\n                parentPane.panes.splice(paneIndex, 1);\n\n                if (that._shouldHideParent(parentPane)) {\n                    parentPane.visible = false;\n                }\n\n                that._refreshRootPane();\n            },\n\n            _shouldHideParent: function(pane) {\n                const that = this,\n                parent = that._findPaneByUid(pane.parentUid);\n\n                if (pane.panes.length == 0) {\n                    if (pane.type == TAB && parent.panes.length == 1) {\n                        parent.panes.splice(0,1);\n                        parent.visible = false;\n                    }\n                    return true;\n                }\n\n                if (pane.panes.length == 1 &&\n                    pane.panes[0].type == TAB &&\n                    !pane.panes.some(x => x.visible)) {\n                    return true;\n                }\n\n                return false;\n            },\n\n            _refreshPane: function(paneElement, pane) {\n                const that = this;\n                const parentElement = paneElement.parent();\n                const isTabbed = paneElement.is(`.${KPANE_TABBED}`);\n\n                kendo.destroy(paneElement);\n                isTabbed ? paneElement.empty() : paneElement.remove();\n                that._refreshToolbar();\n                that._createPane(isTabbed ? paneElement : parentElement, pane);\n            },\n\n            _processPanes: function(pane) {\n                const that = this;\n                pane.uid = pane.uid || kendo.guid();\n                that._extendPane(pane);\n\n                if (pane.type === SPLIT && !pane.orientation) {\n                    pane.orientation = HORIZONTAL;\n                }\n\n                pane.panes.forEach((childPane) => {\n                    childPane.parentUid = pane.uid;\n\n                    if (childPane.type == CONTENT) {\n                        if (childPane.unpinnable === undefined$1 || childPane.unpinnable === true) {\n                            childPane.unpinnable = {\n                                unpinned: false\n                            };\n                        }\n                        childPane.uid = childPane.uid || kendo.guid();\n                    }\n\n                    if (childPane.panes && childPane.panes.length) {\n                        that._processPanes(childPane);\n                    }\n                });\n            },\n\n            _extendPane: function(pane) {\n                const that = this;\n\n                if (pane.panes) {\n                    for (var j = 0; j < pane.panes.length; j++) {\n                        pane.panes.forEach(subItem => {\n                            that._extendPane(subItem);\n                        });\n                    }\n                }\n\n                extend(pane, {\n                    visible: pane.visible === undefined$1 ? that.paneDefaults.visible : pane.visible,\n                    closeable: pane.closeable === undefined$1 ? that.paneDefaults.closeable : pane.closeable,\n                    collapsed: pane.collapsed === undefined$1 ? that.paneDefaults.collapsed : pane.collapsed,\n                    size: pane.size === undefined$1 ? that.paneDefaults.size : pane.size,\n                });\n            },\n\n            _togglePane: function(pane) {\n                const that = this;\n\n                pane.visible = !pane.visible;\n                that._refreshRootPane();\n            },\n\n            _removePane: function(pane) {\n                const that = this;\n                const parentPane = that._findPaneByUid(pane.parentUid);\n                const paneIndex = parentPane.panes.indexOf(pane);\n                const parentPaneElement = that.panesContainer.find(`[${UID_ATTR}=\"${pane.uid}\"]`).parent();\n\n                parentPane.panes.splice(paneIndex, 1);\n                that._refreshRootPane();\n            },\n\n            _refreshToolbar: function() {\n                const that = this;\n                const unpinnedPanes = that._unpinnedPanes();\n                const unpinnedPannesContainer = $(`<div class=\"${KHIDDEN}\"/>`).addClass(KUNPINNED_CONTAINER);\n\n                if (!that.unpinnedContainer) {\n                    that.unpinnedContainer = unpinnedPannesContainer;\n                    unpinnedPannesContainer.append(unpinnedResizeSplitbar);\n                    unpinnedPannesContainer.insertBefore(that.panesContainer);\n                }\n\n                if (!unpinnedPanes.length) {\n                    that._toolbar && that._toolbar.remove();\n                    that._toolbar = null;\n                    return;\n                }\n\n                if (!that._toolbar) {\n                    that._toolbar = that.element.prepend(TOOLBAR_TEMPLATE).find(`.${DOCK_MANAGER_TOOLBAR}`);\n                }\n\n                that._toolbar.empty();\n\n                for (let i = 0; i < unpinnedPanes.length; i++) {\n                    const pane = unpinnedPanes[i];\n                    const button = $(kendo.html.renderButton({ fillMode: \"flat\", size: \"medium\" }))\n                                    .addClass(TOOLBAR_BUTTON)\n                                    .append(buttonTextTemplate(that._paneHeader(pane)));\n\n                    button.attr(UID_ATTR, pane.uid);\n                    that._toolbar.append(button);\n\n                    if (i < unpinnedPanes.length - 1) {\n                        that._toolbar.append(SEPARATOR);\n                    }\n                }\n            },\n\n            destroy: function() {\n                const that = this;\n\n                Widget.fn.destroy.call(that);\n\n                that.element.off(NS);\n                that.element.empty();\n\n                kendo.destroy(that.wrapper);\n            },\n\n            refresh: function() {\n                const that = this;\n                kendo.destroy(that.unpinnedContainer);\n                that.unpinnedContainer.empty();\n                that._refreshRootPane();\n            },\n\n            _refreshRootPane: function() {\n                const that = this;\n                const rootPaneElement = that.element.find(`[${UID_ATTR}=\"${that.options.rootPane.uid}\"]`);\n\n                that._refreshPane(rootPaneElement, that.options.rootPane);\n            },\n\n            _createSplitPane: function(parentElement, pane) {\n                const that = this;\n                const splitterElement = $(\"<div/>\").attr(UID_ATTR, pane.uid);\n                const splitterOptions = {\n                    orientation: pane.orientation || HORIZONTAL,\n                    panes: []\n                };\n\n                if (!pane.panes.some(x=>x.visible)) {\n                    return;\n                }\n\n                parentElement.append(splitterElement);\n\n                pane.panes.forEach((childPane) => {\n                    const paneOptions = {\n                        uid: childPane.uid\n                    };\n                    const paneElement = $(PANE).removeClass(KSTATIC_PANE);\n\n                    if (childPane.unpinnable && childPane.unpinnable.unpinned) {\n                        that._createUnpinnedPane(childPane);\n                        return;\n                    }\n\n                    if (childPane.size) {\n                        paneOptions.size = childPane.size;\n                    }\n\n                    if (childPane.visible != undefined$1) {\n                        paneOptions.visible = childPane.visible;\n                    }\n\n                    if (childPane.visible) {\n                        splitterElement.append(paneElement);\n                        that._createPane(paneElement, childPane);\n                        splitterOptions.panes.push(paneOptions);\n                    }\n                });\n\n               pane.splitter = new DockSplitter(splitterElement, splitterOptions); // eslint-disable-line no-new\n               pane.splitter.bind(RESIZE, that._updatePaneSize.bind(that));\n            },\n\n            _updatePaneSize: function(e) {\n                const that = this;\n                const leftPane = that._findPaneByUid(e.leftPane.uid),\n                rightPane = that._findPaneByUid(e.rightPane.uid);\n\n                leftPane.size = e.leftPane.size;\n                rightPane.size = e.rightPane.size;\n                that.trigger(RESIZE, { ev: e, leftPane: leftPane, rightPane: rightPane });\n            },\n\n            _createTabPane: function(parentElement, pane) {\n                const that = this;\n                const tabStripElement = $(\"<div class='k-header'/>\");\n                const tabContainer = $(\"<ul/>\");\n                const tabStripOptions = {\n                    animation: false\n                };\n                const selectedPane = (pane.selected === undefined$1 || pane.panes.indexOf(pane.panes[pane.selected]) == -1 || pane.panes[pane.selected].unpinnable.unpinned) ? 0 : pane.selected;\n\n                if (!pane.panes.some(x=>x.visible)) {\n                    return;\n                }\n\n                tabStripElement.append(tabContainer);\n                parentElement.append(tabStripElement);\n                parentElement.attr(UID_ATTR, pane.uid);\n                parentElement.addClass(KPANE_TABBED);\n\n                pane.panes.forEach((childPane) => {\n                    const tab = $(tabTemplate(that._paneHeader(childPane))).attr(UID_ATTR, childPane.uid);\n                    const contentElement = $(\"<div/>\");\n\n                    if (childPane.unpinnable && childPane.unpinnable.unpinned) {\n                        that._createUnpinnedPane(childPane);\n                        return;\n                    }\n\n                    if (childPane.visible) {\n                        that._addActions(tab, childPane);\n                        tabContainer.append(tab);\n                        tabStripElement.append(contentElement);\n                        that._createPane(contentElement, childPane);\n                    }\n                });\n\n                $(tabContainer.children()[selectedPane]).addClass(KACTIVE);\n                tabStripElement.kendoTabStrip(tabStripOptions);\n            },\n\n            _createContentPane: function(parentElement, pane) {\n                const that = this;\n                const content = typeof pane.content === \"function\" ? kendo.template(pane.content)({}) : pane.content;\n                const element = $(contentPaneTemplate(extend({}, pane, { title: that._paneHeader(pane), content: content })));\n                const parentPane = that._findPaneByUid(pane.parentUid);\n                const isUnnpinned = pane.unpinnable && pane.unpinnable.unpinned;\n\n\n                if (parentPane && parentPane.type === TAB && !isUnnpinned) {\n                    parentElement.append(content);\n                    return;\n                }\n\n                parentElement.addClass(KKPINNED_PANE)\n                             .removeClass(KSTATIC_PANE)\n                             .attr(UID_ATTR, pane.uid);\n                that._addActions(element.find(`.${KPANE_ACTIONS}`), pane);\n                parentElement.append(element);\n            },\n\n            _createUnpinnedPane: function(pane) {\n                const that = this;\n                const paneElement = $(PANE).removeClass(KSTATIC_PANE);\n\n                if (that.unpinnedContainer.find(paneSelector(pane.uid)).length) {\n                    return;\n                }\n\n                that.unpinnedContainer.prepend(paneElement);\n                that._createContentPane(paneElement, pane);\n            },\n\n            _addActions: function(actionsContainer, pane) {\n                const that = this;\n\n                that.actions.forEach((action) => {\n                    if (action.shouldAdd(pane)) {\n                        actionsContainer.append($(kendo.html.renderButton({ fillMode: \"flat\", icon: action.icon })).attr(ACTION_ATTR, action.name));\n                    }\n                });\n\n            },\n\n            _createPane: function(parentElement, pane) {\n                const that = this;\n\n                if (pane.id) {\n                    parentElement.attr(\"id\", pane.id);\n                }\n\n                return that[\"_create\" + capitalizeFirstLetter(pane.type) + \"Pane\"](parentElement, pane);\n            },\n\n            _unpinnedPanes: function(panes) {\n                const that = this;\n                const options = that.options;\n                let result = [];\n\n                if (!panes) {\n                    panes = options.rootPane.panes;\n                }\n\n                panes.forEach((pane) => {\n                    if (pane.unpinnable && pane.unpinnable.unpinned) {\n                        result.push(pane);\n                    }\n\n                    if (pane.panes && pane.panes.length) {\n                        result = result.concat(that._unpinnedPanes(pane.panes));\n                    }\n                });\n\n                return result;\n            },\n\n            _paneHeader: function(pane) {\n                const that = this;\n                const parentPane = that._findPaneByUid(pane.parentUid);\n                const isTabbed = parentPane && parentPane.type === \"tab\";\n                let header = pane.header;\n\n                if (isTabbed && pane.tabHeader) {\n                    header = pane.tabHeader;\n                }\n\n                if (!header) {\n                    return pane.title || \"\";\n                }\n\n                return kendo.template(header)(pane);\n            },\n\n            _findPaneByUid: function(uid, parent) {\n                const that = this;\n                let found;\n\n                parent = parent || that.options.rootPane;\n\n                if (parent.uid === uid) {\n                    return parent;\n                }\n\n                parent.panes.forEach((pane) => {\n                    if (pane.uid === uid) {\n                        found = pane;\n                        return;\n                    }\n\n                    if (pane.panes && pane.panes.length) {\n                        const result = that._findPaneByUid(uid, pane);\n\n                        if (result) {\n                            found = result;\n                            return;\n                        }\n                    }\n                });\n                return found;\n            },\n\n            _getPaneById: function(pane, prop, value) {\n                const that = this;\n                let found;\n\n                if (pane[prop] == value) {\n                    return pane;\n                }\n\n                if (pane.panes) {\n                    pane.panes.forEach((childPane) => {\n                        let result = that._getPaneById(childPane, prop, value);\n                        if (result) {\n                            found = result;\n                        }\n                    });\n                }\n                return found;\n            },\n\n            _initNavigator: function(params) {\n                const that = this;\n\n                that.navigatorDraggable = new kendo.ui.Draggable(that.element, {\n                    autoScroll: true,\n                    filter: \".k-pane-header, .k-pane-tabbed .k-tabstrip-item\",\n                    hint: function(element) {\n                        const isTabbed = element.is(\"li\");\n                        const paneElement = element.closest(`.${KPANE}`);\n                        const pane = that._findPaneByUid((isTabbed ? element : paneElement).attr(UID_ATTR));\n                        const actionsHtml = isTabbed ? that._getActionButtons(element) : paneElement.find(`.${KPANE_ACTIONS}`).html();\n\n                        return hintTemplate({\n                            width: paneElement.width(),\n                            height: paneElement.height(),\n                            content: pane.content,\n                            title: that._paneHeader(pane),\n                            actions: actionsHtml\n                        });\n                    },\n                    dragstart: that._dragStart.bind(that),\n                    dragend: that._dragEnd.bind(that),\n                    drag: that._drag.bind(that)\n                });\n            },\n\n            _dragStart: function(e) {\n                const that = this;\n                const target = $(e.currentTarget);\n                const pane = target.closest(`.${KPANE}`);\n\n                that.draggedPane = {\n                    width: pane.width(),\n                    height: pane.height(),\n                    pane,\n                    target\n                };\n\n                that._displayGlobalIndicators();\n\n                that.trigger(DRAGSTART, { pane: that.draggedPane.pane, draggableEvent: e });\n            },\n\n            _dragEnd: function(e) {\n                const that = this;\n                const hoveredIndicator = that.element.find(`.${KDOCK_INDICATOR}:hover`);\n                const eventData = { pane: that.draggedPane.pane, draggableEvent: e };\n\n                if (hoveredIndicator.length) {\n                    that.navigatorDraggable.hint.hide();\n                    that._updateLayout(hoveredIndicator);\n                }\n\n                that.element.find(`.${KDOCK_INDICATOR}`).remove();\n                that.element.find(`.${KDOCK_PREVIEW}`).remove();\n\n                if (!hoveredIndicator.length) {\n                    that._showHiddenPanes();\n                }\n                that.trigger(DRAGEND, eventData);\n                that.hoveredPane = null;\n                that.draggedPane = null;\n            },\n\n            _drag: function(e) {\n                const that = this;\n                const currentPane = $(e.elementUnderCursor).closest(`.${KPANE}[${UID_ATTR}]`);\n                const pane = that._findPaneByUid(currentPane.attr(UID_ATTR));\n                const navigator = $(NAVIGATOR_TEMPLATE);\n                const currentPaneUid = currentPane.attr(UID_ATTR);\n                const prevPaneUid = that.hoveredPane && that.hoveredPane.attr(UID_ATTR);\n                var eventData = { pane: that.draggedPane.pane, draggableEvent: e };\n\n                if (that.trigger(DRAG, eventData)) {\n                    e.preventDefault();\n                    return;\n                }\n\n                if (currentPaneUid === prevPaneUid) {\n                    return;\n                }\n\n                that.hoveredPane = currentPane;\n                that.element.find(`.${KDOCK_NAVIGATOR}`).remove();\n                navigator.css({\n                    position: \"absolute\",\n                    top: \"50%\",\n                    left: \"50%\",\n                    transform: \"translate(-50%,-50%)\",\n                    \"z-index\": 100008\n                });\n\n                if (pane && pane.dockable && !pane.dockable.innerDock) {\n                    navigator.css(\"display\", \"none\");\n                }\n\n                currentPane.append(navigator);\n            },\n\n            _showHiddenPanes: function() {\n                const that = this;\n                const isTabbed = that.draggedPane.pane.is(`.${KPANE_TABBED}`);\n\n                if (isTabbed) {\n                    return that._showTab();\n                }\n\n                that._showPane(that.draggedPane.pane);\n            },\n\n            _showTab: function(tab) {\n                if (tab === undefined$1) {\n                    return;\n                }\n\n                const that = this;\n                const tabstrip = tab.closest(`.${KTABSTRIP}`).data(\"kendoTabStrip\");\n\n                tab.show();\n                tabstrip.activateTab(tab);\n            },\n\n            _showPane: function(paneElement) {\n                const that = this;\n                const splitbar = paneElement.siblings(`.${KSPLITBAR}:hidden`);\n                paneElement.show();\n                splitbar.show();\n            },\n\n            _hideDraggedPane: function(draggedElement) {\n                const that = this;\n                const isTabbed = draggedElement.is(\"li\");\n\n                if (isTabbed) {\n                    return that._hideTab(draggedElement);\n                }\n\n                that._hidePane(draggedElement);\n            },\n\n            _hidePane: function(draggedElement) {\n                const that = this;\n                const paneElement = draggedElement.closest(`.${KPANE}`);\n                const prevElement = paneElement.prev();\n                const nextElement = paneElement.next();\n\n                paneElement.hide();\n\n                if (prevElement.is(`.${KSPLITBAR}`)) {\n                    return prevElement.hide();\n                }\n\n                nextElement.hide();\n            },\n\n            _hideTab: function(tab) {\n                const that = this;\n                const isActive = tab.is(`.${KACTIVE}`);\n                const tabstrip = tab.closest(`.${KTABSTRIP}`).data(\"kendoTabStrip\");\n\n                tab.hide();\n\n                if (isActive) {\n                    tabstrip.activateTab(\"li:visible:first\");\n                }\n            },\n\n            _getActionButtons: function(paneElement) {\n                const buttons = paneElement.find(\"button\");\n                const container = $(\"<div/>\");\n\n                buttons.each((_, button) => container.append($(button).clone()));\n\n                return container.html();\n            },\n\n            _displayGlobalIndicators: function() {\n                const that = this;\n\n                that.indicators.forEach((indicator) => {\n                    const element = $(INDICATOR_TEMPLATE);\n\n                    if (indicator.name === \"middle\") {\n                        return;\n                    }\n\n                    that.element.append(element);\n                    element.css({\n                        position: \"absolute\",\n                        \"z-index\": \"100002\",\n                        top: indicator.top,\n                        left: indicator.left,\n                        transform: `${indicator.transform} rotate(${indicator.rotate})`\n                    });\n                    element.attr(INDICATOR_ATTR, indicator.name);\n                });\n            },\n\n            _displayDockPreview: function(e) {\n                const that = this;\n                const indicator = $(e.currentTarget);\n                const isGlobalIndicator = !indicator.parent().is(`.${KDOCK_NAVIGATOR}`);\n                const indicatorName = indicator.attr(INDICATOR_ATTR);\n                const indicatorUid = indicator.attr(UID_ATTR);\n                const indicatorData = that.indicators.filter(i => i.name === indicatorName)[0];\n                const previewElement = $(`<div class=\"${KDOCK_PREVIEW}\"/>`);\n                const container = isGlobalIndicator ? that.panesContainer : that.hoveredPane;\n                const toolbarWidth = that._toolbar ? that._toolbar.outerWidth() : 0;\n                const containerWidth = container.outerWidth();\n                const containerHeight = container.outerHeight();\n                const existingPreview = indicatorUid && container.find(`.${KDOCK_PREVIEW}[${UID_ATTR}=\"${indicatorUid}\"]`);\n                const uid = kendo.guid();\n                let width = that.draggedPane.width;\n                let height = that.draggedPane.height;\n\n                if (existingPreview && existingPreview.length) {\n                    return existingPreview.show();\n                }\n\n                if (indicatorName === MIDDLE) {\n                    width = containerWidth;\n                    height = containerHeight;\n                }\n\n                if (indicatorName === TOP || indicatorName === BOTTOM) {\n                    if (height > containerHeight / 2) {\n                        height = containerHeight / 2;\n                    }\n\n                    width = containerWidth;\n                }\n\n                if (indicatorName === LEFT || indicatorName === RIGHT) {\n                    if (width > containerWidth / 2) {\n                        width = containerWidth / 2;\n                    }\n\n                    height = containerHeight;\n                }\n\n                const css = {\n                    position: \"absolute\",\n                    \"z-index\": 100000,\n                    top: indicatorData.previewTop(containerHeight, height),\n                    left: indicatorData.previewLeft(containerWidth, width) + (isGlobalIndicator ? toolbarWidth : 0),\n                    width: width,\n                    height\n                };\n\n                previewElement.css(css);\n                previewElement.attr(INDICATOR_ATTR, indicatorData.name)\n                              .attr(UID_ATTR, uid);\n                indicator.attr(UID_ATTR, uid);\n                container.append(previewElement);\n                that.draggedPane.preview = {\n                    width,\n                    height\n                };\n                that.draggedPane.container = {\n                    width: containerWidth,\n                    height: containerHeight\n                };\n            },\n\n            _hideDockPreview: function() {\n                const that = this;\n\n                that.element.find(`.${KDOCK_PREVIEW}`).hide();\n            },\n\n            _updateLayout: function(indicator) {\n                const that = this;\n                const isTabbed = that.draggedPane.target.is(\"li\");\n                const isGlobalIndicator = !indicator.parent().is(`.${KDOCK_NAVIGATOR}`);\n                const paneElement = isTabbed ? that.draggedPane.target : that.draggedPane.pane;\n                const hoveredPane = that._findPaneByUid(that.hoveredPane.attr(UID_ATTR));\n                const draggedPane = that._findPaneByUid(paneElement.attr(UID_ATTR));\n                const location = indicator.attr(INDICATOR_ATTR);\n                const draggedPaneParent = that._findPaneByUid(draggedPane.parentUid);\n                const draggedPaneIndex = draggedPaneParent.panes.indexOf(draggedPane);\n                const rootPaneElement = that.element.find(`[${UID_ATTR}=\"${that.options.rootPane.uid}\"]`);\n\n                draggedPaneParent.panes.splice(draggedPaneIndex, 1);\n                location == MIDDLE ? that._tabDock(hoveredPane, draggedPane) : that._splitDock(hoveredPane, draggedPane, location, isGlobalIndicator);\n                that._processPanes(that.options.rootPane);\n                that._adjustSiblingSizes(draggedPane, location, isGlobalIndicator);\n                that._refreshPane(rootPaneElement, that.options.rootPane);\n                location == MIDDLE ?\n                    that.trigger(INNER_DOCK, { pane: draggedPane, paneElement: paneElement }) :\n                    that.trigger(DOCK, { pane: draggedPane, paneElement: paneElement });\n            },\n\n            _splitDock: function(targetPane, pane, location, isGlobalDock) {\n                const that = this;\n                const targetPaneParent = isGlobalDock ? that.options.rootPane : that._findPaneByUid(targetPane.parentUid);\n                const targetPaneIndex = targetPaneParent.panes.indexOf(targetPane);\n                const action = location === TOP || location === LEFT ? UNSHIFT : PUSH;\n                const paneIndex = targetPaneIndex + (action === UNSHIFT ? 0 : 1);\n                const orientation = location === TOP || location === BOTTOM ? VERTICAL : HORIZONTAL;\n                const dimension = location === TOP || location === BOTTOM ? HEIGHT : WIDTH;\n                const newParentPane = {\n                    type: SPLIT,\n                    orientation,\n                    panes: [],\n                };\n                const previewSize = that.draggedPane.preview[dimension];\n                const size = `${previewSize}px`;\n\n                pane.size = size;\n\n                if (isGlobalDock) {\n                    newParentPane.panes.push(targetPaneParent);\n                    (location === TOP || location === LEFT) ? newParentPane.panes.unshift(pane) : newParentPane.panes.push(pane);\n                    that.options.rootPane = newParentPane;\n                    return;\n                }\n\n                if (((location === TOP || location === BOTTOM) && targetPaneParent.orientation === VERTICAL) ||\n                    ((location === LEFT || location === RIGHT) && targetPaneParent.orientation === HORIZONTAL)) {\n                    return targetPaneParent.panes.splice(paneIndex, 0, pane);\n                }\n\n                if (targetPane) {\n                    newParentPane.size = targetPane.size;\n                    targetPane.size = null;\n                }\n\n                targetPaneParent.panes.splice(targetPaneIndex, 1);\n                newParentPane.panes.push(targetPane);\n                newParentPane.panes[action](pane);\n                targetPaneParent.panes.splice(targetPaneIndex, 0, newParentPane);\n            },\n\n            _tabDock: function name(targetPane, pane) {\n                const that = this;\n                const targetPaneParent = that._findPaneByUid(targetPane.parentUid);\n                const targetPaneIndex = targetPaneParent.panes.indexOf(targetPane);\n                const newParentPane = {\n                    type: TAB,\n                    panes: [\n                        targetPane,\n                        pane\n                    ]\n                };\n\n                if (targetPane.type === TAB) {\n                    targetPane.panes.push(pane);\n                    return;\n                }\n\n                targetPaneParent.panes.splice(targetPaneIndex, 1);\n                targetPaneParent.panes.splice(targetPaneIndex, 0, newParentPane);\n\n            },\n\n            _adjustSiblingSizes: function(pane, location, isGlobalDock) {\n                const that = this;\n                const siblings = that._getSiblings(pane);\n                const dimension = location === TOP || location === BOTTOM ? HEIGHT : WIDTH;\n                const parentSize = that.draggedPane.container[dimension];\n                const draggedPaneSize = that.draggedPane[dimension];\n                const newParentSize = parentSize - draggedPaneSize;\n                const noSizePanes = [];\n                let freeSpace = newParentSize;\n\n                if (location === MIDDLE) {\n                    return;\n                }\n\n                if (siblings.length === 2) {\n                    siblings[0].size = null;\n                    return;\n                }\n\n                siblings.forEach((childPane) => {\n                    if (childPane.uid === pane.uid) {\n                        return;\n                    }\n\n                    if (!childPane.size) {\n                        noSizePanes.push(childPane);\n                        return;\n                    }\n\n                    childPane.size = that._calculateNewSize(parentSize, newParentSize, childPane.size);\n                    freeSpace -= childPane.size;\n                });\n\n                noSizePanes.forEach((noSizePane) => {\n                    const newSize = freeSpace / noSizePanes.length;\n\n                    noSizePane.size = newSize;\n                });\n\n            },\n\n            _calculateNewSize: function(parentSize, newParentSize, paneSize) {\n                const proportion = newParentSize / parentSize;\n                let unit = \"px\";\n                let noUnitSize;\n\n                if (isPercentageSize(paneSize)) {\n                    unit = \"%\";\n                }\n\n                noUnitSize = +paneSize.replace(unit, \"\");\n\n                return `${noUnitSize * proportion}${unit}`;\n            },\n\n            _getSiblings: function(pane) {\n                const that = this;\n                const parent = that._findPaneByUid(pane.parentUid);\n\n                return parent.panes.filter(p => p.visible !== false &&\n                                                p.uid !== pane.uid &&\n                                                (p.unpinnable && p.unpinnable.unpinned !== true));\n            }\n        });\n\n        ui.plugin(DockManager);\n    })(window.kendo.jQuery);\n    var kendo$1 = kendo;\n\n    return kendo$1;\n\n}));\n"]}